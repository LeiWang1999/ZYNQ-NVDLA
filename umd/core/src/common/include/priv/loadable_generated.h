// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LOADABLE_NVDLA_LOADABLE_H_
#define FLATBUFFERS_GENERATED_LOADABLE_NVDLA_LOADABLE_H_

#include "flatbuffers/flatbuffers.h"

namespace nvdla {
namespace loadable {

struct Version;

struct Blob;

struct MemoryListEntry;

struct EventListEntry;

struct TaskListEntry;

struct AddressListEntry;

struct SubmitListEntry;

struct TensorDescListEntry;

struct RelocListEntry;

struct Loadable;

enum Interface {
  Interface_NONE = 0,
  Interface_DLA1 = 1,
  Interface_EMU1 = 2,
  Interface_MIN = Interface_NONE,
  Interface_MAX = Interface_EMU1
};

inline const char **EnumNamesInterface() {
  static const char *names[] = {
    "NONE",
    "DLA1",
    "EMU1",
    nullptr
  };
  return names;
}

inline const char *EnumNameInterface(Interface e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesInterface()[index];
}

enum LoadableVersionMajor {
  LoadableVersionMajor_VAL = 0,
  LoadableVersionMajor_MIN = LoadableVersionMajor_VAL,
  LoadableVersionMajor_MAX = LoadableVersionMajor_VAL
};

inline const char **EnumNamesLoadableVersionMajor() {
  static const char *names[] = {
    "VAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameLoadableVersionMajor(LoadableVersionMajor e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLoadableVersionMajor()[index];
}

enum LoadableVersionMinor {
  LoadableVersionMinor_VAL = 7,
  LoadableVersionMinor_MIN = LoadableVersionMinor_VAL,
  LoadableVersionMinor_MAX = LoadableVersionMinor_VAL
};

inline const char **EnumNamesLoadableVersionMinor() {
  static const char *names[] = {
    "VAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameLoadableVersionMinor(LoadableVersionMinor e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(LoadableVersionMinor_VAL);
  return EnumNamesLoadableVersionMinor()[index];
}

enum LoadableVersionSubMinor {
  LoadableVersionSubMinor_VAL = 0,
  LoadableVersionSubMinor_MIN = LoadableVersionSubMinor_VAL,
  LoadableVersionSubMinor_MAX = LoadableVersionSubMinor_VAL
};

inline const char **EnumNamesLoadableVersionSubMinor() {
  static const char *names[] = {
    "VAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameLoadableVersionSubMinor(LoadableVersionSubMinor e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLoadableVersionSubMinor()[index];
}

enum MemoryDomain {
  MemoryDomain_SYSTEM = 0,
  MemoryDomain_SRAM = 1,
  MemoryDomain_MIN = MemoryDomain_SYSTEM,
  MemoryDomain_MAX = MemoryDomain_SRAM
};

inline const char **EnumNamesMemoryDomain() {
  static const char *names[] = {
    "SYSTEM",
    "SRAM",
    nullptr
  };
  return names;
}

inline const char *EnumNameMemoryDomain(MemoryDomain e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMemoryDomain()[index];
}

enum MemoryFlags {
  MemoryFlags_NONE = 0,
  MemoryFlags_ALLOC = 1,
  MemoryFlags_SET = 2,
  MemoryFlags_INPUT = 4,
  MemoryFlags_OUTPUT = 8,
  MemoryFlags_MIN = MemoryFlags_NONE,
  MemoryFlags_MAX = MemoryFlags_OUTPUT
};

inline const char **EnumNamesMemoryFlags() {
  static const char *names[] = {
    "NONE",
    "ALLOC",
    "SET",
    "",
    "INPUT",
    "",
    "",
    "",
    "OUTPUT",
    nullptr
  };
  return names;
}

inline const char *EnumNameMemoryFlags(MemoryFlags e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMemoryFlags()[index];
}

enum EventType {
  EventType_EVENTTYPE0 = 0,
  EventType_EVENTTYPE1 = 1,
  EventType_EVENTTYPE2 = 2,
  EventType_MIN = EventType_EVENTTYPE0,
  EventType_MAX = EventType_EVENTTYPE2
};

inline const char **EnumNamesEventType() {
  static const char *names[] = {
    "EVENTTYPE0",
    "EVENTTYPE1",
    "EVENTTYPE2",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventType(EventType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEventType()[index];
}

enum EventOp {
  EventOp_WAIT = 0,
  EventOp_SIGNAL = 1,
  EventOp_MIN = EventOp_WAIT,
  EventOp_MAX = EventOp_SIGNAL
};

inline const char **EnumNamesEventOp() {
  static const char *names[] = {
    "WAIT",
    "SIGNAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventOp(EventOp e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEventOp()[index];
}

enum DataFormat {
  DataFormat_UNKNOWN = 0,
  DataFormat_NCHW = 1,
  DataFormat_NHWC = 2,
  DataFormat_MIN = DataFormat_UNKNOWN,
  DataFormat_MAX = DataFormat_NHWC
};

inline const char **EnumNamesDataFormat() {
  static const char *names[] = {
    "UNKNOWN",
    "NCHW",
    "NHWC",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataFormat(DataFormat e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDataFormat()[index];
}

enum DataType {
  DataType_UNKNOWN = 0,
  DataType_FLOAT = 1,
  DataType_HALF = 2,
  DataType_INT16 = 3,
  DataType_INT8 = 4,
  DataType_MIN = DataType_UNKNOWN,
  DataType_MAX = DataType_INT8
};

inline const char **EnumNamesDataType() {
  static const char *names[] = {
    "UNKNOWN",
    "FLOAT",
    "HALF",
    "INT16",
    "INT8",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDataType()[index];
}

enum DataCategory {
  DataCategory_IMAGE = 0,
  DataCategory_WEIGHT = 1,
  DataCategory_FEATURE = 2,
  DataCategory_PLANAR = 3,
  DataCategory_BIAS = 4,
  DataCategory_MIN = DataCategory_IMAGE,
  DataCategory_MAX = DataCategory_BIAS
};

inline const char **EnumNamesDataCategory() {
  static const char *names[] = {
    "IMAGE",
    "WEIGHT",
    "FEATURE",
    "PLANAR",
    "BIAS",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataCategory(DataCategory e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDataCategory()[index];
}

enum PixelMapping {
  PixelMapping_PITCH_LINEAR = 0,
  PixelMapping_INVALID_PIXEL_MAP = 1,
  PixelMapping_MIN = PixelMapping_PITCH_LINEAR,
  PixelMapping_MAX = PixelMapping_INVALID_PIXEL_MAP
};

inline const char **EnumNamesPixelMapping() {
  static const char *names[] = {
    "PITCH_LINEAR",
    "INVALID_PIXEL_MAP",
    nullptr
  };
  return names;
}

inline const char *EnumNamePixelMapping(PixelMapping e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPixelMapping()[index];
}

enum PixelFormat {
  PixelFormat_R8 = 0,
  PixelFormat_R10 = 1,
  PixelFormat_R12 = 2,
  PixelFormat_R16 = 3,
  PixelFormat_R16_I = 4,
  PixelFormat_R16_F = 5,
  PixelFormat_A16B16G16R16 = 6,
  PixelFormat_X16B16G16R16 = 7,
  PixelFormat_A16B16G16R16_F = 8,
  PixelFormat_A16Y16U16V16 = 9,
  PixelFormat_V16U16Y16A16 = 10,
  PixelFormat_A16Y16U16V16_F = 11,
  PixelFormat_A8B8G8R8 = 12,
  PixelFormat_A8R8G8B8 = 13,
  PixelFormat_B8G8R8A8 = 14,
  PixelFormat_R8G8B8A8 = 15,
  PixelFormat_X8B8G8R8 = 16,
  PixelFormat_X8R8G8B8 = 17,
  PixelFormat_B8G8R8X8 = 18,
  PixelFormat_R8G8B8X8 = 19,
  PixelFormat_A2B10G10R10 = 20,
  PixelFormat_A2R10G10B10 = 21,
  PixelFormat_B10G10R10A2 = 22,
  PixelFormat_R10G10B10A2 = 23,
  PixelFormat_A2Y10U10V10 = 24,
  PixelFormat_V10U10Y10A2 = 25,
  PixelFormat_A8Y8U8V8 = 26,
  PixelFormat_V8U8Y8A8 = 27,
  PixelFormat_Y8_U8V8_N444 = 28,
  PixelFormat_Y8_V8U8_N444 = 29,
  PixelFormat_Y10_U10V10_N444 = 30,
  PixelFormat_Y10_V10U10_N444 = 31,
  PixelFormat_Y12_U12V12_N444 = 32,
  PixelFormat_Y12_V12U12_N444 = 33,
  PixelFormat_Y16_U16V16_N444 = 34,
  PixelFormat_Y16_V16U16_N444 = 35,
  PixelFormat_FEATURE = 36,
  PixelFormat_FEATURE_X8 = 37,
  PixelFormat_MIN = PixelFormat_R8,
  PixelFormat_MAX = PixelFormat_FEATURE_X8
};

inline const char **EnumNamesPixelFormat() {
  static const char *names[] = {
    "R8",
    "R10",
    "R12",
    "R16",
    "R16_I",
    "R16_F",
    "A16B16G16R16",
    "X16B16G16R16",
    "A16B16G16R16_F",
    "A16Y16U16V16",
    "V16U16Y16A16",
    "A16Y16U16V16_F",
    "A8B8G8R8",
    "A8R8G8B8",
    "B8G8R8A8",
    "R8G8B8A8",
    "X8B8G8R8",
    "X8R8G8B8",
    "B8G8R8X8",
    "R8G8B8X8",
    "A2B10G10R10",
    "A2R10G10B10",
    "B10G10R10A2",
    "R10G10B10A2",
    "A2Y10U10V10",
    "V10U10Y10A2",
    "A8Y8U8V8",
    "V8U8Y8A8",
    "Y8_U8V8_N444",
    "Y8_V8U8_N444",
    "Y10_U10V10_N444",
    "Y10_V10U10_N444",
    "Y12_U12V12_N444",
    "Y12_V12U12_N444",
    "Y16_U16V16_N444",
    "Y16_V16U16_N444",
    "FEATURE",
    "FEATURE_X8",
    nullptr
  };
  return names;
}

inline const char *EnumNamePixelFormat(PixelFormat e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPixelFormat()[index];
}

MANUALLY_ALIGNED_STRUCT(1) Version FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t major_;
  uint8_t minor_;
  uint8_t sub_minor_;

 public:
  Version() {
    memset(this, 0, sizeof(Version));
  }
  Version(const Version &_o) {
    memcpy(this, &_o, sizeof(Version));
  }
  Version(uint8_t _major, uint8_t _minor, uint8_t _sub_minor)
      : major_(flatbuffers::EndianScalar(_major)),
        minor_(flatbuffers::EndianScalar(_minor)),
        sub_minor_(flatbuffers::EndianScalar(_sub_minor)) {
  }
  uint8_t major() const {
    return flatbuffers::EndianScalar(major_);
  }
  uint8_t minor() const {
    return flatbuffers::EndianScalar(minor_);
  }
  uint8_t sub_minor() const {
    return flatbuffers::EndianScalar(sub_minor_);
  }
};
STRUCT_END(Version, 3);

struct Blob FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_SIZE = 6,
    VT_INTERFACE = 8,
    VT_SUB_INTERFACE = 10,
    VT_VERSION = 12,
    VT_DATA = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  Interface interface() const {
    return static_cast<Interface>(GetField<uint32_t>(VT_INTERFACE, 0));
  }
  uint32_t sub_interface() const {
    return GetField<uint32_t>(VT_SUB_INTERFACE, 0);
  }
  const Version *version() const {
    return GetStruct<const Version *>(VT_VERSION);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           VerifyField<uint32_t>(verifier, VT_INTERFACE) &&
           VerifyField<uint32_t>(verifier, VT_SUB_INTERFACE) &&
           VerifyField<Version>(verifier, VT_VERSION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct BlobBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Blob::VT_NAME, name);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(Blob::VT_SIZE, size, 0);
  }
  void add_interface(Interface interface) {
    fbb_.AddElement<uint32_t>(Blob::VT_INTERFACE, static_cast<uint32_t>(interface), 0);
  }
  void add_sub_interface(uint32_t sub_interface) {
    fbb_.AddElement<uint32_t>(Blob::VT_SUB_INTERFACE, sub_interface, 0);
  }
  void add_version(const Version *version) {
    fbb_.AddStruct(Blob::VT_VERSION, version);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Blob::VT_DATA, data);
  }
  BlobBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlobBuilder &operator=(const BlobBuilder &);
  flatbuffers::Offset<Blob> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Blob>(end);
    return o;
  }
};

inline flatbuffers::Offset<Blob> CreateBlob(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint64_t size = 0,
    Interface interface = Interface_NONE,
    uint32_t sub_interface = 0,
    const Version *version = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  BlobBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_data(data);
  builder_.add_version(version);
  builder_.add_sub_interface(sub_interface);
  builder_.add_interface(interface);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Blob> CreateBlobDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t size = 0,
    Interface interface = Interface_NONE,
    uint32_t sub_interface = 0,
    const Version *version = 0,
    const std::vector<uint8_t> *data = nullptr) {
  return nvdla::loadable::CreateBlob(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      size,
      interface,
      sub_interface,
      version,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

struct MemoryListEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_DOMAIN = 6,
    VT_FLAGS = 8,
    VT_SIZE = 10,
    VT_ALIGNMENT = 12,
    VT_CONTENTS = 14,
    VT_OFFSETS = 16,
    VT_BIND_ID = 18,
    VT_TENSOR_DESC_ID = 20
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  MemoryDomain domain() const {
    return static_cast<MemoryDomain>(GetField<uint8_t>(VT_DOMAIN, 0));
  }
  MemoryFlags flags() const {
    return static_cast<MemoryFlags>(GetField<uint16_t>(VT_FLAGS, 0));
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  uint32_t alignment() const {
    return GetField<uint32_t>(VT_ALIGNMENT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *contents() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CONTENTS);
  }
  const flatbuffers::Vector<uint64_t> *offsets() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_OFFSETS);
  }
  uint16_t bind_id() const {
    return GetField<uint16_t>(VT_BIND_ID, 0);
  }
  uint16_t tensor_desc_id() const {
    return GetField<uint16_t>(VT_TENSOR_DESC_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_DOMAIN) &&
           VerifyField<uint16_t>(verifier, VT_FLAGS) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           VerifyField<uint32_t>(verifier, VT_ALIGNMENT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CONTENTS) &&
           verifier.Verify(contents()) &&
           verifier.VerifyVectorOfStrings(contents()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OFFSETS) &&
           verifier.Verify(offsets()) &&
           VerifyField<uint16_t>(verifier, VT_BIND_ID) &&
           VerifyField<uint16_t>(verifier, VT_TENSOR_DESC_ID) &&
           verifier.EndTable();
  }
};

struct MemoryListEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(MemoryListEntry::VT_ID, id, 0);
  }
  void add_domain(MemoryDomain domain) {
    fbb_.AddElement<uint8_t>(MemoryListEntry::VT_DOMAIN, static_cast<uint8_t>(domain), 0);
  }
  void add_flags(MemoryFlags flags) {
    fbb_.AddElement<uint16_t>(MemoryListEntry::VT_FLAGS, static_cast<uint16_t>(flags), 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(MemoryListEntry::VT_SIZE, size, 0);
  }
  void add_alignment(uint32_t alignment) {
    fbb_.AddElement<uint32_t>(MemoryListEntry::VT_ALIGNMENT, alignment, 0);
  }
  void add_contents(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> contents) {
    fbb_.AddOffset(MemoryListEntry::VT_CONTENTS, contents);
  }
  void add_offsets(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> offsets) {
    fbb_.AddOffset(MemoryListEntry::VT_OFFSETS, offsets);
  }
  void add_bind_id(uint16_t bind_id) {
    fbb_.AddElement<uint16_t>(MemoryListEntry::VT_BIND_ID, bind_id, 0);
  }
  void add_tensor_desc_id(uint16_t tensor_desc_id) {
    fbb_.AddElement<uint16_t>(MemoryListEntry::VT_TENSOR_DESC_ID, tensor_desc_id, 0);
  }
  MemoryListEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MemoryListEntryBuilder &operator=(const MemoryListEntryBuilder &);
  flatbuffers::Offset<MemoryListEntry> Finish() {
    const auto end = fbb_.EndTable(start_, 9);
    auto o = flatbuffers::Offset<MemoryListEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<MemoryListEntry> CreateMemoryListEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    MemoryDomain domain = MemoryDomain_SYSTEM,
    MemoryFlags flags = MemoryFlags_NONE,
    uint64_t size = 0,
    uint32_t alignment = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> contents = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> offsets = 0,
    uint16_t bind_id = 0,
    uint16_t tensor_desc_id = 0) {
  MemoryListEntryBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_offsets(offsets);
  builder_.add_contents(contents);
  builder_.add_alignment(alignment);
  builder_.add_tensor_desc_id(tensor_desc_id);
  builder_.add_bind_id(bind_id);
  builder_.add_flags(flags);
  builder_.add_id(id);
  builder_.add_domain(domain);
  return builder_.Finish();
}

inline flatbuffers::Offset<MemoryListEntry> CreateMemoryListEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    MemoryDomain domain = MemoryDomain_SYSTEM,
    MemoryFlags flags = MemoryFlags_NONE,
    uint64_t size = 0,
    uint32_t alignment = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *contents = nullptr,
    const std::vector<uint64_t> *offsets = nullptr,
    uint16_t bind_id = 0,
    uint16_t tensor_desc_id = 0) {
  return nvdla::loadable::CreateMemoryListEntry(
      _fbb,
      id,
      domain,
      flags,
      size,
      alignment,
      contents ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*contents) : 0,
      offsets ? _fbb.CreateVector<uint64_t>(*offsets) : 0,
      bind_id,
      tensor_desc_id);
}

struct EventListEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_TARGET = 8,
    VT_VAL = 10,
    VT_OP = 12
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  EventType type() const {
    return static_cast<EventType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  uint16_t target() const {
    return GetField<uint16_t>(VT_TARGET, 0);
  }
  uint32_t val() const {
    return GetField<uint32_t>(VT_VAL, 0);
  }
  EventOp op() const {
    return static_cast<EventOp>(GetField<uint8_t>(VT_OP, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_TARGET) &&
           VerifyField<uint32_t>(verifier, VT_VAL) &&
           VerifyField<uint8_t>(verifier, VT_OP) &&
           verifier.EndTable();
  }
};

struct EventListEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(EventListEntry::VT_ID, id, 0);
  }
  void add_type(EventType type) {
    fbb_.AddElement<uint8_t>(EventListEntry::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_target(uint16_t target) {
    fbb_.AddElement<uint16_t>(EventListEntry::VT_TARGET, target, 0);
  }
  void add_val(uint32_t val) {
    fbb_.AddElement<uint32_t>(EventListEntry::VT_VAL, val, 0);
  }
  void add_op(EventOp op) {
    fbb_.AddElement<uint8_t>(EventListEntry::VT_OP, static_cast<uint8_t>(op), 0);
  }
  EventListEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventListEntryBuilder &operator=(const EventListEntryBuilder &);
  flatbuffers::Offset<EventListEntry> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<EventListEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventListEntry> CreateEventListEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    EventType type = EventType_EVENTTYPE0,
    uint16_t target = 0,
    uint32_t val = 0,
    EventOp op = EventOp_WAIT) {
  EventListEntryBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_target(target);
  builder_.add_id(id);
  builder_.add_op(op);
  builder_.add_type(type);
  return builder_.Finish();
}

struct TaskListEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_INTERFACE = 6,
    VT_INSTANCE = 8,
    VT_ADDRESS_LIST = 10,
    VT_PRE_ACTIONS = 12,
    VT_POST_ACTIONS = 14
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  Interface interface() const {
    return static_cast<Interface>(GetField<uint32_t>(VT_INTERFACE, 0));
  }
  int16_t instance() const {
    return GetField<int16_t>(VT_INSTANCE, 0);
  }
  const flatbuffers::Vector<uint16_t> *address_list() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_ADDRESS_LIST);
  }
  const flatbuffers::Vector<uint16_t> *pre_actions() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_PRE_ACTIONS);
  }
  const flatbuffers::Vector<uint16_t> *post_actions() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_POST_ACTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_INTERFACE) &&
           VerifyField<int16_t>(verifier, VT_INSTANCE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADDRESS_LIST) &&
           verifier.Verify(address_list()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PRE_ACTIONS) &&
           verifier.Verify(pre_actions()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_POST_ACTIONS) &&
           verifier.Verify(post_actions()) &&
           verifier.EndTable();
  }
};

struct TaskListEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(TaskListEntry::VT_ID, id, 0);
  }
  void add_interface(Interface interface) {
    fbb_.AddElement<uint32_t>(TaskListEntry::VT_INTERFACE, static_cast<uint32_t>(interface), 0);
  }
  void add_instance(int16_t instance) {
    fbb_.AddElement<int16_t>(TaskListEntry::VT_INSTANCE, instance, 0);
  }
  void add_address_list(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> address_list) {
    fbb_.AddOffset(TaskListEntry::VT_ADDRESS_LIST, address_list);
  }
  void add_pre_actions(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> pre_actions) {
    fbb_.AddOffset(TaskListEntry::VT_PRE_ACTIONS, pre_actions);
  }
  void add_post_actions(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> post_actions) {
    fbb_.AddOffset(TaskListEntry::VT_POST_ACTIONS, post_actions);
  }
  TaskListEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TaskListEntryBuilder &operator=(const TaskListEntryBuilder &);
  flatbuffers::Offset<TaskListEntry> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<TaskListEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<TaskListEntry> CreateTaskListEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    Interface interface = Interface_NONE,
    int16_t instance = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> address_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> pre_actions = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> post_actions = 0) {
  TaskListEntryBuilder builder_(_fbb);
  builder_.add_post_actions(post_actions);
  builder_.add_pre_actions(pre_actions);
  builder_.add_address_list(address_list);
  builder_.add_interface(interface);
  builder_.add_instance(instance);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<TaskListEntry> CreateTaskListEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    Interface interface = Interface_NONE,
    int16_t instance = 0,
    const std::vector<uint16_t> *address_list = nullptr,
    const std::vector<uint16_t> *pre_actions = nullptr,
    const std::vector<uint16_t> *post_actions = nullptr) {
  return nvdla::loadable::CreateTaskListEntry(
      _fbb,
      id,
      interface,
      instance,
      address_list ? _fbb.CreateVector<uint16_t>(*address_list) : 0,
      pre_actions ? _fbb.CreateVector<uint16_t>(*pre_actions) : 0,
      post_actions ? _fbb.CreateVector<uint16_t>(*post_actions) : 0);
}

struct AddressListEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_MEM_ID = 6,
    VT_OFFSET = 8,
    VT_SIZE = 10
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  uint16_t mem_id() const {
    return GetField<uint16_t>(VT_MEM_ID, 0);
  }
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint16_t>(verifier, VT_MEM_ID) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct AddressListEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(AddressListEntry::VT_ID, id, 0);
  }
  void add_mem_id(uint16_t mem_id) {
    fbb_.AddElement<uint16_t>(AddressListEntry::VT_MEM_ID, mem_id, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(AddressListEntry::VT_OFFSET, offset, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(AddressListEntry::VT_SIZE, size, 0);
  }
  AddressListEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddressListEntryBuilder &operator=(const AddressListEntryBuilder &);
  flatbuffers::Offset<AddressListEntry> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<AddressListEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddressListEntry> CreateAddressListEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    uint16_t mem_id = 0,
    uint64_t offset = 0,
    uint64_t size = 0) {
  AddressListEntryBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_offset(offset);
  builder_.add_mem_id(mem_id);
  builder_.add_id(id);
  return builder_.Finish();
}

struct SubmitListEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_TASK_ID = 6
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<uint16_t> *task_id() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TASK_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TASK_ID) &&
           verifier.Verify(task_id()) &&
           verifier.EndTable();
  }
};

struct SubmitListEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(SubmitListEntry::VT_ID, id, 0);
  }
  void add_task_id(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> task_id) {
    fbb_.AddOffset(SubmitListEntry::VT_TASK_ID, task_id);
  }
  SubmitListEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubmitListEntryBuilder &operator=(const SubmitListEntryBuilder &);
  flatbuffers::Offset<SubmitListEntry> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SubmitListEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubmitListEntry> CreateSubmitListEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> task_id = 0) {
  SubmitListEntryBuilder builder_(_fbb);
  builder_.add_task_id(task_id);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubmitListEntry> CreateSubmitListEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    const std::vector<uint16_t> *task_id = nullptr) {
  return nvdla::loadable::CreateSubmitListEntry(
      _fbb,
      id,
      task_id ? _fbb.CreateVector<uint16_t>(*task_id) : 0);
}

struct TensorDescListEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_ID = 6,
    VT_MEM_ID = 8,
    VT_SIZE = 10,
    VT_OFFSET = 12,
    VT_DATA_FORMAT = 14,
    VT_DATA_TYPE = 16,
    VT_DATA_CATEGORY = 18,
    VT_PIXEL_FORMAT = 20,
    VT_PIXEL_MAPPING = 22,
    VT_N = 24,
    VT_C = 26,
    VT_H = 28,
    VT_W = 30,
    VT_STRIDE_0 = 32,
    VT_STRIDE_1 = 34,
    VT_STRIDE_2 = 36,
    VT_STRIDE_3 = 38,
    VT_STRIDE_4 = 40,
    VT_STRIDE_5 = 42,
    VT_STRIDE_6 = 44,
    VT_STRIDE_7 = 46
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  uint16_t mem_id() const {
    return GetField<uint16_t>(VT_MEM_ID, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  DataFormat data_format() const {
    return static_cast<DataFormat>(GetField<uint8_t>(VT_DATA_FORMAT, 0));
  }
  DataType data_type() const {
    return static_cast<DataType>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  DataCategory data_category() const {
    return static_cast<DataCategory>(GetField<uint8_t>(VT_DATA_CATEGORY, 0));
  }
  PixelFormat pixel_format() const {
    return static_cast<PixelFormat>(GetField<uint8_t>(VT_PIXEL_FORMAT, 0));
  }
  PixelMapping pixel_mapping() const {
    return static_cast<PixelMapping>(GetField<uint8_t>(VT_PIXEL_MAPPING, 0));
  }
  int32_t n() const {
    return GetField<int32_t>(VT_N, 0);
  }
  int32_t c() const {
    return GetField<int32_t>(VT_C, 0);
  }
  int32_t h() const {
    return GetField<int32_t>(VT_H, 0);
  }
  int32_t w() const {
    return GetField<int32_t>(VT_W, 0);
  }
  uint32_t stride_0() const {
    return GetField<uint32_t>(VT_STRIDE_0, 0);
  }
  uint32_t stride_1() const {
    return GetField<uint32_t>(VT_STRIDE_1, 0);
  }
  uint32_t stride_2() const {
    return GetField<uint32_t>(VT_STRIDE_2, 0);
  }
  uint32_t stride_3() const {
    return GetField<uint32_t>(VT_STRIDE_3, 0);
  }
  uint32_t stride_4() const {
    return GetField<uint32_t>(VT_STRIDE_4, 0);
  }
  uint32_t stride_5() const {
    return GetField<uint32_t>(VT_STRIDE_5, 0);
  }
  uint32_t stride_6() const {
    return GetField<uint32_t>(VT_STRIDE_6, 0);
  }
  uint32_t stride_7() const {
    return GetField<uint32_t>(VT_STRIDE_7, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint16_t>(verifier, VT_MEM_ID) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET) &&
           VerifyField<uint8_t>(verifier, VT_DATA_FORMAT) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DATA_CATEGORY) &&
           VerifyField<uint8_t>(verifier, VT_PIXEL_FORMAT) &&
           VerifyField<uint8_t>(verifier, VT_PIXEL_MAPPING) &&
           VerifyField<int32_t>(verifier, VT_N) &&
           VerifyField<int32_t>(verifier, VT_C) &&
           VerifyField<int32_t>(verifier, VT_H) &&
           VerifyField<int32_t>(verifier, VT_W) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE_0) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE_1) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE_2) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE_3) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE_4) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE_5) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE_6) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE_7) &&
           verifier.EndTable();
  }
};

struct TensorDescListEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TensorDescListEntry::VT_NAME, name);
  }
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(TensorDescListEntry::VT_ID, id, 0);
  }
  void add_mem_id(uint16_t mem_id) {
    fbb_.AddElement<uint16_t>(TensorDescListEntry::VT_MEM_ID, mem_id, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(TensorDescListEntry::VT_SIZE, size, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(TensorDescListEntry::VT_OFFSET, offset, 0);
  }
  void add_data_format(DataFormat data_format) {
    fbb_.AddElement<uint8_t>(TensorDescListEntry::VT_DATA_FORMAT, static_cast<uint8_t>(data_format), 0);
  }
  void add_data_type(DataType data_type) {
    fbb_.AddElement<uint8_t>(TensorDescListEntry::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data_category(DataCategory data_category) {
    fbb_.AddElement<uint8_t>(TensorDescListEntry::VT_DATA_CATEGORY, static_cast<uint8_t>(data_category), 0);
  }
  void add_pixel_format(PixelFormat pixel_format) {
    fbb_.AddElement<uint8_t>(TensorDescListEntry::VT_PIXEL_FORMAT, static_cast<uint8_t>(pixel_format), 0);
  }
  void add_pixel_mapping(PixelMapping pixel_mapping) {
    fbb_.AddElement<uint8_t>(TensorDescListEntry::VT_PIXEL_MAPPING, static_cast<uint8_t>(pixel_mapping), 0);
  }
  void add_n(int32_t n) {
    fbb_.AddElement<int32_t>(TensorDescListEntry::VT_N, n, 0);
  }
  void add_c(int32_t c) {
    fbb_.AddElement<int32_t>(TensorDescListEntry::VT_C, c, 0);
  }
  void add_h(int32_t h) {
    fbb_.AddElement<int32_t>(TensorDescListEntry::VT_H, h, 0);
  }
  void add_w(int32_t w) {
    fbb_.AddElement<int32_t>(TensorDescListEntry::VT_W, w, 0);
  }
  void add_stride_0(uint32_t stride_0) {
    fbb_.AddElement<uint32_t>(TensorDescListEntry::VT_STRIDE_0, stride_0, 0);
  }
  void add_stride_1(uint32_t stride_1) {
    fbb_.AddElement<uint32_t>(TensorDescListEntry::VT_STRIDE_1, stride_1, 0);
  }
  void add_stride_2(uint32_t stride_2) {
    fbb_.AddElement<uint32_t>(TensorDescListEntry::VT_STRIDE_2, stride_2, 0);
  }
  void add_stride_3(uint32_t stride_3) {
    fbb_.AddElement<uint32_t>(TensorDescListEntry::VT_STRIDE_3, stride_3, 0);
  }
  void add_stride_4(uint32_t stride_4) {
    fbb_.AddElement<uint32_t>(TensorDescListEntry::VT_STRIDE_4, stride_4, 0);
  }
  void add_stride_5(uint32_t stride_5) {
    fbb_.AddElement<uint32_t>(TensorDescListEntry::VT_STRIDE_5, stride_5, 0);
  }
  void add_stride_6(uint32_t stride_6) {
    fbb_.AddElement<uint32_t>(TensorDescListEntry::VT_STRIDE_6, stride_6, 0);
  }
  void add_stride_7(uint32_t stride_7) {
    fbb_.AddElement<uint32_t>(TensorDescListEntry::VT_STRIDE_7, stride_7, 0);
  }
  TensorDescListEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorDescListEntryBuilder &operator=(const TensorDescListEntryBuilder &);
  flatbuffers::Offset<TensorDescListEntry> Finish() {
    const auto end = fbb_.EndTable(start_, 22);
    auto o = flatbuffers::Offset<TensorDescListEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorDescListEntry> CreateTensorDescListEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint16_t id = 0,
    uint16_t mem_id = 0,
    uint64_t size = 0,
    uint64_t offset = 0,
    DataFormat data_format = DataFormat_UNKNOWN,
    DataType data_type = DataType_UNKNOWN,
    DataCategory data_category = DataCategory_IMAGE,
    PixelFormat pixel_format = PixelFormat_R8,
    PixelMapping pixel_mapping = PixelMapping_PITCH_LINEAR,
    int32_t n = 0,
    int32_t c = 0,
    int32_t h = 0,
    int32_t w = 0,
    uint32_t stride_0 = 0,
    uint32_t stride_1 = 0,
    uint32_t stride_2 = 0,
    uint32_t stride_3 = 0,
    uint32_t stride_4 = 0,
    uint32_t stride_5 = 0,
    uint32_t stride_6 = 0,
    uint32_t stride_7 = 0) {
  TensorDescListEntryBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_size(size);
  builder_.add_stride_7(stride_7);
  builder_.add_stride_6(stride_6);
  builder_.add_stride_5(stride_5);
  builder_.add_stride_4(stride_4);
  builder_.add_stride_3(stride_3);
  builder_.add_stride_2(stride_2);
  builder_.add_stride_1(stride_1);
  builder_.add_stride_0(stride_0);
  builder_.add_w(w);
  builder_.add_h(h);
  builder_.add_c(c);
  builder_.add_n(n);
  builder_.add_name(name);
  builder_.add_mem_id(mem_id);
  builder_.add_id(id);
  builder_.add_pixel_mapping(pixel_mapping);
  builder_.add_pixel_format(pixel_format);
  builder_.add_data_category(data_category);
  builder_.add_data_type(data_type);
  builder_.add_data_format(data_format);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorDescListEntry> CreateTensorDescListEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint16_t id = 0,
    uint16_t mem_id = 0,
    uint64_t size = 0,
    uint64_t offset = 0,
    DataFormat data_format = DataFormat_UNKNOWN,
    DataType data_type = DataType_UNKNOWN,
    DataCategory data_category = DataCategory_IMAGE,
    PixelFormat pixel_format = PixelFormat_R8,
    PixelMapping pixel_mapping = PixelMapping_PITCH_LINEAR,
    int32_t n = 0,
    int32_t c = 0,
    int32_t h = 0,
    int32_t w = 0,
    uint32_t stride_0 = 0,
    uint32_t stride_1 = 0,
    uint32_t stride_2 = 0,
    uint32_t stride_3 = 0,
    uint32_t stride_4 = 0,
    uint32_t stride_5 = 0,
    uint32_t stride_6 = 0,
    uint32_t stride_7 = 0) {
  return nvdla::loadable::CreateTensorDescListEntry(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      id,
      mem_id,
      size,
      offset,
      data_format,
      data_type,
      data_category,
      pixel_format,
      pixel_mapping,
      n,
      c,
      h,
      w,
      stride_0,
      stride_1,
      stride_2,
      stride_3,
      stride_4,
      stride_5,
      stride_6,
      stride_7);
}

struct RelocListEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS_ID = 4,
    VT_WRITE_ID = 6,
    VT_OFFSET = 8,
    VT_INTERFACE = 10,
    VT_SUB_INTERFACE = 12,
    VT_RELOC_TYPE = 14
  };
  uint16_t address_id() const {
    return GetField<uint16_t>(VT_ADDRESS_ID, 0);
  }
  uint16_t write_id() const {
    return GetField<uint16_t>(VT_WRITE_ID, 0);
  }
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  uint32_t interface() const {
    return GetField<uint32_t>(VT_INTERFACE, 0);
  }
  uint32_t sub_interface() const {
    return GetField<uint32_t>(VT_SUB_INTERFACE, 0);
  }
  uint8_t reloc_type() const {
    return GetField<uint8_t>(VT_RELOC_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ADDRESS_ID) &&
           VerifyField<uint16_t>(verifier, VT_WRITE_ID) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET) &&
           VerifyField<uint32_t>(verifier, VT_INTERFACE) &&
           VerifyField<uint32_t>(verifier, VT_SUB_INTERFACE) &&
           VerifyField<uint8_t>(verifier, VT_RELOC_TYPE) &&
           verifier.EndTable();
  }
};

struct RelocListEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address_id(uint16_t address_id) {
    fbb_.AddElement<uint16_t>(RelocListEntry::VT_ADDRESS_ID, address_id, 0);
  }
  void add_write_id(uint16_t write_id) {
    fbb_.AddElement<uint16_t>(RelocListEntry::VT_WRITE_ID, write_id, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(RelocListEntry::VT_OFFSET, offset, 0);
  }
  void add_interface(uint32_t interface) {
    fbb_.AddElement<uint32_t>(RelocListEntry::VT_INTERFACE, interface, 0);
  }
  void add_sub_interface(uint32_t sub_interface) {
    fbb_.AddElement<uint32_t>(RelocListEntry::VT_SUB_INTERFACE, sub_interface, 0);
  }
  void add_reloc_type(uint8_t reloc_type) {
    fbb_.AddElement<uint8_t>(RelocListEntry::VT_RELOC_TYPE, reloc_type, 0);
  }
  RelocListEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelocListEntryBuilder &operator=(const RelocListEntryBuilder &);
  flatbuffers::Offset<RelocListEntry> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<RelocListEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<RelocListEntry> CreateRelocListEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t address_id = 0,
    uint16_t write_id = 0,
    uint64_t offset = 0,
    uint32_t interface = 0,
    uint32_t sub_interface = 0,
    uint8_t reloc_type = 0) {
  RelocListEntryBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_sub_interface(sub_interface);
  builder_.add_interface(interface);
  builder_.add_write_id(write_id);
  builder_.add_address_id(address_id);
  builder_.add_reloc_type(reloc_type);
  return builder_.Finish();
}

struct Loadable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_TASK_LIST = 6,
    VT_MEMORY_LIST = 8,
    VT_ADDRESS_LIST = 10,
    VT_EVENT_LIST = 12,
    VT_BLOBS = 14,
    VT_TENSOR_DESC_LIST = 16,
    VT_RELOC_LIST = 18,
    VT_SUBMIT_LIST = 20
  };
  const Version *version() const {
    return GetStruct<const Version *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TaskListEntry>> *task_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TaskListEntry>> *>(VT_TASK_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MemoryListEntry>> *memory_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MemoryListEntry>> *>(VT_MEMORY_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AddressListEntry>> *address_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AddressListEntry>> *>(VT_ADDRESS_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EventListEntry>> *event_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EventListEntry>> *>(VT_EVENT_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Blob>> *blobs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Blob>> *>(VT_BLOBS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TensorDescListEntry>> *tensor_desc_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorDescListEntry>> *>(VT_TENSOR_DESC_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RelocListEntry>> *reloc_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RelocListEntry>> *>(VT_RELOC_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SubmitListEntry>> *submit_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SubmitListEntry>> *>(VT_SUBMIT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Version>(verifier, VT_VERSION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TASK_LIST) &&
           verifier.Verify(task_list()) &&
           verifier.VerifyVectorOfTables(task_list()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MEMORY_LIST) &&
           verifier.Verify(memory_list()) &&
           verifier.VerifyVectorOfTables(memory_list()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADDRESS_LIST) &&
           verifier.Verify(address_list()) &&
           verifier.VerifyVectorOfTables(address_list()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENT_LIST) &&
           verifier.Verify(event_list()) &&
           verifier.VerifyVectorOfTables(event_list()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BLOBS) &&
           verifier.Verify(blobs()) &&
           verifier.VerifyVectorOfTables(blobs()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TENSOR_DESC_LIST) &&
           verifier.Verify(tensor_desc_list()) &&
           verifier.VerifyVectorOfTables(tensor_desc_list()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RELOC_LIST) &&
           verifier.Verify(reloc_list()) &&
           verifier.VerifyVectorOfTables(reloc_list()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SUBMIT_LIST) &&
           verifier.Verify(submit_list()) &&
           verifier.VerifyVectorOfTables(submit_list()) &&
           verifier.EndTable();
  }
};

struct LoadableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(const Version *version) {
    fbb_.AddStruct(Loadable::VT_VERSION, version);
  }
  void add_task_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TaskListEntry>>> task_list) {
    fbb_.AddOffset(Loadable::VT_TASK_LIST, task_list);
  }
  void add_memory_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MemoryListEntry>>> memory_list) {
    fbb_.AddOffset(Loadable::VT_MEMORY_LIST, memory_list);
  }
  void add_address_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AddressListEntry>>> address_list) {
    fbb_.AddOffset(Loadable::VT_ADDRESS_LIST, address_list);
  }
  void add_event_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventListEntry>>> event_list) {
    fbb_.AddOffset(Loadable::VT_EVENT_LIST, event_list);
  }
  void add_blobs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Blob>>> blobs) {
    fbb_.AddOffset(Loadable::VT_BLOBS, blobs);
  }
  void add_tensor_desc_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorDescListEntry>>> tensor_desc_list) {
    fbb_.AddOffset(Loadable::VT_TENSOR_DESC_LIST, tensor_desc_list);
  }
  void add_reloc_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RelocListEntry>>> reloc_list) {
    fbb_.AddOffset(Loadable::VT_RELOC_LIST, reloc_list);
  }
  void add_submit_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubmitListEntry>>> submit_list) {
    fbb_.AddOffset(Loadable::VT_SUBMIT_LIST, submit_list);
  }
  LoadableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoadableBuilder &operator=(const LoadableBuilder &);
  flatbuffers::Offset<Loadable> Finish() {
    const auto end = fbb_.EndTable(start_, 9);
    auto o = flatbuffers::Offset<Loadable>(end);
    fbb_.Required(o, Loadable::VT_VERSION);
    return o;
  }
};

inline flatbuffers::Offset<Loadable> CreateLoadable(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Version *version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TaskListEntry>>> task_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MemoryListEntry>>> memory_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AddressListEntry>>> address_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventListEntry>>> event_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Blob>>> blobs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorDescListEntry>>> tensor_desc_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RelocListEntry>>> reloc_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubmitListEntry>>> submit_list = 0) {
  LoadableBuilder builder_(_fbb);
  builder_.add_submit_list(submit_list);
  builder_.add_reloc_list(reloc_list);
  builder_.add_tensor_desc_list(tensor_desc_list);
  builder_.add_blobs(blobs);
  builder_.add_event_list(event_list);
  builder_.add_address_list(address_list);
  builder_.add_memory_list(memory_list);
  builder_.add_task_list(task_list);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Loadable> CreateLoadableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Version *version = 0,
    const std::vector<flatbuffers::Offset<TaskListEntry>> *task_list = nullptr,
    const std::vector<flatbuffers::Offset<MemoryListEntry>> *memory_list = nullptr,
    const std::vector<flatbuffers::Offset<AddressListEntry>> *address_list = nullptr,
    const std::vector<flatbuffers::Offset<EventListEntry>> *event_list = nullptr,
    const std::vector<flatbuffers::Offset<Blob>> *blobs = nullptr,
    const std::vector<flatbuffers::Offset<TensorDescListEntry>> *tensor_desc_list = nullptr,
    const std::vector<flatbuffers::Offset<RelocListEntry>> *reloc_list = nullptr,
    const std::vector<flatbuffers::Offset<SubmitListEntry>> *submit_list = nullptr) {
  return nvdla::loadable::CreateLoadable(
      _fbb,
      version,
      task_list ? _fbb.CreateVector<flatbuffers::Offset<TaskListEntry>>(*task_list) : 0,
      memory_list ? _fbb.CreateVector<flatbuffers::Offset<MemoryListEntry>>(*memory_list) : 0,
      address_list ? _fbb.CreateVector<flatbuffers::Offset<AddressListEntry>>(*address_list) : 0,
      event_list ? _fbb.CreateVector<flatbuffers::Offset<EventListEntry>>(*event_list) : 0,
      blobs ? _fbb.CreateVector<flatbuffers::Offset<Blob>>(*blobs) : 0,
      tensor_desc_list ? _fbb.CreateVector<flatbuffers::Offset<TensorDescListEntry>>(*tensor_desc_list) : 0,
      reloc_list ? _fbb.CreateVector<flatbuffers::Offset<RelocListEntry>>(*reloc_list) : 0,
      submit_list ? _fbb.CreateVector<flatbuffers::Offset<SubmitListEntry>>(*submit_list) : 0);
}

inline const nvdla::loadable::Loadable *GetLoadable(const void *buf) {
  return flatbuffers::GetRoot<nvdla::loadable::Loadable>(buf);
}

inline bool VerifyLoadableBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<nvdla::loadable::Loadable>(nullptr);
}

inline void FinishLoadableBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<nvdla::loadable::Loadable> root) {
  fbb.Finish(root);
}

}  // namespace loadable
}  // namespace nvdla

#endif  // FLATBUFFERS_GENERATED_LOADABLE_NVDLA_LOADABLE_H_
