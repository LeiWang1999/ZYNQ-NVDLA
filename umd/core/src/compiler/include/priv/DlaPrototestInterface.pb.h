// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DlaPrototestInterface.proto

#ifndef PROTOBUF_DlaPrototestInterface_2eproto__INCLUDED
#define PROTOBUF_DlaPrototestInterface_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace nvdla_prototest_interface {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

class LUTOffset;
class FloatData;
class DLASlope;
class DataFile;
class Constant;
class DataFiller;
class LUTParam;
class BDMATransferDesc;
class BDMASurfaceDesc;
class BDMAOpDesc;
class CVTParam;
class MemInfo;
class DataCube;
class CONVSurfaceDesc;
class CONVOpDesc;
class SDPCvt;
class SDPOp;
class SDPSurfaceDesc;
class SDPOpDesc;
class PDPSurfaceDesc;
class PDPOpDesc;
class CDPSurfaceDesc;
class CDPOpDesc;
class RUBIKSurfaceDesc;
class RUBIKOpDesc;
class SurfaceContainer;
class OperationContainer;
class Consumer;
class Layer;
class NetworkLayer;
class NetworkDesc;
class LUTParamList;
class ROIArrayDesc;
class ROIDesc;
class ROIDescription;
class Network;
class TaskStatus;
class Action;
class TaskSchedule;
class TasksData;
class Event;
class EventList;
class SubmitSlot;
class TestInfo;
class Test;

enum SDPOp_SDPOpMode {
  SDPOp_SDPOpMode_SDP_OP_PER_LAYER = 0,
  SDPOp_SDPOpMode_SDP_OP_PER_KERNEL = 1,
  SDPOp_SDPOpMode_SDP_OP_PER_POINT = 2
};
bool SDPOp_SDPOpMode_IsValid(int value);
const SDPOp_SDPOpMode SDPOp_SDPOpMode_SDPOpMode_MIN = SDPOp_SDPOpMode_SDP_OP_PER_LAYER;
const SDPOp_SDPOpMode SDPOp_SDPOpMode_SDPOpMode_MAX = SDPOp_SDPOpMode_SDP_OP_PER_POINT;
const int SDPOp_SDPOpMode_SDPOpMode_ARRAYSIZE = SDPOp_SDPOpMode_SDPOpMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* SDPOp_SDPOpMode_descriptor();
inline const ::std::string& SDPOp_SDPOpMode_Name(SDPOp_SDPOpMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    SDPOp_SDPOpMode_descriptor(), value);
}
inline bool SDPOp_SDPOpMode_Parse(
    const ::std::string& name, SDPOp_SDPOpMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SDPOp_SDPOpMode>(
    SDPOp_SDPOpMode_descriptor(), name, value);
}
enum PDPOpDesc_PoolingMode {
  PDPOpDesc_PoolingMode_MODE_AVG = 0,
  PDPOpDesc_PoolingMode_MODE_MAX = 1,
  PDPOpDesc_PoolingMode_MODE_MIN = 2
};
bool PDPOpDesc_PoolingMode_IsValid(int value);
const PDPOpDesc_PoolingMode PDPOpDesc_PoolingMode_PoolingMode_MIN = PDPOpDesc_PoolingMode_MODE_AVG;
const PDPOpDesc_PoolingMode PDPOpDesc_PoolingMode_PoolingMode_MAX = PDPOpDesc_PoolingMode_MODE_MIN;
const int PDPOpDesc_PoolingMode_PoolingMode_ARRAYSIZE = PDPOpDesc_PoolingMode_PoolingMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* PDPOpDesc_PoolingMode_descriptor();
inline const ::std::string& PDPOpDesc_PoolingMode_Name(PDPOpDesc_PoolingMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    PDPOpDesc_PoolingMode_descriptor(), value);
}
inline bool PDPOpDesc_PoolingMode_Parse(
    const ::std::string& name, PDPOpDesc_PoolingMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PDPOpDesc_PoolingMode>(
    PDPOpDesc_PoolingMode_descriptor(), name, value);
}
enum Consumer_EventType {
  Consumer_EventType_OP_COMPLETED = 1,
  Consumer_EventType_OP_PROGRAMMED = 2,
  Consumer_EventType_OP_ENABLED = 3,
  Consumer_EventType_CDMA_WT_DONE = 4,
  Consumer_EventType_CDMA_DT_DONE = 5
};
bool Consumer_EventType_IsValid(int value);
const Consumer_EventType Consumer_EventType_EventType_MIN = Consumer_EventType_OP_COMPLETED;
const Consumer_EventType Consumer_EventType_EventType_MAX = Consumer_EventType_CDMA_DT_DONE;
const int Consumer_EventType_EventType_ARRAYSIZE = Consumer_EventType_EventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Consumer_EventType_descriptor();
inline const ::std::string& Consumer_EventType_Name(Consumer_EventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Consumer_EventType_descriptor(), value);
}
inline bool Consumer_EventType_Parse(
    const ::std::string& name, Consumer_EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Consumer_EventType>(
    Consumer_EventType_descriptor(), name, value);
}
enum Event_EventType {
  Event_EventType_SYNCPOINT = 0,
  Event_EventType_SYNCFD = 1,
  Event_EventType_SEMAPHORE = 2,
  Event_EventType_TS_SEMAPHORE = 3
};
bool Event_EventType_IsValid(int value);
const Event_EventType Event_EventType_EventType_MIN = Event_EventType_SYNCPOINT;
const Event_EventType Event_EventType_EventType_MAX = Event_EventType_TS_SEMAPHORE;
const int Event_EventType_EventType_ARRAYSIZE = Event_EventType_EventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Event_EventType_descriptor();
inline const ::std::string& Event_EventType_Name(Event_EventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Event_EventType_descriptor(), value);
}
inline bool Event_EventType_Parse(
    const ::std::string& name, Event_EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Event_EventType>(
    Event_EventType_descriptor(), name, value);
}
enum DataPrecision {
  PRECISION_INT8 = 0,
  PRECISION_INT16 = 1,
  PRECISION_FP16 = 2
};
bool DataPrecision_IsValid(int value);
const DataPrecision DataPrecision_MIN = PRECISION_INT8;
const DataPrecision DataPrecision_MAX = PRECISION_FP16;
const int DataPrecision_ARRAYSIZE = DataPrecision_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataPrecision_descriptor();
inline const ::std::string& DataPrecision_Name(DataPrecision value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataPrecision_descriptor(), value);
}
inline bool DataPrecision_Parse(
    const ::std::string& name, DataPrecision* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataPrecision>(
    DataPrecision_descriptor(), name, value);
}
enum MemType {
  DLA_MEM_MC = 0,
  DLA_MEM_CV = 1,
  DLA_MEM_HW = 2
};
bool MemType_IsValid(int value);
const MemType MemType_MIN = DLA_MEM_MC;
const MemType MemType_MAX = DLA_MEM_HW;
const int MemType_ARRAYSIZE = MemType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemType_descriptor();
inline const ::std::string& MemType_Name(MemType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemType_descriptor(), value);
}
inline bool MemType_Parse(
    const ::std::string& name, MemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemType>(
    MemType_descriptor(), name, value);
}
enum MemFlag {
  DLA_MEM_ALLOC = 0,
  DLA_MEM_SET = 1,
  DLA_MEM_INPUT = 2,
  DLA_MEM_OUTPUT = 3,
  DLA_MEM_DEBUG = 4
};
bool MemFlag_IsValid(int value);
const MemFlag MemFlag_MIN = DLA_MEM_ALLOC;
const MemFlag MemFlag_MAX = DLA_MEM_DEBUG;
const int MemFlag_ARRAYSIZE = MemFlag_MAX + 1;

const ::google::protobuf::EnumDescriptor* MemFlag_descriptor();
inline const ::std::string& MemFlag_Name(MemFlag value) {
  return ::google::protobuf::internal::NameOfEnum(
    MemFlag_descriptor(), value);
}
inline bool MemFlag_Parse(
    const ::std::string& name, MemFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MemFlag>(
    MemFlag_descriptor(), name, value);
}
enum EngineID {
  DLA_0 = 0,
  DLA_1 = 1
};
bool EngineID_IsValid(int value);
const EngineID EngineID_MIN = DLA_0;
const EngineID EngineID_MAX = DLA_1;
const int EngineID_ARRAYSIZE = EngineID_MAX + 1;

const ::google::protobuf::EnumDescriptor* EngineID_descriptor();
inline const ::std::string& EngineID_Name(EngineID value) {
  return ::google::protobuf::internal::NameOfEnum(
    EngineID_descriptor(), value);
}
inline bool EngineID_Parse(
    const ::std::string& name, EngineID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EngineID>(
    EngineID_descriptor(), name, value);
}
enum LayerType {
  DLA_OP_BDMA = 0,
  DLA_OP_CONV = 1,
  DLA_OP_SDP = 2,
  DLA_OP_PDP = 3,
  DLA_OP_CDP = 4,
  DLA_OP_RUBIK = 5
};
bool LayerType_IsValid(int value);
const LayerType LayerType_MIN = DLA_OP_BDMA;
const LayerType LayerType_MAX = DLA_OP_RUBIK;
const int LayerType_ARRAYSIZE = LayerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LayerType_descriptor();
inline const ::std::string& LayerType_Name(LayerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LayerType_descriptor(), value);
}
inline bool LayerType_Parse(
    const ::std::string& name, LayerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LayerType>(
    LayerType_descriptor(), name, value);
}
enum ALUType {
  ALU_MAX = 0,
  ALU_MIN = 1,
  ALU_SUM = 2,
  ALU_EQL = 3
};
bool ALUType_IsValid(int value);
const ALUType ALUType_MIN = ALU_MAX;
const ALUType ALUType_MAX = ALU_EQL;
const int ALUType_ARRAYSIZE = ALUType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ALUType_descriptor();
inline const ::std::string& ALUType_Name(ALUType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ALUType_descriptor(), value);
}
inline bool ALUType_Parse(
    const ::std::string& name, ALUType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ALUType>(
    ALUType_descriptor(), name, value);
}
enum SDPOpType {
  SDP_OP_NONE = 0,
  SDP_OP_MUL = 1,
  SDP_OP_ADD = 2,
  SDP_OP_BOTH = 3
};
bool SDPOpType_IsValid(int value);
const SDPOpType SDPOpType_MIN = SDP_OP_NONE;
const SDPOpType SDPOpType_MAX = SDP_OP_BOTH;
const int SDPOpType_ARRAYSIZE = SDPOpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SDPOpType_descriptor();
inline const ::std::string& SDPOpType_Name(SDPOpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SDPOpType_descriptor(), value);
}
inline bool SDPOpType_Parse(
    const ::std::string& name, SDPOpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SDPOpType>(
    SDPOpType_descriptor(), name, value);
}
enum LUTLOGSize {
  EXP_TABLE_ENTRY_LOG2 = 6,
  LINEAR_TABLE_ENTRY_LOG2 = 8
};
bool LUTLOGSize_IsValid(int value);
const LUTLOGSize LUTLOGSize_MIN = EXP_TABLE_ENTRY_LOG2;
const LUTLOGSize LUTLOGSize_MAX = LINEAR_TABLE_ENTRY_LOG2;
const int LUTLOGSize_ARRAYSIZE = LUTLOGSize_MAX + 1;

const ::google::protobuf::EnumDescriptor* LUTLOGSize_descriptor();
inline const ::std::string& LUTLOGSize_Name(LUTLOGSize value) {
  return ::google::protobuf::internal::NameOfEnum(
    LUTLOGSize_descriptor(), value);
}
inline bool LUTLOGSize_Parse(
    const ::std::string& name, LUTLOGSize* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LUTLOGSize>(
    LUTLOGSize_descriptor(), name, value);
}
enum LUTTable {
  EXP_TABLE = 0,
  LINEAR_TABLE = 1
};
bool LUTTable_IsValid(int value);
const LUTTable LUTTable_MIN = EXP_TABLE;
const LUTTable LUTTable_MAX = LINEAR_TABLE;
const int LUTTable_ARRAYSIZE = LUTTable_MAX + 1;

const ::google::protobuf::EnumDescriptor* LUTTable_descriptor();
inline const ::std::string& LUTTable_Name(LUTTable value) {
  return ::google::protobuf::internal::NameOfEnum(
    LUTTable_descriptor(), value);
}
inline bool LUTTable_Parse(
    const ::std::string& name, LUTTable* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LUTTable>(
    LUTTable_descriptor(), name, value);
}
enum LUTMethod {
  METHOD_EXPONENTIAL = 0,
  METHOD_LINEAR = 1
};
bool LUTMethod_IsValid(int value);
const LUTMethod LUTMethod_MIN = METHOD_EXPONENTIAL;
const LUTMethod LUTMethod_MAX = METHOD_LINEAR;
const int LUTMethod_ARRAYSIZE = LUTMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* LUTMethod_descriptor();
inline const ::std::string& LUTMethod_Name(LUTMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    LUTMethod_descriptor(), value);
}
inline bool LUTMethod_Parse(
    const ::std::string& name, LUTMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LUTMethod>(
    LUTMethod_descriptor(), name, value);
}
enum LUTPriority {
  PRI_EXPONENTIAL = 0,
  PRI_LINEAR = 1
};
bool LUTPriority_IsValid(int value);
const LUTPriority LUTPriority_MIN = PRI_EXPONENTIAL;
const LUTPriority LUTPriority_MAX = PRI_LINEAR;
const int LUTPriority_ARRAYSIZE = LUTPriority_MAX + 1;

const ::google::protobuf::EnumDescriptor* LUTPriority_descriptor();
inline const ::std::string& LUTPriority_Name(LUTPriority value) {
  return ::google::protobuf::internal::NameOfEnum(
    LUTPriority_descriptor(), value);
}
inline bool LUTPriority_Parse(
    const ::std::string& name, LUTPriority* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LUTPriority>(
    LUTPriority_descriptor(), name, value);
}
enum ConvMode {
  DIRECT = 0,
  WINOGRAD = 1
};
bool ConvMode_IsValid(int value);
const ConvMode ConvMode_MIN = DIRECT;
const ConvMode ConvMode_MAX = WINOGRAD;
const int ConvMode_ARRAYSIZE = ConvMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConvMode_descriptor();
inline const ::std::string& ConvMode_Name(ConvMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConvMode_descriptor(), value);
}
inline bool ConvMode_Parse(
    const ::std::string& name, ConvMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConvMode>(
    ConvMode_descriptor(), name, value);
}
enum ConvPixelMAP {
  PITCH_LINEAR = 0
};
bool ConvPixelMAP_IsValid(int value);
const ConvPixelMAP ConvPixelMAP_MIN = PITCH_LINEAR;
const ConvPixelMAP ConvPixelMAP_MAX = PITCH_LINEAR;
const int ConvPixelMAP_ARRAYSIZE = ConvPixelMAP_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConvPixelMAP_descriptor();
inline const ::std::string& ConvPixelMAP_Name(ConvPixelMAP value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConvPixelMAP_descriptor(), value);
}
inline bool ConvPixelMAP_Parse(
    const ::std::string& name, ConvPixelMAP* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConvPixelMAP>(
    ConvPixelMAP_descriptor(), name, value);
}
enum PixelOverride {
  OVERRIDE_UINT = 0,
  OVERRIDE_INT = 1
};
bool PixelOverride_IsValid(int value);
const PixelOverride PixelOverride_MIN = OVERRIDE_UINT;
const PixelOverride PixelOverride_MAX = OVERRIDE_INT;
const int PixelOverride_ARRAYSIZE = PixelOverride_MAX + 1;

const ::google::protobuf::EnumDescriptor* PixelOverride_descriptor();
inline const ::std::string& PixelOverride_Name(PixelOverride value) {
  return ::google::protobuf::internal::NameOfEnum(
    PixelOverride_descriptor(), value);
}
inline bool PixelOverride_Parse(
    const ::std::string& name, PixelOverride* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PixelOverride>(
    PixelOverride_descriptor(), name, value);
}
enum PoolSize {
  SIZE_1 = 0,
  SIZE_2 = 1,
  SIZE_3 = 2,
  SIZE_4 = 3,
  SIZE_5 = 4,
  SIZE_6 = 5,
  SIZE_7 = 6,
  SIZE_8 = 7
};
bool PoolSize_IsValid(int value);
const PoolSize PoolSize_MIN = SIZE_1;
const PoolSize PoolSize_MAX = SIZE_8;
const int PoolSize_ARRAYSIZE = PoolSize_MAX + 1;

const ::google::protobuf::EnumDescriptor* PoolSize_descriptor();
inline const ::std::string& PoolSize_Name(PoolSize value) {
  return ::google::protobuf::internal::NameOfEnum(
    PoolSize_descriptor(), value);
}
inline bool PoolSize_Parse(
    const ::std::string& name, PoolSize* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PoolSize>(
    PoolSize_descriptor(), name, value);
}
enum RUBIKMode {
  MODE_CONTRACT = 0,
  MODE_SPLIT = 1,
  MODE_MERGE = 2
};
bool RUBIKMode_IsValid(int value);
const RUBIKMode RUBIKMode_MIN = MODE_CONTRACT;
const RUBIKMode RUBIKMode_MAX = MODE_MERGE;
const int RUBIKMode_ARRAYSIZE = RUBIKMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* RUBIKMode_descriptor();
inline const ::std::string& RUBIKMode_Name(RUBIKMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    RUBIKMode_descriptor(), value);
}
inline bool RUBIKMode_Parse(
    const ::std::string& name, RUBIKMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RUBIKMode>(
    RUBIKMode_descriptor(), name, value);
}
enum WeightFormat {
  UNCOMPRESSED = 0,
  COMPRESSED = 1
};
bool WeightFormat_IsValid(int value);
const WeightFormat WeightFormat_MIN = UNCOMPRESSED;
const WeightFormat WeightFormat_MAX = COMPRESSED;
const int WeightFormat_ARRAYSIZE = WeightFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* WeightFormat_descriptor();
inline const ::std::string& WeightFormat_Name(WeightFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    WeightFormat_descriptor(), value);
}
inline bool WeightFormat_Parse(
    const ::std::string& name, WeightFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WeightFormat>(
    WeightFormat_descriptor(), name, value);
}
enum MeanFormat {
  MEAN_DISABLE = 0,
  MEAN_ENABLE = 1
};
bool MeanFormat_IsValid(int value);
const MeanFormat MeanFormat_MIN = MEAN_DISABLE;
const MeanFormat MeanFormat_MAX = MEAN_ENABLE;
const int MeanFormat_ARRAYSIZE = MeanFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* MeanFormat_descriptor();
inline const ::std::string& MeanFormat_Name(MeanFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    MeanFormat_descriptor(), value);
}
inline bool MeanFormat_Parse(
    const ::std::string& name, MeanFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MeanFormat>(
    MeanFormat_descriptor(), name, value);
}
enum SDPActivation {
  ACT_NONE = 0,
  ACT_RELU = 1,
  ACT_LUT = 2,
  ACT_PRELU = 3
};
bool SDPActivation_IsValid(int value);
const SDPActivation SDPActivation_MIN = ACT_NONE;
const SDPActivation SDPActivation_MAX = ACT_PRELU;
const int SDPActivation_ARRAYSIZE = SDPActivation_MAX + 1;

const ::google::protobuf::EnumDescriptor* SDPActivation_descriptor();
inline const ::std::string& SDPActivation_Name(SDPActivation value) {
  return ::google::protobuf::internal::NameOfEnum(
    SDPActivation_descriptor(), value);
}
inline bool SDPActivation_Parse(
    const ::std::string& name, SDPActivation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SDPActivation>(
    SDPActivation_descriptor(), name, value);
}
enum DataFormat {
  FORMAT_T_R8 = 0,
  FORMAT_T_R10 = 1,
  FORMAT_T_R12 = 2,
  FORMAT_T_R16 = 3,
  FORMAT_T_R16_I = 4,
  FORMAT_T_R16_F = 5,
  FORMAT_T_A16B16G16R16 = 6,
  FORMAT_T_X16B16G16R16 = 7,
  FORMAT_T_A16B16G16R16_F = 8,
  FORMAT_T_A16Y16U16V16 = 9,
  FORMAT_T_V16U16Y16A16 = 10,
  FORMAT_T_A16Y16U16V16_F = 11,
  FORMAT_T_A8B8G8R8 = 12,
  FORMAT_T_A8R8G8B8 = 13,
  FORMAT_T_B8G8R8A8 = 14,
  FORMAT_T_R8G8B8A8 = 15,
  FORMAT_T_X8B8G8R8 = 16,
  FORMAT_T_X8R8G8B8 = 17,
  FORMAT_T_B8G8R8X8 = 18,
  FORMAT_T_R8G8B8X8 = 19,
  FORMAT_T_A2B10G10R10 = 20,
  FORMAT_T_A2R10G10B10 = 21,
  FORMAT_T_B10G10R10A2 = 22,
  FORMAT_T_R10G10B10A2 = 23,
  FORMAT_T_A2Y10U10V10 = 24,
  FORMAT_T_V10U10Y10A2 = 25,
  FORMAT_T_A8Y8U8V8 = 26,
  FORMAT_T_V8U8Y8A8 = 27,
  FORMAT_T_Y8___U8V8_N444 = 28,
  FORMAT_T_Y8___V8U8_N444 = 29,
  FORMAT_T_Y10___U10V10_N444 = 30,
  FORMAT_T_Y10___V10U10_N444 = 31,
  FORMAT_T_Y12___U12V12_N444 = 32,
  FORMAT_T_Y12___V12U12_N444 = 33,
  FORMAT_T_Y16___U16V16_N444 = 34,
  FORMAT_T_Y16___V16U16_N444 = 35,
  FORMAT_FEATURE = 36
};
bool DataFormat_IsValid(int value);
const DataFormat DataFormat_MIN = FORMAT_T_R8;
const DataFormat DataFormat_MAX = FORMAT_FEATURE;
const int DataFormat_ARRAYSIZE = DataFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataFormat_descriptor();
inline const ::std::string& DataFormat_Name(DataFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataFormat_descriptor(), value);
}
inline bool DataFormat_Parse(
    const ::std::string& name, DataFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataFormat>(
    DataFormat_descriptor(), name, value);
}
enum FillerType {
  FILL_NONE = 0,
  FILL_FILE = 1,
  FILL_CONSTANT = 2,
  FILL_RANDOM = 3
};
bool FillerType_IsValid(int value);
const FillerType FillerType_MIN = FILL_NONE;
const FillerType FillerType_MAX = FILL_RANDOM;
const int FillerType_ARRAYSIZE = FillerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FillerType_descriptor();
inline const ::std::string& FillerType_Name(FillerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FillerType_descriptor(), value);
}
inline bool FillerType_Parse(
    const ::std::string& name, FillerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FillerType>(
    FillerType_descriptor(), name, value);
}
enum FileType {
  FILE_PROTOBIN = 0,
  FILE_PROTOTXT = 1,
  FILE_RAWBIN = 2,
  FILE_PNG = 3,
  FILE_JPEG = 4
};
bool FileType_IsValid(int value);
const FileType FileType_MIN = FILE_PROTOBIN;
const FileType FileType_MAX = FILE_JPEG;
const int FileType_ARRAYSIZE = FileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileType_descriptor();
inline const ::std::string& FileType_Name(FileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileType_descriptor(), value);
}
inline bool FileType_Parse(
    const ::std::string& name, FileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileType>(
    FileType_descriptor(), name, value);
}
enum DataType {
  DLA_DATA_DC_WEIGHT = 0,
  DLA_DATA_WG_WEIGHT = 1,
  DLA_DATA_IMG_WEIGHT = 2,
  DLA_DATA_FC_WEIGHT = 3,
  DLA_DATA_BIAS = 4,
  DLA_DATA_IMAGE = 5,
  DLA_DATA_LUT = 6,
  DLA_DATA_FEATURE = 7
};
bool DataType_IsValid(int value);
const DataType DataType_MIN = DLA_DATA_DC_WEIGHT;
const DataType DataType_MAX = DLA_DATA_FEATURE;
const int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataType_descriptor();
inline const ::std::string& DataType_Name(DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataType_descriptor(), value);
}
inline bool DataType_Parse(
    const ::std::string& name, DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class LUTOffset : public ::google::protobuf::Message {
 public:
  LUTOffset();
  virtual ~LUTOffset();

  LUTOffset(const LUTOffset& from);

  inline LUTOffset& operator=(const LUTOffset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LUTOffset& default_instance();

  enum LutOffsetOneofCase {
    kExpOffset = 1,
    kFracBits = 2,
    LUT_OFFSET_ONEOF_NOT_SET = 0,
  };

  void Swap(LUTOffset* other);

  // implements Message ----------------------------------------------

  LUTOffset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LUTOffset& from);
  void MergeFrom(const LUTOffset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 exp_offset = 1;
  inline bool has_exp_offset() const;
  inline void clear_exp_offset();
  static const int kExpOffsetFieldNumber = 1;
  inline ::google::protobuf::int32 exp_offset() const;
  inline void set_exp_offset(::google::protobuf::int32 value);

  // optional int32 frac_bits = 2;
  inline bool has_frac_bits() const;
  inline void clear_frac_bits();
  static const int kFracBitsFieldNumber = 2;
  inline ::google::protobuf::int32 frac_bits() const;
  inline void set_frac_bits(::google::protobuf::int32 value);

  inline LutOffsetOneofCase lut_offset_oneof_case() const;
  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.LUTOffset)
 private:
  inline void set_has_exp_offset();
  inline void set_has_frac_bits();

  inline bool has_lut_offset_oneof();
  void clear_lut_offset_oneof();
  inline void clear_has_lut_offset_oneof();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union LutOffsetOneofUnion {
    ::google::protobuf::int32 exp_offset_;
    ::google::protobuf::int32 frac_bits_;
  } lut_offset_oneof_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static LUTOffset* default_instance_;
};
// -------------------------------------------------------------------

class FloatData : public ::google::protobuf::Message {
 public:
  FloatData();
  virtual ~FloatData();

  FloatData(const FloatData& from);

  inline FloatData& operator=(const FloatData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatData& default_instance();

  void Swap(FloatData* other);

  // implements Message ----------------------------------------------

  FloatData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FloatData& from);
  void MergeFrom(const FloatData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 scale = 1;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 1;
  inline ::google::protobuf::int32 scale() const;
  inline void set_scale(::google::protobuf::int32 value);

  // required int32 shifter = 2;
  inline bool has_shifter() const;
  inline void clear_shifter();
  static const int kShifterFieldNumber = 2;
  inline ::google::protobuf::int32 shifter() const;
  inline void set_shifter(::google::protobuf::int32 value);

  // optional uint32 reserved0 = 3 [default = 0];
  inline bool has_reserved0() const;
  inline void clear_reserved0();
  static const int kReserved0FieldNumber = 3;
  inline ::google::protobuf::uint32 reserved0() const;
  inline void set_reserved0(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.FloatData)
 private:
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_shifter();
  inline void clear_has_shifter();
  inline void set_has_reserved0();
  inline void clear_has_reserved0();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 scale_;
  ::google::protobuf::int32 shifter_;
  ::google::protobuf::uint32 reserved0_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static FloatData* default_instance_;
};
// -------------------------------------------------------------------

class DLASlope : public ::google::protobuf::Message {
 public:
  DLASlope();
  virtual ~DLASlope();

  DLASlope(const DLASlope& from);

  inline DLASlope& operator=(const DLASlope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DLASlope& default_instance();

  enum DlaSlopeOneofCase {
    kDataI = 1,
    kDataF = 2,
    DLA_SLOPE_ONEOF_NOT_SET = 0,
  };

  void Swap(DLASlope* other);

  // implements Message ----------------------------------------------

  DLASlope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DLASlope& from);
  void MergeFrom(const DLASlope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nvdla_prototest_interface.FloatData data_i = 1;
  inline bool has_data_i() const;
  inline void clear_data_i();
  static const int kDataIFieldNumber = 1;
  inline const ::nvdla_prototest_interface::FloatData& data_i() const;
  inline ::nvdla_prototest_interface::FloatData* mutable_data_i();
  inline ::nvdla_prototest_interface::FloatData* release_data_i();
  inline void set_allocated_data_i(::nvdla_prototest_interface::FloatData* data_i);

  // optional uint32 data_f = 2;
  inline bool has_data_f() const;
  inline void clear_data_f();
  static const int kDataFFieldNumber = 2;
  inline ::google::protobuf::uint32 data_f() const;
  inline void set_data_f(::google::protobuf::uint32 value);

  inline DlaSlopeOneofCase dla_slope_oneof_case() const;
  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.DLASlope)
 private:
  inline void set_has_data_i();
  inline void set_has_data_f();

  inline bool has_dla_slope_oneof();
  void clear_dla_slope_oneof();
  inline void clear_has_dla_slope_oneof();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union DlaSlopeOneofUnion {
    ::nvdla_prototest_interface::FloatData* data_i_;
    ::google::protobuf::uint32 data_f_;
  } dla_slope_oneof_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static DLASlope* default_instance_;
};
// -------------------------------------------------------------------

class DataFile : public ::google::protobuf::Message {
 public:
  DataFile();
  virtual ~DataFile();

  DataFile(const DataFile& from);

  inline DataFile& operator=(const DataFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataFile& default_instance();

  void Swap(DataFile* other);

  // implements Message ----------------------------------------------

  DataFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataFile& from);
  void MergeFrom(const DataFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .nvdla_prototest_interface.DataType data_type = 2;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 2;
  inline ::nvdla_prototest_interface::DataType data_type() const;
  inline void set_data_type(::nvdla_prototest_interface::DataType value);

  // required uint32 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // required uint32 size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.FileType file_type = 5;
  inline bool has_file_type() const;
  inline void clear_file_type();
  static const int kFileTypeFieldNumber = 5;
  inline ::nvdla_prototest_interface::FileType file_type() const;
  inline void set_file_type(::nvdla_prototest_interface::FileType value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.DataFile)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_data_type();
  inline void clear_has_data_type();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_file_type();
  inline void clear_has_file_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int data_type_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 size_;
  int file_type_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static DataFile* default_instance_;
};
// -------------------------------------------------------------------

class Constant : public ::google::protobuf::Message {
 public:
  Constant();
  virtual ~Constant();

  Constant(const Constant& from);

  inline Constant& operator=(const Constant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Constant& default_instance();

  void Swap(Constant* other);

  // implements Message ----------------------------------------------

  Constant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Constant& from);
  void MergeFrom(const Constant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.Constant)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 value_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static Constant* default_instance_;
};
// -------------------------------------------------------------------

class DataFiller : public ::google::protobuf::Message {
 public:
  DataFiller();
  virtual ~DataFiller();

  DataFiller(const DataFiller& from);

  inline DataFiller& operator=(const DataFiller& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataFiller& default_instance();

  enum DataFillerOneofCase {
    kDataFile = 1,
    kConst = 2,
    DATA_FILLER_ONEOF_NOT_SET = 0,
  };

  void Swap(DataFiller* other);

  // implements Message ----------------------------------------------

  DataFiller* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataFiller& from);
  void MergeFrom(const DataFiller& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nvdla_prototest_interface.DataFile data_file = 1;
  inline bool has_data_file() const;
  inline void clear_data_file();
  static const int kDataFileFieldNumber = 1;
  inline const ::nvdla_prototest_interface::DataFile& data_file() const;
  inline ::nvdla_prototest_interface::DataFile* mutable_data_file();
  inline ::nvdla_prototest_interface::DataFile* release_data_file();
  inline void set_allocated_data_file(::nvdla_prototest_interface::DataFile* data_file);

  // optional .nvdla_prototest_interface.Constant const = 2;
  inline bool has_const_() const;
  inline void clear_const_();
  static const int kConstFieldNumber = 2;
  inline const ::nvdla_prototest_interface::Constant& const_() const;
  inline ::nvdla_prototest_interface::Constant* mutable_const_();
  inline ::nvdla_prototest_interface::Constant* release_const_();
  inline void set_allocated_const_(::nvdla_prototest_interface::Constant* const_);

  inline DataFillerOneofCase data_filler_oneof_case() const;
  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.DataFiller)
 private:
  inline void set_has_data_file();
  inline void set_has_const_();

  inline bool has_data_filler_oneof();
  void clear_data_filler_oneof();
  inline void clear_has_data_filler_oneof();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union DataFillerOneofUnion {
    ::nvdla_prototest_interface::DataFile* data_file_;
    ::nvdla_prototest_interface::Constant* const__;
  } data_filler_oneof_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static DataFiller* default_instance_;
};
// -------------------------------------------------------------------

class LUTParam : public ::google::protobuf::Message {
 public:
  LUTParam();
  virtual ~LUTParam();

  LUTParam(const LUTParam& from);

  inline LUTParam& operator=(const LUTParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LUTParam& default_instance();

  void Swap(LUTParam* other);

  // implements Message ----------------------------------------------

  LUTParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LUTParam& from);
  void MergeFrom(const LUTParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 linear_exp_table = 1 [packed = true];
  inline int linear_exp_table_size() const;
  inline void clear_linear_exp_table();
  static const int kLinearExpTableFieldNumber = 1;
  inline ::google::protobuf::int32 linear_exp_table(int index) const;
  inline void set_linear_exp_table(int index, ::google::protobuf::int32 value);
  inline void add_linear_exp_table(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      linear_exp_table() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_linear_exp_table();

  // repeated int32 linear_only_table = 2 [packed = true];
  inline int linear_only_table_size() const;
  inline void clear_linear_only_table();
  static const int kLinearOnlyTableFieldNumber = 2;
  inline ::google::protobuf::int32 linear_only_table(int index) const;
  inline void set_linear_only_table(int index, ::google::protobuf::int32 value);
  inline void add_linear_only_table(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      linear_only_table() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_linear_only_table();

  // required .nvdla_prototest_interface.LUTOffset linear_exp_offset = 3;
  inline bool has_linear_exp_offset() const;
  inline void clear_linear_exp_offset();
  static const int kLinearExpOffsetFieldNumber = 3;
  inline const ::nvdla_prototest_interface::LUTOffset& linear_exp_offset() const;
  inline ::nvdla_prototest_interface::LUTOffset* mutable_linear_exp_offset();
  inline ::nvdla_prototest_interface::LUTOffset* release_linear_exp_offset();
  inline void set_allocated_linear_exp_offset(::nvdla_prototest_interface::LUTOffset* linear_exp_offset);

  // required .nvdla_prototest_interface.LUTOffset linear_only_offset = 4;
  inline bool has_linear_only_offset() const;
  inline void clear_linear_only_offset();
  static const int kLinearOnlyOffsetFieldNumber = 4;
  inline const ::nvdla_prototest_interface::LUTOffset& linear_only_offset() const;
  inline ::nvdla_prototest_interface::LUTOffset* mutable_linear_only_offset();
  inline ::nvdla_prototest_interface::LUTOffset* release_linear_only_offset();
  inline void set_allocated_linear_only_offset(::nvdla_prototest_interface::LUTOffset* linear_only_offset);

  // required uint64 linear_exp_start = 5;
  inline bool has_linear_exp_start() const;
  inline void clear_linear_exp_start();
  static const int kLinearExpStartFieldNumber = 5;
  inline ::google::protobuf::uint64 linear_exp_start() const;
  inline void set_linear_exp_start(::google::protobuf::uint64 value);

  // required uint64 linear_exp_end = 6;
  inline bool has_linear_exp_end() const;
  inline void clear_linear_exp_end();
  static const int kLinearExpEndFieldNumber = 6;
  inline ::google::protobuf::uint64 linear_exp_end() const;
  inline void set_linear_exp_end(::google::protobuf::uint64 value);

  // required uint64 linear_only_start = 7;
  inline bool has_linear_only_start() const;
  inline void clear_linear_only_start();
  static const int kLinearOnlyStartFieldNumber = 7;
  inline ::google::protobuf::uint64 linear_only_start() const;
  inline void set_linear_only_start(::google::protobuf::uint64 value);

  // required uint64 linear_only_end = 8;
  inline bool has_linear_only_end() const;
  inline void clear_linear_only_end();
  static const int kLinearOnlyEndFieldNumber = 8;
  inline ::google::protobuf::uint64 linear_only_end() const;
  inline void set_linear_only_end(::google::protobuf::uint64 value);

  // required .nvdla_prototest_interface.DLASlope linear_exp_underflow_slope = 9;
  inline bool has_linear_exp_underflow_slope() const;
  inline void clear_linear_exp_underflow_slope();
  static const int kLinearExpUnderflowSlopeFieldNumber = 9;
  inline const ::nvdla_prototest_interface::DLASlope& linear_exp_underflow_slope() const;
  inline ::nvdla_prototest_interface::DLASlope* mutable_linear_exp_underflow_slope();
  inline ::nvdla_prototest_interface::DLASlope* release_linear_exp_underflow_slope();
  inline void set_allocated_linear_exp_underflow_slope(::nvdla_prototest_interface::DLASlope* linear_exp_underflow_slope);

  // required .nvdla_prototest_interface.DLASlope linear_exp_overflow_slope = 10;
  inline bool has_linear_exp_overflow_slope() const;
  inline void clear_linear_exp_overflow_slope();
  static const int kLinearExpOverflowSlopeFieldNumber = 10;
  inline const ::nvdla_prototest_interface::DLASlope& linear_exp_overflow_slope() const;
  inline ::nvdla_prototest_interface::DLASlope* mutable_linear_exp_overflow_slope();
  inline ::nvdla_prototest_interface::DLASlope* release_linear_exp_overflow_slope();
  inline void set_allocated_linear_exp_overflow_slope(::nvdla_prototest_interface::DLASlope* linear_exp_overflow_slope);

  // required .nvdla_prototest_interface.DLASlope linear_only_underflow_slope = 11;
  inline bool has_linear_only_underflow_slope() const;
  inline void clear_linear_only_underflow_slope();
  static const int kLinearOnlyUnderflowSlopeFieldNumber = 11;
  inline const ::nvdla_prototest_interface::DLASlope& linear_only_underflow_slope() const;
  inline ::nvdla_prototest_interface::DLASlope* mutable_linear_only_underflow_slope();
  inline ::nvdla_prototest_interface::DLASlope* release_linear_only_underflow_slope();
  inline void set_allocated_linear_only_underflow_slope(::nvdla_prototest_interface::DLASlope* linear_only_underflow_slope);

  // required .nvdla_prototest_interface.DLASlope linear_only_overflow_slope = 12;
  inline bool has_linear_only_overflow_slope() const;
  inline void clear_linear_only_overflow_slope();
  static const int kLinearOnlyOverflowSlopeFieldNumber = 12;
  inline const ::nvdla_prototest_interface::DLASlope& linear_only_overflow_slope() const;
  inline ::nvdla_prototest_interface::DLASlope* mutable_linear_only_overflow_slope();
  inline ::nvdla_prototest_interface::DLASlope* release_linear_only_overflow_slope();
  inline void set_allocated_linear_only_overflow_slope(::nvdla_prototest_interface::DLASlope* linear_only_overflow_slope);

  // required uint32 hybrid_priority = 13;
  inline bool has_hybrid_priority() const;
  inline void clear_hybrid_priority();
  static const int kHybridPriorityFieldNumber = 13;
  inline ::google::protobuf::uint32 hybrid_priority() const;
  inline void set_hybrid_priority(::google::protobuf::uint32 value);

  // required uint32 underflow_priority = 14;
  inline bool has_underflow_priority() const;
  inline void clear_underflow_priority();
  static const int kUnderflowPriorityFieldNumber = 14;
  inline ::google::protobuf::uint32 underflow_priority() const;
  inline void set_underflow_priority(::google::protobuf::uint32 value);

  // required uint32 overflow_priority = 15;
  inline bool has_overflow_priority() const;
  inline void clear_overflow_priority();
  static const int kOverflowPriorityFieldNumber = 15;
  inline ::google::protobuf::uint32 overflow_priority() const;
  inline void set_overflow_priority(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.LUTMethod method = 16;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 16;
  inline ::nvdla_prototest_interface::LUTMethod method() const;
  inline void set_method(::nvdla_prototest_interface::LUTMethod value);

  // optional .nvdla_prototest_interface.FillerType fill_type = 17 [default = FILL_NONE];
  inline bool has_fill_type() const;
  inline void clear_fill_type();
  static const int kFillTypeFieldNumber = 17;
  inline ::nvdla_prototest_interface::FillerType fill_type() const;
  inline void set_fill_type(::nvdla_prototest_interface::FillerType value);

  // optional .nvdla_prototest_interface.DataFiller filler = 18;
  inline bool has_filler() const;
  inline void clear_filler();
  static const int kFillerFieldNumber = 18;
  inline const ::nvdla_prototest_interface::DataFiller& filler() const;
  inline ::nvdla_prototest_interface::DataFiller* mutable_filler();
  inline ::nvdla_prototest_interface::DataFiller* release_filler();
  inline void set_allocated_filler(::nvdla_prototest_interface::DataFiller* filler);

  // optional .nvdla_prototest_interface.DataPrecision precision = 19 [default = PRECISION_INT16];
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 19;
  inline ::nvdla_prototest_interface::DataPrecision precision() const;
  inline void set_precision(::nvdla_prototest_interface::DataPrecision value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.LUTParam)
 private:
  inline void set_has_linear_exp_offset();
  inline void clear_has_linear_exp_offset();
  inline void set_has_linear_only_offset();
  inline void clear_has_linear_only_offset();
  inline void set_has_linear_exp_start();
  inline void clear_has_linear_exp_start();
  inline void set_has_linear_exp_end();
  inline void clear_has_linear_exp_end();
  inline void set_has_linear_only_start();
  inline void clear_has_linear_only_start();
  inline void set_has_linear_only_end();
  inline void clear_has_linear_only_end();
  inline void set_has_linear_exp_underflow_slope();
  inline void clear_has_linear_exp_underflow_slope();
  inline void set_has_linear_exp_overflow_slope();
  inline void clear_has_linear_exp_overflow_slope();
  inline void set_has_linear_only_underflow_slope();
  inline void clear_has_linear_only_underflow_slope();
  inline void set_has_linear_only_overflow_slope();
  inline void clear_has_linear_only_overflow_slope();
  inline void set_has_hybrid_priority();
  inline void clear_has_hybrid_priority();
  inline void set_has_underflow_priority();
  inline void clear_has_underflow_priority();
  inline void set_has_overflow_priority();
  inline void clear_has_overflow_priority();
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_fill_type();
  inline void clear_has_fill_type();
  inline void set_has_filler();
  inline void clear_has_filler();
  inline void set_has_precision();
  inline void clear_has_precision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > linear_exp_table_;
  mutable int _linear_exp_table_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > linear_only_table_;
  mutable int _linear_only_table_cached_byte_size_;
  ::nvdla_prototest_interface::LUTOffset* linear_exp_offset_;
  ::nvdla_prototest_interface::LUTOffset* linear_only_offset_;
  ::google::protobuf::uint64 linear_exp_start_;
  ::google::protobuf::uint64 linear_exp_end_;
  ::google::protobuf::uint64 linear_only_start_;
  ::google::protobuf::uint64 linear_only_end_;
  ::nvdla_prototest_interface::DLASlope* linear_exp_underflow_slope_;
  ::nvdla_prototest_interface::DLASlope* linear_exp_overflow_slope_;
  ::nvdla_prototest_interface::DLASlope* linear_only_underflow_slope_;
  ::nvdla_prototest_interface::DLASlope* linear_only_overflow_slope_;
  ::google::protobuf::uint32 hybrid_priority_;
  ::google::protobuf::uint32 underflow_priority_;
  ::google::protobuf::uint32 overflow_priority_;
  int method_;
  ::nvdla_prototest_interface::DataFiller* filler_;
  int fill_type_;
  int precision_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static LUTParam* default_instance_;
};
// -------------------------------------------------------------------

class BDMATransferDesc : public ::google::protobuf::Message {
 public:
  BDMATransferDesc();
  virtual ~BDMATransferDesc();

  BDMATransferDesc(const BDMATransferDesc& from);

  inline BDMATransferDesc& operator=(const BDMATransferDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BDMATransferDesc& default_instance();

  void Swap(BDMATransferDesc* other);

  // implements Message ----------------------------------------------

  BDMATransferDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BDMATransferDesc& from);
  void MergeFrom(const BDMATransferDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 source_address = 1;
  inline bool has_source_address() const;
  inline void clear_source_address();
  static const int kSourceAddressFieldNumber = 1;
  inline ::google::protobuf::int32 source_address() const;
  inline void set_source_address(::google::protobuf::int32 value);

  // required int32 destination_address = 2;
  inline bool has_destination_address() const;
  inline void clear_destination_address();
  static const int kDestinationAddressFieldNumber = 2;
  inline ::google::protobuf::int32 destination_address() const;
  inline void set_destination_address(::google::protobuf::int32 value);

  // required uint32 line_size = 3;
  inline bool has_line_size() const;
  inline void clear_line_size();
  static const int kLineSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 line_size() const;
  inline void set_line_size(::google::protobuf::uint32 value);

  // required uint32 line_repeat = 4;
  inline bool has_line_repeat() const;
  inline void clear_line_repeat();
  static const int kLineRepeatFieldNumber = 4;
  inline ::google::protobuf::uint32 line_repeat() const;
  inline void set_line_repeat(::google::protobuf::uint32 value);

  // required uint32 source_line = 5;
  inline bool has_source_line() const;
  inline void clear_source_line();
  static const int kSourceLineFieldNumber = 5;
  inline ::google::protobuf::uint32 source_line() const;
  inline void set_source_line(::google::protobuf::uint32 value);

  // required uint32 destination_line = 6;
  inline bool has_destination_line() const;
  inline void clear_destination_line();
  static const int kDestinationLineFieldNumber = 6;
  inline ::google::protobuf::uint32 destination_line() const;
  inline void set_destination_line(::google::protobuf::uint32 value);

  // required uint32 surface_repeat = 7;
  inline bool has_surface_repeat() const;
  inline void clear_surface_repeat();
  static const int kSurfaceRepeatFieldNumber = 7;
  inline ::google::protobuf::uint32 surface_repeat() const;
  inline void set_surface_repeat(::google::protobuf::uint32 value);

  // required uint32 source_surface = 8;
  inline bool has_source_surface() const;
  inline void clear_source_surface();
  static const int kSourceSurfaceFieldNumber = 8;
  inline ::google::protobuf::uint32 source_surface() const;
  inline void set_source_surface(::google::protobuf::uint32 value);

  // required uint32 destination_surface = 9;
  inline bool has_destination_surface() const;
  inline void clear_destination_surface();
  static const int kDestinationSurfaceFieldNumber = 9;
  inline ::google::protobuf::uint32 destination_surface() const;
  inline void set_destination_surface(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.MemInfo src_mem_info = 10;
  inline bool has_src_mem_info() const;
  inline void clear_src_mem_info();
  static const int kSrcMemInfoFieldNumber = 10;
  inline const ::nvdla_prototest_interface::MemInfo& src_mem_info() const;
  inline ::nvdla_prototest_interface::MemInfo* mutable_src_mem_info();
  inline ::nvdla_prototest_interface::MemInfo* release_src_mem_info();
  inline void set_allocated_src_mem_info(::nvdla_prototest_interface::MemInfo* src_mem_info);

  // required .nvdla_prototest_interface.MemInfo dst_mem_info = 11;
  inline bool has_dst_mem_info() const;
  inline void clear_dst_mem_info();
  static const int kDstMemInfoFieldNumber = 11;
  inline const ::nvdla_prototest_interface::MemInfo& dst_mem_info() const;
  inline ::nvdla_prototest_interface::MemInfo* mutable_dst_mem_info();
  inline ::nvdla_prototest_interface::MemInfo* release_dst_mem_info();
  inline void set_allocated_dst_mem_info(::nvdla_prototest_interface::MemInfo* dst_mem_info);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.BDMATransferDesc)
 private:
  inline void set_has_source_address();
  inline void clear_has_source_address();
  inline void set_has_destination_address();
  inline void clear_has_destination_address();
  inline void set_has_line_size();
  inline void clear_has_line_size();
  inline void set_has_line_repeat();
  inline void clear_has_line_repeat();
  inline void set_has_source_line();
  inline void clear_has_source_line();
  inline void set_has_destination_line();
  inline void clear_has_destination_line();
  inline void set_has_surface_repeat();
  inline void clear_has_surface_repeat();
  inline void set_has_source_surface();
  inline void clear_has_source_surface();
  inline void set_has_destination_surface();
  inline void clear_has_destination_surface();
  inline void set_has_src_mem_info();
  inline void clear_has_src_mem_info();
  inline void set_has_dst_mem_info();
  inline void clear_has_dst_mem_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 source_address_;
  ::google::protobuf::int32 destination_address_;
  ::google::protobuf::uint32 line_size_;
  ::google::protobuf::uint32 line_repeat_;
  ::google::protobuf::uint32 source_line_;
  ::google::protobuf::uint32 destination_line_;
  ::google::protobuf::uint32 surface_repeat_;
  ::google::protobuf::uint32 source_surface_;
  ::nvdla_prototest_interface::MemInfo* src_mem_info_;
  ::nvdla_prototest_interface::MemInfo* dst_mem_info_;
  ::google::protobuf::uint32 destination_surface_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static BDMATransferDesc* default_instance_;
};
// -------------------------------------------------------------------

class BDMASurfaceDesc : public ::google::protobuf::Message {
 public:
  BDMASurfaceDesc();
  virtual ~BDMASurfaceDesc();

  BDMASurfaceDesc(const BDMASurfaceDesc& from);

  inline BDMASurfaceDesc& operator=(const BDMASurfaceDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BDMASurfaceDesc& default_instance();

  void Swap(BDMASurfaceDesc* other);

  // implements Message ----------------------------------------------

  BDMASurfaceDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BDMASurfaceDesc& from);
  void MergeFrom(const BDMASurfaceDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.MemType source_type = 1;
  inline bool has_source_type() const;
  inline void clear_source_type();
  static const int kSourceTypeFieldNumber = 1;
  inline ::nvdla_prototest_interface::MemType source_type() const;
  inline void set_source_type(::nvdla_prototest_interface::MemType value);

  // required .nvdla_prototest_interface.MemType destination_type = 2;
  inline bool has_destination_type() const;
  inline void clear_destination_type();
  static const int kDestinationTypeFieldNumber = 2;
  inline ::nvdla_prototest_interface::MemType destination_type() const;
  inline void set_destination_type(::nvdla_prototest_interface::MemType value);

  // required uint32 num_transfers = 3;
  inline bool has_num_transfers() const;
  inline void clear_num_transfers();
  static const int kNumTransfersFieldNumber = 3;
  inline ::google::protobuf::uint32 num_transfers() const;
  inline void set_num_transfers(::google::protobuf::uint32 value);

  // repeated .nvdla_prototest_interface.BDMATransferDesc transfers = 4;
  inline int transfers_size() const;
  inline void clear_transfers();
  static const int kTransfersFieldNumber = 4;
  inline const ::nvdla_prototest_interface::BDMATransferDesc& transfers(int index) const;
  inline ::nvdla_prototest_interface::BDMATransferDesc* mutable_transfers(int index);
  inline ::nvdla_prototest_interface::BDMATransferDesc* add_transfers();
  inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::BDMATransferDesc >&
      transfers() const;
  inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::BDMATransferDesc >*
      mutable_transfers();

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.BDMASurfaceDesc)
 private:
  inline void set_has_source_type();
  inline void clear_has_source_type();
  inline void set_has_destination_type();
  inline void clear_has_destination_type();
  inline void set_has_num_transfers();
  inline void clear_has_num_transfers();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int source_type_;
  int destination_type_;
  ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::BDMATransferDesc > transfers_;
  ::google::protobuf::uint32 num_transfers_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static BDMASurfaceDesc* default_instance_;
};
// -------------------------------------------------------------------

class BDMAOpDesc : public ::google::protobuf::Message {
 public:
  BDMAOpDesc();
  virtual ~BDMAOpDesc();

  BDMAOpDesc(const BDMAOpDesc& from);

  inline BDMAOpDesc& operator=(const BDMAOpDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BDMAOpDesc& default_instance();

  void Swap(BDMAOpDesc* other);

  // implements Message ----------------------------------------------

  BDMAOpDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BDMAOpDesc& from);
  void MergeFrom(const BDMAOpDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 num_transfers = 1;
  inline bool has_num_transfers() const;
  inline void clear_num_transfers();
  static const int kNumTransfersFieldNumber = 1;
  inline ::google::protobuf::uint32 num_transfers() const;
  inline void set_num_transfers(::google::protobuf::uint32 value);

  // optional uint32 reserved0 = 2 [default = 0];
  inline bool has_reserved0() const;
  inline void clear_reserved0();
  static const int kReserved0FieldNumber = 2;
  inline ::google::protobuf::uint32 reserved0() const;
  inline void set_reserved0(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.BDMAOpDesc)
 private:
  inline void set_has_num_transfers();
  inline void clear_has_num_transfers();
  inline void set_has_reserved0();
  inline void clear_has_reserved0();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 num_transfers_;
  ::google::protobuf::uint32 reserved0_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static BDMAOpDesc* default_instance_;
};
// -------------------------------------------------------------------

class CVTParam : public ::google::protobuf::Message {
 public:
  CVTParam();
  virtual ~CVTParam();

  CVTParam(const CVTParam& from);

  inline CVTParam& operator=(const CVTParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CVTParam& default_instance();

  void Swap(CVTParam* other);

  // implements Message ----------------------------------------------

  CVTParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CVTParam& from);
  void MergeFrom(const CVTParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 scale = 1;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 1;
  inline ::google::protobuf::int32 scale() const;
  inline void set_scale(::google::protobuf::int32 value);

  // required uint32 truncate = 2;
  inline bool has_truncate() const;
  inline void clear_truncate();
  static const int kTruncateFieldNumber = 2;
  inline ::google::protobuf::uint32 truncate() const;
  inline void set_truncate(::google::protobuf::uint32 value);

  // required uint32 enable = 3;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 3;
  inline ::google::protobuf::uint32 enable() const;
  inline void set_enable(::google::protobuf::uint32 value);

  // required int32 offset = 4;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 4;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.CVTParam)
 private:
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_truncate();
  inline void clear_has_truncate();
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 scale_;
  ::google::protobuf::uint32 truncate_;
  ::google::protobuf::uint32 enable_;
  ::google::protobuf::int32 offset_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static CVTParam* default_instance_;
};
// -------------------------------------------------------------------

class MemInfo : public ::google::protobuf::Message {
 public:
  MemInfo();
  virtual ~MemInfo();

  MemInfo(const MemInfo& from);

  inline MemInfo& operator=(const MemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemInfo& default_instance();

  void Swap(MemInfo* other);

  // implements Message ----------------------------------------------

  MemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemInfo& from);
  void MergeFrom(const MemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mem_id = 1 [default = -1];
  inline bool has_mem_id() const;
  inline void clear_mem_id();
  static const int kMemIdFieldNumber = 1;
  inline ::google::protobuf::int32 mem_id() const;
  inline void set_mem_id(::google::protobuf::int32 value);

  // required uint32 mem_size = 2 [default = 0];
  inline bool has_mem_size() const;
  inline void clear_mem_size();
  static const int kMemSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 mem_size() const;
  inline void set_mem_size(::google::protobuf::uint32 value);

  // required uint32 offset = 3 [default = 0];
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // optional .nvdla_prototest_interface.FillerType fill_type = 4 [default = FILL_NONE];
  inline bool has_fill_type() const;
  inline void clear_fill_type();
  static const int kFillTypeFieldNumber = 4;
  inline ::nvdla_prototest_interface::FillerType fill_type() const;
  inline void set_fill_type(::nvdla_prototest_interface::FillerType value);

  // optional .nvdla_prototest_interface.DataFiller filler = 5;
  inline bool has_filler() const;
  inline void clear_filler();
  static const int kFillerFieldNumber = 5;
  inline const ::nvdla_prototest_interface::DataFiller& filler() const;
  inline ::nvdla_prototest_interface::DataFiller* mutable_filler();
  inline ::nvdla_prototest_interface::DataFiller* release_filler();
  inline void set_allocated_filler(::nvdla_prototest_interface::DataFiller* filler);

  // optional .nvdla_prototest_interface.MemFlag flag = 6 [default = DLA_MEM_ALLOC];
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 6;
  inline ::nvdla_prototest_interface::MemFlag flag() const;
  inline void set_flag(::nvdla_prototest_interface::MemFlag value);

  // optional .nvdla_prototest_interface.DataPrecision precision = 7 [default = PRECISION_INT8];
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 7;
  inline ::nvdla_prototest_interface::DataPrecision precision() const;
  inline void set_precision(::nvdla_prototest_interface::DataPrecision value);

  // optional uint32 sw_dilation_x = 8 [default = 1];
  inline bool has_sw_dilation_x() const;
  inline void clear_sw_dilation_x();
  static const int kSwDilationXFieldNumber = 8;
  inline ::google::protobuf::uint32 sw_dilation_x() const;
  inline void set_sw_dilation_x(::google::protobuf::uint32 value);

  // optional uint32 sw_dilation_y = 9 [default = 1];
  inline bool has_sw_dilation_y() const;
  inline void clear_sw_dilation_y();
  static const int kSwDilationYFieldNumber = 9;
  inline ::google::protobuf::uint32 sw_dilation_y() const;
  inline void set_sw_dilation_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.MemInfo)
 private:
  inline void set_has_mem_id();
  inline void clear_has_mem_id();
  inline void set_has_mem_size();
  inline void clear_has_mem_size();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_fill_type();
  inline void clear_has_fill_type();
  inline void set_has_filler();
  inline void clear_has_filler();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_sw_dilation_x();
  inline void clear_has_sw_dilation_x();
  inline void set_has_sw_dilation_y();
  inline void clear_has_sw_dilation_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 mem_id_;
  ::google::protobuf::uint32 mem_size_;
  ::google::protobuf::uint32 offset_;
  int fill_type_;
  ::nvdla_prototest_interface::DataFiller* filler_;
  int flag_;
  int precision_;
  ::google::protobuf::uint32 sw_dilation_x_;
  ::google::protobuf::uint32 sw_dilation_y_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static MemInfo* default_instance_;
};
// -------------------------------------------------------------------

class DataCube : public ::google::protobuf::Message {
 public:
  DataCube();
  virtual ~DataCube();

  DataCube(const DataCube& from);

  inline DataCube& operator=(const DataCube& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataCube& default_instance();

  void Swap(DataCube* other);

  // implements Message ----------------------------------------------

  DataCube* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataCube& from);
  void MergeFrom(const DataCube& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 reserved0 = 1 [default = 0];
  inline bool has_reserved0() const;
  inline void clear_reserved0();
  static const int kReserved0FieldNumber = 1;
  inline ::google::protobuf::uint32 reserved0() const;
  inline void set_reserved0(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.MemType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::nvdla_prototest_interface::MemType type() const;
  inline void set_type(::nvdla_prototest_interface::MemType value);

  // required int32 address = 3;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 3;
  inline ::google::protobuf::int32 address() const;
  inline void set_address(::google::protobuf::int32 value);

  // required uint32 size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // required uint32 width = 5;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 5;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 6;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 6;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // required uint32 channel = 7;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 7;
  inline ::google::protobuf::uint32 channel() const;
  inline void set_channel(::google::protobuf::uint32 value);

  // optional uint32 reserved1 = 8 [default = 0];
  inline bool has_reserved1() const;
  inline void clear_reserved1();
  static const int kReserved1FieldNumber = 8;
  inline ::google::protobuf::uint32 reserved1() const;
  inline void set_reserved1(::google::protobuf::uint32 value);

  // required uint32 line_stride = 9;
  inline bool has_line_stride() const;
  inline void clear_line_stride();
  static const int kLineStrideFieldNumber = 9;
  inline ::google::protobuf::uint32 line_stride() const;
  inline void set_line_stride(::google::protobuf::uint32 value);

  // required uint32 surf_stride = 10;
  inline bool has_surf_stride() const;
  inline void clear_surf_stride();
  static const int kSurfStrideFieldNumber = 10;
  inline ::google::protobuf::uint32 surf_stride() const;
  inline void set_surf_stride(::google::protobuf::uint32 value);

  // required uint32 plane_stride = 11;
  inline bool has_plane_stride() const;
  inline void clear_plane_stride();
  static const int kPlaneStrideFieldNumber = 11;
  inline ::google::protobuf::uint32 plane_stride() const;
  inline void set_plane_stride(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.MemInfo mem_info = 12;
  inline bool has_mem_info() const;
  inline void clear_mem_info();
  static const int kMemInfoFieldNumber = 12;
  inline const ::nvdla_prototest_interface::MemInfo& mem_info() const;
  inline ::nvdla_prototest_interface::MemInfo* mutable_mem_info();
  inline ::nvdla_prototest_interface::MemInfo* release_mem_info();
  inline void set_allocated_mem_info(::nvdla_prototest_interface::MemInfo* mem_info);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.DataCube)
 private:
  inline void set_has_reserved0();
  inline void clear_has_reserved0();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_reserved1();
  inline void clear_has_reserved1();
  inline void set_has_line_stride();
  inline void clear_has_line_stride();
  inline void set_has_surf_stride();
  inline void clear_has_surf_stride();
  inline void set_has_plane_stride();
  inline void clear_has_plane_stride();
  inline void set_has_mem_info();
  inline void clear_has_mem_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 reserved0_;
  int type_;
  ::google::protobuf::int32 address_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint32 reserved1_;
  ::google::protobuf::uint32 line_stride_;
  ::google::protobuf::uint32 surf_stride_;
  ::nvdla_prototest_interface::MemInfo* mem_info_;
  ::google::protobuf::uint32 plane_stride_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static DataCube* default_instance_;
};
// -------------------------------------------------------------------

class CONVSurfaceDesc : public ::google::protobuf::Message {
 public:
  CONVSurfaceDesc();
  virtual ~CONVSurfaceDesc();

  CONVSurfaceDesc(const CONVSurfaceDesc& from);

  inline CONVSurfaceDesc& operator=(const CONVSurfaceDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CONVSurfaceDesc& default_instance();

  void Swap(CONVSurfaceDesc* other);

  // implements Message ----------------------------------------------

  CONVSurfaceDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CONVSurfaceDesc& from);
  void MergeFrom(const CONVSurfaceDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.DataCube weight_data = 1;
  inline bool has_weight_data() const;
  inline void clear_weight_data();
  static const int kWeightDataFieldNumber = 1;
  inline const ::nvdla_prototest_interface::DataCube& weight_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_weight_data();
  inline ::nvdla_prototest_interface::DataCube* release_weight_data();
  inline void set_allocated_weight_data(::nvdla_prototest_interface::DataCube* weight_data);

  // optional .nvdla_prototest_interface.DataCube wmb_data = 2;
  inline bool has_wmb_data() const;
  inline void clear_wmb_data();
  static const int kWmbDataFieldNumber = 2;
  inline const ::nvdla_prototest_interface::DataCube& wmb_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_wmb_data();
  inline ::nvdla_prototest_interface::DataCube* release_wmb_data();
  inline void set_allocated_wmb_data(::nvdla_prototest_interface::DataCube* wmb_data);

  // optional .nvdla_prototest_interface.DataCube wgs_data = 3;
  inline bool has_wgs_data() const;
  inline void clear_wgs_data();
  static const int kWgsDataFieldNumber = 3;
  inline const ::nvdla_prototest_interface::DataCube& wgs_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_wgs_data();
  inline ::nvdla_prototest_interface::DataCube* release_wgs_data();
  inline void set_allocated_wgs_data(::nvdla_prototest_interface::DataCube* wgs_data);

  // required .nvdla_prototest_interface.DataCube src_data = 4;
  inline bool has_src_data() const;
  inline void clear_src_data();
  static const int kSrcDataFieldNumber = 4;
  inline const ::nvdla_prototest_interface::DataCube& src_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_src_data();
  inline ::nvdla_prototest_interface::DataCube* release_src_data();
  inline void set_allocated_src_data(::nvdla_prototest_interface::DataCube* src_data);

  // required .nvdla_prototest_interface.DataCube dst_data = 5;
  inline bool has_dst_data() const;
  inline void clear_dst_data();
  static const int kDstDataFieldNumber = 5;
  inline const ::nvdla_prototest_interface::DataCube& dst_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_dst_data();
  inline ::nvdla_prototest_interface::DataCube* release_dst_data();
  inline void set_allocated_dst_data(::nvdla_prototest_interface::DataCube* dst_data);

  // required int64 offset_u = 6;
  inline bool has_offset_u() const;
  inline void clear_offset_u();
  static const int kOffsetUFieldNumber = 6;
  inline ::google::protobuf::int64 offset_u() const;
  inline void set_offset_u(::google::protobuf::int64 value);

  // required uint32 in_line_uv_stride = 7;
  inline bool has_in_line_uv_stride() const;
  inline void clear_in_line_uv_stride();
  static const int kInLineUvStrideFieldNumber = 7;
  inline ::google::protobuf::uint32 in_line_uv_stride() const;
  inline void set_in_line_uv_stride(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.CONVSurfaceDesc)
 private:
  inline void set_has_weight_data();
  inline void clear_has_weight_data();
  inline void set_has_wmb_data();
  inline void clear_has_wmb_data();
  inline void set_has_wgs_data();
  inline void clear_has_wgs_data();
  inline void set_has_src_data();
  inline void clear_has_src_data();
  inline void set_has_dst_data();
  inline void clear_has_dst_data();
  inline void set_has_offset_u();
  inline void clear_has_offset_u();
  inline void set_has_in_line_uv_stride();
  inline void clear_has_in_line_uv_stride();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nvdla_prototest_interface::DataCube* weight_data_;
  ::nvdla_prototest_interface::DataCube* wmb_data_;
  ::nvdla_prototest_interface::DataCube* wgs_data_;
  ::nvdla_prototest_interface::DataCube* src_data_;
  ::nvdla_prototest_interface::DataCube* dst_data_;
  ::google::protobuf::int64 offset_u_;
  ::google::protobuf::uint32 in_line_uv_stride_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static CONVSurfaceDesc* default_instance_;
};
// -------------------------------------------------------------------

class CONVOpDesc : public ::google::protobuf::Message {
 public:
  CONVOpDesc();
  virtual ~CONVOpDesc();

  CONVOpDesc(const CONVOpDesc& from);

  inline CONVOpDesc& operator=(const CONVOpDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CONVOpDesc& default_instance();

  void Swap(CONVOpDesc* other);

  // implements Message ----------------------------------------------

  CONVOpDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CONVOpDesc& from);
  void MergeFrom(const CONVOpDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.ConvMode conv_mode = 1;
  inline bool has_conv_mode() const;
  inline void clear_conv_mode();
  static const int kConvModeFieldNumber = 1;
  inline ::nvdla_prototest_interface::ConvMode conv_mode() const;
  inline void set_conv_mode(::nvdla_prototest_interface::ConvMode value);

  // required uint32 data_reuse = 2;
  inline bool has_data_reuse() const;
  inline void clear_data_reuse();
  static const int kDataReuseFieldNumber = 2;
  inline ::google::protobuf::uint32 data_reuse() const;
  inline void set_data_reuse(::google::protobuf::uint32 value);

  // required uint32 weight_reuse = 3;
  inline bool has_weight_reuse() const;
  inline void clear_weight_reuse();
  static const int kWeightReuseFieldNumber = 3;
  inline ::google::protobuf::uint32 weight_reuse() const;
  inline void set_weight_reuse(::google::protobuf::uint32 value);

  // required uint32 skip_data_rls = 4;
  inline bool has_skip_data_rls() const;
  inline void clear_skip_data_rls();
  static const int kSkipDataRlsFieldNumber = 4;
  inline ::google::protobuf::uint32 skip_data_rls() const;
  inline void set_skip_data_rls(::google::protobuf::uint32 value);

  // required uint32 skip_weight_rls = 5;
  inline bool has_skip_weight_rls() const;
  inline void clear_skip_weight_rls();
  static const int kSkipWeightRlsFieldNumber = 5;
  inline ::google::protobuf::uint32 skip_weight_rls() const;
  inline void set_skip_weight_rls(::google::protobuf::uint32 value);

  // optional uint32 reserved0 = 6 [default = 0];
  inline bool has_reserved0() const;
  inline void clear_reserved0();
  static const int kReserved0FieldNumber = 6;
  inline ::google::protobuf::uint32 reserved0() const;
  inline void set_reserved0(::google::protobuf::uint32 value);

  // required uint32 entry_per_slice = 7;
  inline bool has_entry_per_slice() const;
  inline void clear_entry_per_slice();
  static const int kEntryPerSliceFieldNumber = 7;
  inline ::google::protobuf::uint32 entry_per_slice() const;
  inline void set_entry_per_slice(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.DataFormat data_format = 8;
  inline bool has_data_format() const;
  inline void clear_data_format();
  static const int kDataFormatFieldNumber = 8;
  inline ::nvdla_prototest_interface::DataFormat data_format() const;
  inline void set_data_format(::nvdla_prototest_interface::DataFormat value);

  // required uint32 pixel_mapping = 9;
  inline bool has_pixel_mapping() const;
  inline void clear_pixel_mapping();
  static const int kPixelMappingFieldNumber = 9;
  inline ::google::protobuf::uint32 pixel_mapping() const;
  inline void set_pixel_mapping(::google::protobuf::uint32 value);

  // required uint32 fetch_grain = 10;
  inline bool has_fetch_grain() const;
  inline void clear_fetch_grain();
  static const int kFetchGrainFieldNumber = 10;
  inline ::google::protobuf::uint32 fetch_grain() const;
  inline void set_fetch_grain(::google::protobuf::uint32 value);

  // required uint32 pixel_offset_x = 11;
  inline bool has_pixel_offset_x() const;
  inline void clear_pixel_offset_x();
  static const int kPixelOffsetXFieldNumber = 11;
  inline ::google::protobuf::uint32 pixel_offset_x() const;
  inline void set_pixel_offset_x(::google::protobuf::uint32 value);

  // required uint32 pixel_offset_y = 12;
  inline bool has_pixel_offset_y() const;
  inline void clear_pixel_offset_y();
  static const int kPixelOffsetYFieldNumber = 12;
  inline ::google::protobuf::uint32 pixel_offset_y() const;
  inline void set_pixel_offset_y(::google::protobuf::uint32 value);

  // required uint32 gob_per_line = 13;
  inline bool has_gob_per_line() const;
  inline void clear_gob_per_line();
  static const int kGobPerLineFieldNumber = 13;
  inline ::google::protobuf::uint32 gob_per_line() const;
  inline void set_gob_per_line(::google::protobuf::uint32 value);

  // required uint32 gob_height = 14;
  inline bool has_gob_height() const;
  inline void clear_gob_height();
  static const int kGobHeightFieldNumber = 14;
  inline ::google::protobuf::uint32 gob_height() const;
  inline void set_gob_height(::google::protobuf::uint32 value);

  // required uint32 gob_y_index = 15;
  inline bool has_gob_y_index() const;
  inline void clear_gob_y_index();
  static const int kGobYIndexFieldNumber = 15;
  inline ::google::protobuf::uint32 gob_y_index() const;
  inline void set_gob_y_index(::google::protobuf::uint32 value);

  // required uint32 gob_per_uv_line = 16;
  inline bool has_gob_per_uv_line() const;
  inline void clear_gob_per_uv_line();
  static const int kGobPerUvLineFieldNumber = 16;
  inline ::google::protobuf::uint32 gob_per_uv_line() const;
  inline void set_gob_per_uv_line(::google::protobuf::uint32 value);

  // required uint32 batch = 17;
  inline bool has_batch() const;
  inline void clear_batch();
  static const int kBatchFieldNumber = 17;
  inline ::google::protobuf::uint32 batch() const;
  inline void set_batch(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.WeightFormat weight_format = 18;
  inline bool has_weight_format() const;
  inline void clear_weight_format();
  static const int kWeightFormatFieldNumber = 18;
  inline ::nvdla_prototest_interface::WeightFormat weight_format() const;
  inline void set_weight_format(::nvdla_prototest_interface::WeightFormat value);

  // required uint32 data_bank = 19;
  inline bool has_data_bank() const;
  inline void clear_data_bank();
  static const int kDataBankFieldNumber = 19;
  inline ::google::protobuf::uint32 data_bank() const;
  inline void set_data_bank(::google::protobuf::uint32 value);

  // required uint32 weight_bank = 20;
  inline bool has_weight_bank() const;
  inline void clear_weight_bank();
  static const int kWeightBankFieldNumber = 20;
  inline ::google::protobuf::uint32 weight_bank() const;
  inline void set_weight_bank(::google::protobuf::uint32 value);

  // required uint32 batch_stride = 21;
  inline bool has_batch_stride() const;
  inline void clear_batch_stride();
  static const int kBatchStrideFieldNumber = 21;
  inline ::google::protobuf::uint32 batch_stride() const;
  inline void set_batch_stride(::google::protobuf::uint32 value);

  // required uint32 post_extension = 22;
  inline bool has_post_extension() const;
  inline void clear_post_extension();
  static const int kPostExtensionFieldNumber = 22;
  inline ::google::protobuf::uint32 post_extension() const;
  inline void set_post_extension(::google::protobuf::uint32 value);

  // optional .nvdla_prototest_interface.PixelOverride pixel_override = 23;
  inline bool has_pixel_override() const;
  inline void clear_pixel_override();
  static const int kPixelOverrideFieldNumber = 23;
  inline ::nvdla_prototest_interface::PixelOverride pixel_override() const;
  inline void set_pixel_override(::nvdla_prototest_interface::PixelOverride value);

  // required uint32 release = 24;
  inline bool has_release() const;
  inline void clear_release();
  static const int kReleaseFieldNumber = 24;
  inline ::google::protobuf::uint32 release() const;
  inline void set_release(::google::protobuf::uint32 value);

  // required uint32 input_width_csc = 25;
  inline bool has_input_width_csc() const;
  inline void clear_input_width_csc();
  static const int kInputWidthCscFieldNumber = 25;
  inline ::google::protobuf::uint32 input_width_csc() const;
  inline void set_input_width_csc(::google::protobuf::uint32 value);

  // required uint32 input_height_csc = 26;
  inline bool has_input_height_csc() const;
  inline void clear_input_height_csc();
  static const int kInputHeightCscFieldNumber = 26;
  inline ::google::protobuf::uint32 input_height_csc() const;
  inline void set_input_height_csc(::google::protobuf::uint32 value);

  // required uint32 input_channel_csc = 27;
  inline bool has_input_channel_csc() const;
  inline void clear_input_channel_csc();
  static const int kInputChannelCscFieldNumber = 27;
  inline ::google::protobuf::uint32 input_channel_csc() const;
  inline void set_input_channel_csc(::google::protobuf::uint32 value);

  // required uint32 kernel_width_csc = 28;
  inline bool has_kernel_width_csc() const;
  inline void clear_kernel_width_csc();
  static const int kKernelWidthCscFieldNumber = 28;
  inline ::google::protobuf::uint32 kernel_width_csc() const;
  inline void set_kernel_width_csc(::google::protobuf::uint32 value);

  // required uint32 kernel_height_csc = 29;
  inline bool has_kernel_height_csc() const;
  inline void clear_kernel_height_csc();
  static const int kKernelHeightCscFieldNumber = 29;
  inline ::google::protobuf::uint32 kernel_height_csc() const;
  inline void set_kernel_height_csc(::google::protobuf::uint32 value);

  // required uint32 kernel_channel_csc = 30;
  inline bool has_kernel_channel_csc() const;
  inline void clear_kernel_channel_csc();
  static const int kKernelChannelCscFieldNumber = 30;
  inline ::google::protobuf::uint32 kernel_channel_csc() const;
  inline void set_kernel_channel_csc(::google::protobuf::uint32 value);

  // required uint32 input_width_cmac = 31;
  inline bool has_input_width_cmac() const;
  inline void clear_input_width_cmac();
  static const int kInputWidthCmacFieldNumber = 31;
  inline ::google::protobuf::uint32 input_width_cmac() const;
  inline void set_input_width_cmac(::google::protobuf::uint32 value);

  // required uint32 input_height_cmac = 32;
  inline bool has_input_height_cmac() const;
  inline void clear_input_height_cmac();
  static const int kInputHeightCmacFieldNumber = 32;
  inline ::google::protobuf::uint32 input_height_cmac() const;
  inline void set_input_height_cmac(::google::protobuf::uint32 value);

  // required uint32 bytes_per_kernel = 33;
  inline bool has_bytes_per_kernel() const;
  inline void clear_bytes_per_kernel();
  static const int kBytesPerKernelFieldNumber = 33;
  inline ::google::protobuf::uint32 bytes_per_kernel() const;
  inline void set_bytes_per_kernel(::google::protobuf::uint32 value);

  // required int32 mean_ry = 34;
  inline bool has_mean_ry() const;
  inline void clear_mean_ry();
  static const int kMeanRyFieldNumber = 34;
  inline ::google::protobuf::int32 mean_ry() const;
  inline void set_mean_ry(::google::protobuf::int32 value);

  // required int32 mean_gu = 35;
  inline bool has_mean_gu() const;
  inline void clear_mean_gu();
  static const int kMeanGuFieldNumber = 35;
  inline ::google::protobuf::int32 mean_gu() const;
  inline void set_mean_gu(::google::protobuf::int32 value);

  // required int32 mean_bv = 36;
  inline bool has_mean_bv() const;
  inline void clear_mean_bv();
  static const int kMeanBvFieldNumber = 36;
  inline ::google::protobuf::int32 mean_bv() const;
  inline void set_mean_bv(::google::protobuf::int32 value);

  // required int32 mean_ax = 37;
  inline bool has_mean_ax() const;
  inline void clear_mean_ax();
  static const int kMeanAxFieldNumber = 37;
  inline ::google::protobuf::int32 mean_ax() const;
  inline void set_mean_ax(::google::protobuf::int32 value);

  // required .nvdla_prototest_interface.MeanFormat mean_format = 38;
  inline bool has_mean_format() const;
  inline void clear_mean_format();
  static const int kMeanFormatFieldNumber = 38;
  inline ::nvdla_prototest_interface::MeanFormat mean_format() const;
  inline void set_mean_format(::nvdla_prototest_interface::MeanFormat value);

  // required uint32 conv_stride_x = 39;
  inline bool has_conv_stride_x() const;
  inline void clear_conv_stride_x();
  static const int kConvStrideXFieldNumber = 39;
  inline ::google::protobuf::uint32 conv_stride_x() const;
  inline void set_conv_stride_x(::google::protobuf::uint32 value);

  // required uint32 conv_stride_y = 40;
  inline bool has_conv_stride_y() const;
  inline void clear_conv_stride_y();
  static const int kConvStrideYFieldNumber = 40;
  inline ::google::protobuf::uint32 conv_stride_y() const;
  inline void set_conv_stride_y(::google::protobuf::uint32 value);

  // required uint32 pad_x_left = 41;
  inline bool has_pad_x_left() const;
  inline void clear_pad_x_left();
  static const int kPadXLeftFieldNumber = 41;
  inline ::google::protobuf::uint32 pad_x_left() const;
  inline void set_pad_x_left(::google::protobuf::uint32 value);

  // required uint32 pad_x_right = 42;
  inline bool has_pad_x_right() const;
  inline void clear_pad_x_right();
  static const int kPadXRightFieldNumber = 42;
  inline ::google::protobuf::uint32 pad_x_right() const;
  inline void set_pad_x_right(::google::protobuf::uint32 value);

  // required uint32 pad_y_top = 43;
  inline bool has_pad_y_top() const;
  inline void clear_pad_y_top();
  static const int kPadYTopFieldNumber = 43;
  inline ::google::protobuf::uint32 pad_y_top() const;
  inline void set_pad_y_top(::google::protobuf::uint32 value);

  // required uint32 pad_y_bottom = 44;
  inline bool has_pad_y_bottom() const;
  inline void clear_pad_y_bottom();
  static const int kPadYBottomFieldNumber = 44;
  inline ::google::protobuf::uint32 pad_y_bottom() const;
  inline void set_pad_y_bottom(::google::protobuf::uint32 value);

  // required uint32 dilation_x = 45;
  inline bool has_dilation_x() const;
  inline void clear_dilation_x();
  static const int kDilationXFieldNumber = 45;
  inline ::google::protobuf::uint32 dilation_x() const;
  inline void set_dilation_x(::google::protobuf::uint32 value);

  // required uint32 dilation_y = 46;
  inline bool has_dilation_y() const;
  inline void clear_dilation_y();
  static const int kDilationYFieldNumber = 46;
  inline ::google::protobuf::uint32 dilation_y() const;
  inline void set_dilation_y(::google::protobuf::uint32 value);

  // repeated uint32 reserved2 = 47 [packed = true];
  inline int reserved2_size() const;
  inline void clear_reserved2();
  static const int kReserved2FieldNumber = 47;
  inline ::google::protobuf::uint32 reserved2(int index) const;
  inline void set_reserved2(int index, ::google::protobuf::uint32 value);
  inline void add_reserved2(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      reserved2() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_reserved2();

  // required uint32 pra_truncate = 48;
  inline bool has_pra_truncate() const;
  inline void clear_pra_truncate();
  static const int kPraTruncateFieldNumber = 48;
  inline ::google::protobuf::uint32 pra_truncate() const;
  inline void set_pra_truncate(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.DataPrecision in_precision = 49;
  inline bool has_in_precision() const;
  inline void clear_in_precision();
  static const int kInPrecisionFieldNumber = 49;
  inline ::nvdla_prototest_interface::DataPrecision in_precision() const;
  inline void set_in_precision(::nvdla_prototest_interface::DataPrecision value);

  // required .nvdla_prototest_interface.DataPrecision out_precision = 50;
  inline bool has_out_precision() const;
  inline void clear_out_precision();
  static const int kOutPrecisionFieldNumber = 50;
  inline ::nvdla_prototest_interface::DataPrecision out_precision() const;
  inline void set_out_precision(::nvdla_prototest_interface::DataPrecision value);

  // required int32 pad_val = 51;
  inline bool has_pad_val() const;
  inline void clear_pad_val();
  static const int kPadValFieldNumber = 51;
  inline ::google::protobuf::int32 pad_val() const;
  inline void set_pad_val(::google::protobuf::int32 value);

  // required .nvdla_prototest_interface.CVTParam in_cvt = 52;
  inline bool has_in_cvt() const;
  inline void clear_in_cvt();
  static const int kInCvtFieldNumber = 52;
  inline const ::nvdla_prototest_interface::CVTParam& in_cvt() const;
  inline ::nvdla_prototest_interface::CVTParam* mutable_in_cvt();
  inline ::nvdla_prototest_interface::CVTParam* release_in_cvt();
  inline void set_allocated_in_cvt(::nvdla_prototest_interface::CVTParam* in_cvt);

  // required .nvdla_prototest_interface.CVTParam out_cvt = 53;
  inline bool has_out_cvt() const;
  inline void clear_out_cvt();
  static const int kOutCvtFieldNumber = 53;
  inline const ::nvdla_prototest_interface::CVTParam& out_cvt() const;
  inline ::nvdla_prototest_interface::CVTParam* mutable_out_cvt();
  inline ::nvdla_prototest_interface::CVTParam* release_out_cvt();
  inline void set_allocated_out_cvt(::nvdla_prototest_interface::CVTParam* out_cvt);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.CONVOpDesc)
 private:
  inline void set_has_conv_mode();
  inline void clear_has_conv_mode();
  inline void set_has_data_reuse();
  inline void clear_has_data_reuse();
  inline void set_has_weight_reuse();
  inline void clear_has_weight_reuse();
  inline void set_has_skip_data_rls();
  inline void clear_has_skip_data_rls();
  inline void set_has_skip_weight_rls();
  inline void clear_has_skip_weight_rls();
  inline void set_has_reserved0();
  inline void clear_has_reserved0();
  inline void set_has_entry_per_slice();
  inline void clear_has_entry_per_slice();
  inline void set_has_data_format();
  inline void clear_has_data_format();
  inline void set_has_pixel_mapping();
  inline void clear_has_pixel_mapping();
  inline void set_has_fetch_grain();
  inline void clear_has_fetch_grain();
  inline void set_has_pixel_offset_x();
  inline void clear_has_pixel_offset_x();
  inline void set_has_pixel_offset_y();
  inline void clear_has_pixel_offset_y();
  inline void set_has_gob_per_line();
  inline void clear_has_gob_per_line();
  inline void set_has_gob_height();
  inline void clear_has_gob_height();
  inline void set_has_gob_y_index();
  inline void clear_has_gob_y_index();
  inline void set_has_gob_per_uv_line();
  inline void clear_has_gob_per_uv_line();
  inline void set_has_batch();
  inline void clear_has_batch();
  inline void set_has_weight_format();
  inline void clear_has_weight_format();
  inline void set_has_data_bank();
  inline void clear_has_data_bank();
  inline void set_has_weight_bank();
  inline void clear_has_weight_bank();
  inline void set_has_batch_stride();
  inline void clear_has_batch_stride();
  inline void set_has_post_extension();
  inline void clear_has_post_extension();
  inline void set_has_pixel_override();
  inline void clear_has_pixel_override();
  inline void set_has_release();
  inline void clear_has_release();
  inline void set_has_input_width_csc();
  inline void clear_has_input_width_csc();
  inline void set_has_input_height_csc();
  inline void clear_has_input_height_csc();
  inline void set_has_input_channel_csc();
  inline void clear_has_input_channel_csc();
  inline void set_has_kernel_width_csc();
  inline void clear_has_kernel_width_csc();
  inline void set_has_kernel_height_csc();
  inline void clear_has_kernel_height_csc();
  inline void set_has_kernel_channel_csc();
  inline void clear_has_kernel_channel_csc();
  inline void set_has_input_width_cmac();
  inline void clear_has_input_width_cmac();
  inline void set_has_input_height_cmac();
  inline void clear_has_input_height_cmac();
  inline void set_has_bytes_per_kernel();
  inline void clear_has_bytes_per_kernel();
  inline void set_has_mean_ry();
  inline void clear_has_mean_ry();
  inline void set_has_mean_gu();
  inline void clear_has_mean_gu();
  inline void set_has_mean_bv();
  inline void clear_has_mean_bv();
  inline void set_has_mean_ax();
  inline void clear_has_mean_ax();
  inline void set_has_mean_format();
  inline void clear_has_mean_format();
  inline void set_has_conv_stride_x();
  inline void clear_has_conv_stride_x();
  inline void set_has_conv_stride_y();
  inline void clear_has_conv_stride_y();
  inline void set_has_pad_x_left();
  inline void clear_has_pad_x_left();
  inline void set_has_pad_x_right();
  inline void clear_has_pad_x_right();
  inline void set_has_pad_y_top();
  inline void clear_has_pad_y_top();
  inline void set_has_pad_y_bottom();
  inline void clear_has_pad_y_bottom();
  inline void set_has_dilation_x();
  inline void clear_has_dilation_x();
  inline void set_has_dilation_y();
  inline void clear_has_dilation_y();
  inline void set_has_pra_truncate();
  inline void clear_has_pra_truncate();
  inline void set_has_in_precision();
  inline void clear_has_in_precision();
  inline void set_has_out_precision();
  inline void clear_has_out_precision();
  inline void set_has_pad_val();
  inline void clear_has_pad_val();
  inline void set_has_in_cvt();
  inline void clear_has_in_cvt();
  inline void set_has_out_cvt();
  inline void clear_has_out_cvt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  int conv_mode_;
  ::google::protobuf::uint32 data_reuse_;
  ::google::protobuf::uint32 weight_reuse_;
  ::google::protobuf::uint32 skip_data_rls_;
  ::google::protobuf::uint32 skip_weight_rls_;
  ::google::protobuf::uint32 reserved0_;
  ::google::protobuf::uint32 entry_per_slice_;
  int data_format_;
  ::google::protobuf::uint32 pixel_mapping_;
  ::google::protobuf::uint32 fetch_grain_;
  ::google::protobuf::uint32 pixel_offset_x_;
  ::google::protobuf::uint32 pixel_offset_y_;
  ::google::protobuf::uint32 gob_per_line_;
  ::google::protobuf::uint32 gob_height_;
  ::google::protobuf::uint32 gob_y_index_;
  ::google::protobuf::uint32 gob_per_uv_line_;
  ::google::protobuf::uint32 batch_;
  int weight_format_;
  ::google::protobuf::uint32 data_bank_;
  ::google::protobuf::uint32 weight_bank_;
  ::google::protobuf::uint32 batch_stride_;
  ::google::protobuf::uint32 post_extension_;
  int pixel_override_;
  ::google::protobuf::uint32 release_;
  ::google::protobuf::uint32 input_width_csc_;
  ::google::protobuf::uint32 input_height_csc_;
  ::google::protobuf::uint32 input_channel_csc_;
  ::google::protobuf::uint32 kernel_width_csc_;
  ::google::protobuf::uint32 kernel_height_csc_;
  ::google::protobuf::uint32 kernel_channel_csc_;
  ::google::protobuf::uint32 input_width_cmac_;
  ::google::protobuf::uint32 input_height_cmac_;
  ::google::protobuf::uint32 bytes_per_kernel_;
  ::google::protobuf::int32 mean_ry_;
  ::google::protobuf::int32 mean_gu_;
  ::google::protobuf::int32 mean_bv_;
  ::google::protobuf::int32 mean_ax_;
  int mean_format_;
  ::google::protobuf::uint32 conv_stride_x_;
  ::google::protobuf::uint32 conv_stride_y_;
  ::google::protobuf::uint32 pad_x_left_;
  ::google::protobuf::uint32 pad_x_right_;
  ::google::protobuf::uint32 pad_y_top_;
  ::google::protobuf::uint32 pad_y_bottom_;
  ::google::protobuf::uint32 dilation_x_;
  ::google::protobuf::uint32 dilation_y_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > reserved2_;
  mutable int _reserved2_cached_byte_size_;
  ::google::protobuf::uint32 pra_truncate_;
  int in_precision_;
  int out_precision_;
  ::google::protobuf::int32 pad_val_;
  ::nvdla_prototest_interface::CVTParam* in_cvt_;
  ::nvdla_prototest_interface::CVTParam* out_cvt_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static CONVOpDesc* default_instance_;
};
// -------------------------------------------------------------------

class SDPCvt : public ::google::protobuf::Message {
 public:
  SDPCvt();
  virtual ~SDPCvt();

  SDPCvt(const SDPCvt& from);

  inline SDPCvt& operator=(const SDPCvt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SDPCvt& default_instance();

  void Swap(SDPCvt* other);

  // implements Message ----------------------------------------------

  SDPCvt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SDPCvt& from);
  void MergeFrom(const SDPCvt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.CVTParam alu_cvt = 1;
  inline bool has_alu_cvt() const;
  inline void clear_alu_cvt();
  static const int kAluCvtFieldNumber = 1;
  inline const ::nvdla_prototest_interface::CVTParam& alu_cvt() const;
  inline ::nvdla_prototest_interface::CVTParam* mutable_alu_cvt();
  inline ::nvdla_prototest_interface::CVTParam* release_alu_cvt();
  inline void set_allocated_alu_cvt(::nvdla_prototest_interface::CVTParam* alu_cvt);

  // required .nvdla_prototest_interface.CVTParam mul_cvt = 2;
  inline bool has_mul_cvt() const;
  inline void clear_mul_cvt();
  static const int kMulCvtFieldNumber = 2;
  inline const ::nvdla_prototest_interface::CVTParam& mul_cvt() const;
  inline ::nvdla_prototest_interface::CVTParam* mutable_mul_cvt();
  inline ::nvdla_prototest_interface::CVTParam* release_mul_cvt();
  inline void set_allocated_mul_cvt(::nvdla_prototest_interface::CVTParam* mul_cvt);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.SDPCvt)
 private:
  inline void set_has_alu_cvt();
  inline void clear_has_alu_cvt();
  inline void set_has_mul_cvt();
  inline void clear_has_mul_cvt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nvdla_prototest_interface::CVTParam* alu_cvt_;
  ::nvdla_prototest_interface::CVTParam* mul_cvt_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static SDPCvt* default_instance_;
};
// -------------------------------------------------------------------

class SDPOp : public ::google::protobuf::Message {
 public:
  SDPOp();
  virtual ~SDPOp();

  SDPOp(const SDPOp& from);

  inline SDPOp& operator=(const SDPOp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SDPOp& default_instance();

  void Swap(SDPOp* other);

  // implements Message ----------------------------------------------

  SDPOp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SDPOp& from);
  void MergeFrom(const SDPOp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SDPOp_SDPOpMode SDPOpMode;
  static const SDPOpMode SDP_OP_PER_LAYER = SDPOp_SDPOpMode_SDP_OP_PER_LAYER;
  static const SDPOpMode SDP_OP_PER_KERNEL = SDPOp_SDPOpMode_SDP_OP_PER_KERNEL;
  static const SDPOpMode SDP_OP_PER_POINT = SDPOp_SDPOpMode_SDP_OP_PER_POINT;
  static inline bool SDPOpMode_IsValid(int value) {
    return SDPOp_SDPOpMode_IsValid(value);
  }
  static const SDPOpMode SDPOpMode_MIN =
    SDPOp_SDPOpMode_SDPOpMode_MIN;
  static const SDPOpMode SDPOpMode_MAX =
    SDPOp_SDPOpMode_SDPOpMode_MAX;
  static const int SDPOpMode_ARRAYSIZE =
    SDPOp_SDPOpMode_SDPOpMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SDPOpMode_descriptor() {
    return SDPOp_SDPOpMode_descriptor();
  }
  static inline const ::std::string& SDPOpMode_Name(SDPOpMode value) {
    return SDPOp_SDPOpMode_Name(value);
  }
  static inline bool SDPOpMode_Parse(const ::std::string& name,
      SDPOpMode* value) {
    return SDPOp_SDPOpMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 enable = 1;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 1;
  inline ::google::protobuf::uint32 enable() const;
  inline void set_enable(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.ALUType alu_type = 2;
  inline bool has_alu_type() const;
  inline void clear_alu_type();
  static const int kAluTypeFieldNumber = 2;
  inline ::nvdla_prototest_interface::ALUType alu_type() const;
  inline void set_alu_type(::nvdla_prototest_interface::ALUType value);

  // required .nvdla_prototest_interface.SDPOpType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::nvdla_prototest_interface::SDPOpType type() const;
  inline void set_type(::nvdla_prototest_interface::SDPOpType value);

  // required .nvdla_prototest_interface.SDPOp.SDPOpMode mode = 4;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 4;
  inline ::nvdla_prototest_interface::SDPOp_SDPOpMode mode() const;
  inline void set_mode(::nvdla_prototest_interface::SDPOp_SDPOpMode value);

  // required .nvdla_prototest_interface.SDPActivation act = 5;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 5;
  inline ::nvdla_prototest_interface::SDPActivation act() const;
  inline void set_act(::nvdla_prototest_interface::SDPActivation value);

  // required uint32 shift_value = 6;
  inline bool has_shift_value() const;
  inline void clear_shift_value();
  static const int kShiftValueFieldNumber = 6;
  inline ::google::protobuf::uint32 shift_value() const;
  inline void set_shift_value(::google::protobuf::uint32 value);

  // required uint32 truncate = 7;
  inline bool has_truncate() const;
  inline void clear_truncate();
  static const int kTruncateFieldNumber = 7;
  inline ::google::protobuf::uint32 truncate() const;
  inline void set_truncate(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.DataPrecision precision = 8;
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 8;
  inline ::nvdla_prototest_interface::DataPrecision precision() const;
  inline void set_precision(::nvdla_prototest_interface::DataPrecision value);

  // required int32 alu_operand = 9;
  inline bool has_alu_operand() const;
  inline void clear_alu_operand();
  static const int kAluOperandFieldNumber = 9;
  inline ::google::protobuf::int32 alu_operand() const;
  inline void set_alu_operand(::google::protobuf::int32 value);

  // required int32 mul_operand = 10;
  inline bool has_mul_operand() const;
  inline void clear_mul_operand();
  static const int kMulOperandFieldNumber = 10;
  inline ::google::protobuf::int32 mul_operand() const;
  inline void set_mul_operand(::google::protobuf::int32 value);

  // required .nvdla_prototest_interface.SDPCvt cvt = 11;
  inline bool has_cvt() const;
  inline void clear_cvt();
  static const int kCvtFieldNumber = 11;
  inline const ::nvdla_prototest_interface::SDPCvt& cvt() const;
  inline ::nvdla_prototest_interface::SDPCvt* mutable_cvt();
  inline ::nvdla_prototest_interface::SDPCvt* release_cvt();
  inline void set_allocated_cvt(::nvdla_prototest_interface::SDPCvt* cvt);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.SDPOp)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_alu_type();
  inline void clear_has_alu_type();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_act();
  inline void clear_has_act();
  inline void set_has_shift_value();
  inline void clear_has_shift_value();
  inline void set_has_truncate();
  inline void clear_has_truncate();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_alu_operand();
  inline void clear_has_alu_operand();
  inline void set_has_mul_operand();
  inline void clear_has_mul_operand();
  inline void set_has_cvt();
  inline void clear_has_cvt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 enable_;
  int alu_type_;
  int type_;
  int mode_;
  int act_;
  ::google::protobuf::uint32 shift_value_;
  ::google::protobuf::uint32 truncate_;
  int precision_;
  ::google::protobuf::int32 alu_operand_;
  ::google::protobuf::int32 mul_operand_;
  ::nvdla_prototest_interface::SDPCvt* cvt_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static SDPOp* default_instance_;
};
// -------------------------------------------------------------------

class SDPSurfaceDesc : public ::google::protobuf::Message {
 public:
  SDPSurfaceDesc();
  virtual ~SDPSurfaceDesc();

  SDPSurfaceDesc(const SDPSurfaceDesc& from);

  inline SDPSurfaceDesc& operator=(const SDPSurfaceDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SDPSurfaceDesc& default_instance();

  void Swap(SDPSurfaceDesc* other);

  // implements Message ----------------------------------------------

  SDPSurfaceDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SDPSurfaceDesc& from);
  void MergeFrom(const SDPSurfaceDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.DataCube src_data = 1;
  inline bool has_src_data() const;
  inline void clear_src_data();
  static const int kSrcDataFieldNumber = 1;
  inline const ::nvdla_prototest_interface::DataCube& src_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_src_data();
  inline ::nvdla_prototest_interface::DataCube* release_src_data();
  inline void set_allocated_src_data(::nvdla_prototest_interface::DataCube* src_data);

  // optional .nvdla_prototest_interface.DataCube x1_data = 2;
  inline bool has_x1_data() const;
  inline void clear_x1_data();
  static const int kX1DataFieldNumber = 2;
  inline const ::nvdla_prototest_interface::DataCube& x1_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_x1_data();
  inline ::nvdla_prototest_interface::DataCube* release_x1_data();
  inline void set_allocated_x1_data(::nvdla_prototest_interface::DataCube* x1_data);

  // optional .nvdla_prototest_interface.DataCube x2_data = 3;
  inline bool has_x2_data() const;
  inline void clear_x2_data();
  static const int kX2DataFieldNumber = 3;
  inline const ::nvdla_prototest_interface::DataCube& x2_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_x2_data();
  inline ::nvdla_prototest_interface::DataCube* release_x2_data();
  inline void set_allocated_x2_data(::nvdla_prototest_interface::DataCube* x2_data);

  // optional .nvdla_prototest_interface.DataCube y_data = 4;
  inline bool has_y_data() const;
  inline void clear_y_data();
  static const int kYDataFieldNumber = 4;
  inline const ::nvdla_prototest_interface::DataCube& y_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_y_data();
  inline ::nvdla_prototest_interface::DataCube* release_y_data();
  inline void set_allocated_y_data(::nvdla_prototest_interface::DataCube* y_data);

  // required .nvdla_prototest_interface.DataCube dst_data = 5;
  inline bool has_dst_data() const;
  inline void clear_dst_data();
  static const int kDstDataFieldNumber = 5;
  inline const ::nvdla_prototest_interface::DataCube& dst_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_dst_data();
  inline ::nvdla_prototest_interface::DataCube* release_dst_data();
  inline void set_allocated_dst_data(::nvdla_prototest_interface::DataCube* dst_data);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.SDPSurfaceDesc)
 private:
  inline void set_has_src_data();
  inline void clear_has_src_data();
  inline void set_has_x1_data();
  inline void clear_has_x1_data();
  inline void set_has_x2_data();
  inline void clear_has_x2_data();
  inline void set_has_y_data();
  inline void clear_has_y_data();
  inline void set_has_dst_data();
  inline void clear_has_dst_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nvdla_prototest_interface::DataCube* src_data_;
  ::nvdla_prototest_interface::DataCube* x1_data_;
  ::nvdla_prototest_interface::DataCube* x2_data_;
  ::nvdla_prototest_interface::DataCube* y_data_;
  ::nvdla_prototest_interface::DataCube* dst_data_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static SDPSurfaceDesc* default_instance_;
};
// -------------------------------------------------------------------

class SDPOpDesc : public ::google::protobuf::Message {
 public:
  SDPOpDesc();
  virtual ~SDPOpDesc();

  SDPOpDesc(const SDPOpDesc& from);

  inline SDPOpDesc& operator=(const SDPOpDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SDPOpDesc& default_instance();

  void Swap(SDPOpDesc* other);

  // implements Message ----------------------------------------------

  SDPOpDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SDPOpDesc& from);
  void MergeFrom(const SDPOpDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.DataPrecision src_precision = 1;
  inline bool has_src_precision() const;
  inline void clear_src_precision();
  static const int kSrcPrecisionFieldNumber = 1;
  inline ::nvdla_prototest_interface::DataPrecision src_precision() const;
  inline void set_src_precision(::nvdla_prototest_interface::DataPrecision value);

  // required .nvdla_prototest_interface.DataPrecision dst_precision = 2;
  inline bool has_dst_precision() const;
  inline void clear_dst_precision();
  static const int kDstPrecisionFieldNumber = 2;
  inline ::nvdla_prototest_interface::DataPrecision dst_precision() const;
  inline void set_dst_precision(::nvdla_prototest_interface::DataPrecision value);

  // required int32 lut_index = 3;
  inline bool has_lut_index() const;
  inline void clear_lut_index();
  static const int kLutIndexFieldNumber = 3;
  inline ::google::protobuf::int32 lut_index() const;
  inline void set_lut_index(::google::protobuf::int32 value);

  // required .nvdla_prototest_interface.CVTParam out_cvt = 4;
  inline bool has_out_cvt() const;
  inline void clear_out_cvt();
  static const int kOutCvtFieldNumber = 4;
  inline const ::nvdla_prototest_interface::CVTParam& out_cvt() const;
  inline ::nvdla_prototest_interface::CVTParam* mutable_out_cvt();
  inline ::nvdla_prototest_interface::CVTParam* release_out_cvt();
  inline void set_allocated_out_cvt(::nvdla_prototest_interface::CVTParam* out_cvt);

  // required .nvdla_prototest_interface.ConvMode conv_mode = 5;
  inline bool has_conv_mode() const;
  inline void clear_conv_mode();
  static const int kConvModeFieldNumber = 5;
  inline ::nvdla_prototest_interface::ConvMode conv_mode() const;
  inline void set_conv_mode(::nvdla_prototest_interface::ConvMode value);

  // required uint32 batch_num = 6;
  inline bool has_batch_num() const;
  inline void clear_batch_num();
  static const int kBatchNumFieldNumber = 6;
  inline ::google::protobuf::uint32 batch_num() const;
  inline void set_batch_num(::google::protobuf::uint32 value);

  // optional uint32 reserved0 = 7 [default = 0];
  inline bool has_reserved0() const;
  inline void clear_reserved0();
  static const int kReserved0FieldNumber = 7;
  inline ::google::protobuf::uint32 reserved0() const;
  inline void set_reserved0(::google::protobuf::uint32 value);

  // required uint32 batch_stride = 8;
  inline bool has_batch_stride() const;
  inline void clear_batch_stride();
  static const int kBatchStrideFieldNumber = 8;
  inline ::google::protobuf::uint32 batch_stride() const;
  inline void set_batch_stride(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.SDPOp x1_op = 9;
  inline bool has_x1_op() const;
  inline void clear_x1_op();
  static const int kX1OpFieldNumber = 9;
  inline const ::nvdla_prototest_interface::SDPOp& x1_op() const;
  inline ::nvdla_prototest_interface::SDPOp* mutable_x1_op();
  inline ::nvdla_prototest_interface::SDPOp* release_x1_op();
  inline void set_allocated_x1_op(::nvdla_prototest_interface::SDPOp* x1_op);

  // required .nvdla_prototest_interface.SDPOp x2_op = 10;
  inline bool has_x2_op() const;
  inline void clear_x2_op();
  static const int kX2OpFieldNumber = 10;
  inline const ::nvdla_prototest_interface::SDPOp& x2_op() const;
  inline ::nvdla_prototest_interface::SDPOp* mutable_x2_op();
  inline ::nvdla_prototest_interface::SDPOp* release_x2_op();
  inline void set_allocated_x2_op(::nvdla_prototest_interface::SDPOp* x2_op);

  // required .nvdla_prototest_interface.SDPOp y_op = 11;
  inline bool has_y_op() const;
  inline void clear_y_op();
  static const int kYOpFieldNumber = 11;
  inline const ::nvdla_prototest_interface::SDPOp& y_op() const;
  inline ::nvdla_prototest_interface::SDPOp* mutable_y_op();
  inline ::nvdla_prototest_interface::SDPOp* release_y_op();
  inline void set_allocated_y_op(::nvdla_prototest_interface::SDPOp* y_op);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.SDPOpDesc)
 private:
  inline void set_has_src_precision();
  inline void clear_has_src_precision();
  inline void set_has_dst_precision();
  inline void clear_has_dst_precision();
  inline void set_has_lut_index();
  inline void clear_has_lut_index();
  inline void set_has_out_cvt();
  inline void clear_has_out_cvt();
  inline void set_has_conv_mode();
  inline void clear_has_conv_mode();
  inline void set_has_batch_num();
  inline void clear_has_batch_num();
  inline void set_has_reserved0();
  inline void clear_has_reserved0();
  inline void set_has_batch_stride();
  inline void clear_has_batch_stride();
  inline void set_has_x1_op();
  inline void clear_has_x1_op();
  inline void set_has_x2_op();
  inline void clear_has_x2_op();
  inline void set_has_y_op();
  inline void clear_has_y_op();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int src_precision_;
  int dst_precision_;
  ::nvdla_prototest_interface::CVTParam* out_cvt_;
  ::google::protobuf::int32 lut_index_;
  int conv_mode_;
  ::google::protobuf::uint32 batch_num_;
  ::google::protobuf::uint32 reserved0_;
  ::nvdla_prototest_interface::SDPOp* x1_op_;
  ::nvdla_prototest_interface::SDPOp* x2_op_;
  ::nvdla_prototest_interface::SDPOp* y_op_;
  ::google::protobuf::uint32 batch_stride_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static SDPOpDesc* default_instance_;
};
// -------------------------------------------------------------------

class PDPSurfaceDesc : public ::google::protobuf::Message {
 public:
  PDPSurfaceDesc();
  virtual ~PDPSurfaceDesc();

  PDPSurfaceDesc(const PDPSurfaceDesc& from);

  inline PDPSurfaceDesc& operator=(const PDPSurfaceDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PDPSurfaceDesc& default_instance();

  void Swap(PDPSurfaceDesc* other);

  // implements Message ----------------------------------------------

  PDPSurfaceDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PDPSurfaceDesc& from);
  void MergeFrom(const PDPSurfaceDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.DataCube src_data = 1;
  inline bool has_src_data() const;
  inline void clear_src_data();
  static const int kSrcDataFieldNumber = 1;
  inline const ::nvdla_prototest_interface::DataCube& src_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_src_data();
  inline ::nvdla_prototest_interface::DataCube* release_src_data();
  inline void set_allocated_src_data(::nvdla_prototest_interface::DataCube* src_data);

  // required .nvdla_prototest_interface.DataCube dst_data = 2;
  inline bool has_dst_data() const;
  inline void clear_dst_data();
  static const int kDstDataFieldNumber = 2;
  inline const ::nvdla_prototest_interface::DataCube& dst_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_dst_data();
  inline ::nvdla_prototest_interface::DataCube* release_dst_data();
  inline void set_allocated_dst_data(::nvdla_prototest_interface::DataCube* dst_data);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.PDPSurfaceDesc)
 private:
  inline void set_has_src_data();
  inline void clear_has_src_data();
  inline void set_has_dst_data();
  inline void clear_has_dst_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nvdla_prototest_interface::DataCube* src_data_;
  ::nvdla_prototest_interface::DataCube* dst_data_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static PDPSurfaceDesc* default_instance_;
};
// -------------------------------------------------------------------

class PDPOpDesc : public ::google::protobuf::Message {
 public:
  PDPOpDesc();
  virtual ~PDPOpDesc();

  PDPOpDesc(const PDPOpDesc& from);

  inline PDPOpDesc& operator=(const PDPOpDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PDPOpDesc& default_instance();

  void Swap(PDPOpDesc* other);

  // implements Message ----------------------------------------------

  PDPOpDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PDPOpDesc& from);
  void MergeFrom(const PDPOpDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PDPOpDesc_PoolingMode PoolingMode;
  static const PoolingMode MODE_AVG = PDPOpDesc_PoolingMode_MODE_AVG;
  static const PoolingMode MODE_MAX = PDPOpDesc_PoolingMode_MODE_MAX;
  static const PoolingMode MODE_MIN = PDPOpDesc_PoolingMode_MODE_MIN;
  static inline bool PoolingMode_IsValid(int value) {
    return PDPOpDesc_PoolingMode_IsValid(value);
  }
  static const PoolingMode PoolingMode_MIN =
    PDPOpDesc_PoolingMode_PoolingMode_MIN;
  static const PoolingMode PoolingMode_MAX =
    PDPOpDesc_PoolingMode_PoolingMode_MAX;
  static const int PoolingMode_ARRAYSIZE =
    PDPOpDesc_PoolingMode_PoolingMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PoolingMode_descriptor() {
    return PDPOpDesc_PoolingMode_descriptor();
  }
  static inline const ::std::string& PoolingMode_Name(PoolingMode value) {
    return PDPOpDesc_PoolingMode_Name(value);
  }
  static inline bool PoolingMode_Parse(const ::std::string& name,
      PoolingMode* value) {
    return PDPOpDesc_PoolingMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 partial_in_width_first = 1;
  inline bool has_partial_in_width_first() const;
  inline void clear_partial_in_width_first();
  static const int kPartialInWidthFirstFieldNumber = 1;
  inline ::google::protobuf::uint32 partial_in_width_first() const;
  inline void set_partial_in_width_first(::google::protobuf::uint32 value);

  // required uint32 partial_in_width_mid = 2;
  inline bool has_partial_in_width_mid() const;
  inline void clear_partial_in_width_mid();
  static const int kPartialInWidthMidFieldNumber = 2;
  inline ::google::protobuf::uint32 partial_in_width_mid() const;
  inline void set_partial_in_width_mid(::google::protobuf::uint32 value);

  // required uint32 partial_in_width_last = 3;
  inline bool has_partial_in_width_last() const;
  inline void clear_partial_in_width_last();
  static const int kPartialInWidthLastFieldNumber = 3;
  inline ::google::protobuf::uint32 partial_in_width_last() const;
  inline void set_partial_in_width_last(::google::protobuf::uint32 value);

  // required uint32 partial_width_first = 4;
  inline bool has_partial_width_first() const;
  inline void clear_partial_width_first();
  static const int kPartialWidthFirstFieldNumber = 4;
  inline ::google::protobuf::uint32 partial_width_first() const;
  inline void set_partial_width_first(::google::protobuf::uint32 value);

  // required uint32 partial_width_mid = 5;
  inline bool has_partial_width_mid() const;
  inline void clear_partial_width_mid();
  static const int kPartialWidthMidFieldNumber = 5;
  inline ::google::protobuf::uint32 partial_width_mid() const;
  inline void set_partial_width_mid(::google::protobuf::uint32 value);

  // required uint32 partial_width_last = 6;
  inline bool has_partial_width_last() const;
  inline void clear_partial_width_last();
  static const int kPartialWidthLastFieldNumber = 6;
  inline ::google::protobuf::uint32 partial_width_last() const;
  inline void set_partial_width_last(::google::protobuf::uint32 value);

  // required uint32 split_num = 7;
  inline bool has_split_num() const;
  inline void clear_split_num();
  static const int kSplitNumFieldNumber = 7;
  inline ::google::protobuf::uint32 split_num() const;
  inline void set_split_num(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.PDPOpDesc.PoolingMode pool_mode = 8;
  inline bool has_pool_mode() const;
  inline void clear_pool_mode();
  static const int kPoolModeFieldNumber = 8;
  inline ::nvdla_prototest_interface::PDPOpDesc_PoolingMode pool_mode() const;
  inline void set_pool_mode(::nvdla_prototest_interface::PDPOpDesc_PoolingMode value);

  // required .nvdla_prototest_interface.PoolSize pool_width = 9;
  inline bool has_pool_width() const;
  inline void clear_pool_width();
  static const int kPoolWidthFieldNumber = 9;
  inline ::nvdla_prototest_interface::PoolSize pool_width() const;
  inline void set_pool_width(::nvdla_prototest_interface::PoolSize value);

  // required .nvdla_prototest_interface.PoolSize pool_height = 10;
  inline bool has_pool_height() const;
  inline void clear_pool_height();
  static const int kPoolHeightFieldNumber = 10;
  inline ::nvdla_prototest_interface::PoolSize pool_height() const;
  inline void set_pool_height(::nvdla_prototest_interface::PoolSize value);

  // required uint32 stride_x = 11;
  inline bool has_stride_x() const;
  inline void clear_stride_x();
  static const int kStrideXFieldNumber = 11;
  inline ::google::protobuf::uint32 stride_x() const;
  inline void set_stride_x(::google::protobuf::uint32 value);

  // required uint32 stride_y = 12;
  inline bool has_stride_y() const;
  inline void clear_stride_y();
  static const int kStrideYFieldNumber = 12;
  inline ::google::protobuf::uint32 stride_y() const;
  inline void set_stride_y(::google::protobuf::uint32 value);

  // required uint32 pad_left = 13;
  inline bool has_pad_left() const;
  inline void clear_pad_left();
  static const int kPadLeftFieldNumber = 13;
  inline ::google::protobuf::uint32 pad_left() const;
  inline void set_pad_left(::google::protobuf::uint32 value);

  // required uint32 pad_right = 14;
  inline bool has_pad_right() const;
  inline void clear_pad_right();
  static const int kPadRightFieldNumber = 14;
  inline ::google::protobuf::uint32 pad_right() const;
  inline void set_pad_right(::google::protobuf::uint32 value);

  // required uint32 pad_top = 15;
  inline bool has_pad_top() const;
  inline void clear_pad_top();
  static const int kPadTopFieldNumber = 15;
  inline ::google::protobuf::uint32 pad_top() const;
  inline void set_pad_top(::google::protobuf::uint32 value);

  // required uint32 pad_bottom = 16;
  inline bool has_pad_bottom() const;
  inline void clear_pad_bottom();
  static const int kPadBottomFieldNumber = 16;
  inline ::google::protobuf::uint32 pad_bottom() const;
  inline void set_pad_bottom(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.DataPrecision precision = 17;
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 17;
  inline ::nvdla_prototest_interface::DataPrecision precision() const;
  inline void set_precision(::nvdla_prototest_interface::DataPrecision value);

  // optional uint32 reserved0 = 18 [default = 0];
  inline bool has_reserved0() const;
  inline void clear_reserved0();
  static const int kReserved0FieldNumber = 18;
  inline ::google::protobuf::uint32 reserved0() const;
  inline void set_reserved0(::google::protobuf::uint32 value);

  // repeated int32 padding_value = 19 [packed = true];
  inline int padding_value_size() const;
  inline void clear_padding_value();
  static const int kPaddingValueFieldNumber = 19;
  inline ::google::protobuf::int32 padding_value(int index) const;
  inline void set_padding_value(int index, ::google::protobuf::int32 value);
  inline void add_padding_value(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      padding_value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_padding_value();

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.PDPOpDesc)
 private:
  inline void set_has_partial_in_width_first();
  inline void clear_has_partial_in_width_first();
  inline void set_has_partial_in_width_mid();
  inline void clear_has_partial_in_width_mid();
  inline void set_has_partial_in_width_last();
  inline void clear_has_partial_in_width_last();
  inline void set_has_partial_width_first();
  inline void clear_has_partial_width_first();
  inline void set_has_partial_width_mid();
  inline void clear_has_partial_width_mid();
  inline void set_has_partial_width_last();
  inline void clear_has_partial_width_last();
  inline void set_has_split_num();
  inline void clear_has_split_num();
  inline void set_has_pool_mode();
  inline void clear_has_pool_mode();
  inline void set_has_pool_width();
  inline void clear_has_pool_width();
  inline void set_has_pool_height();
  inline void clear_has_pool_height();
  inline void set_has_stride_x();
  inline void clear_has_stride_x();
  inline void set_has_stride_y();
  inline void clear_has_stride_y();
  inline void set_has_pad_left();
  inline void clear_has_pad_left();
  inline void set_has_pad_right();
  inline void clear_has_pad_right();
  inline void set_has_pad_top();
  inline void clear_has_pad_top();
  inline void set_has_pad_bottom();
  inline void clear_has_pad_bottom();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_reserved0();
  inline void clear_has_reserved0();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 partial_in_width_first_;
  ::google::protobuf::uint32 partial_in_width_mid_;
  ::google::protobuf::uint32 partial_in_width_last_;
  ::google::protobuf::uint32 partial_width_first_;
  ::google::protobuf::uint32 partial_width_mid_;
  ::google::protobuf::uint32 partial_width_last_;
  ::google::protobuf::uint32 split_num_;
  int pool_mode_;
  int pool_width_;
  int pool_height_;
  ::google::protobuf::uint32 stride_x_;
  ::google::protobuf::uint32 stride_y_;
  ::google::protobuf::uint32 pad_left_;
  ::google::protobuf::uint32 pad_right_;
  ::google::protobuf::uint32 pad_top_;
  ::google::protobuf::uint32 pad_bottom_;
  int precision_;
  ::google::protobuf::uint32 reserved0_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > padding_value_;
  mutable int _padding_value_cached_byte_size_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static PDPOpDesc* default_instance_;
};
// -------------------------------------------------------------------

class CDPSurfaceDesc : public ::google::protobuf::Message {
 public:
  CDPSurfaceDesc();
  virtual ~CDPSurfaceDesc();

  CDPSurfaceDesc(const CDPSurfaceDesc& from);

  inline CDPSurfaceDesc& operator=(const CDPSurfaceDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CDPSurfaceDesc& default_instance();

  void Swap(CDPSurfaceDesc* other);

  // implements Message ----------------------------------------------

  CDPSurfaceDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CDPSurfaceDesc& from);
  void MergeFrom(const CDPSurfaceDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.DataCube src_data = 1;
  inline bool has_src_data() const;
  inline void clear_src_data();
  static const int kSrcDataFieldNumber = 1;
  inline const ::nvdla_prototest_interface::DataCube& src_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_src_data();
  inline ::nvdla_prototest_interface::DataCube* release_src_data();
  inline void set_allocated_src_data(::nvdla_prototest_interface::DataCube* src_data);

  // required .nvdla_prototest_interface.DataCube dst_data = 2;
  inline bool has_dst_data() const;
  inline void clear_dst_data();
  static const int kDstDataFieldNumber = 2;
  inline const ::nvdla_prototest_interface::DataCube& dst_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_dst_data();
  inline ::nvdla_prototest_interface::DataCube* release_dst_data();
  inline void set_allocated_dst_data(::nvdla_prototest_interface::DataCube* dst_data);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.CDPSurfaceDesc)
 private:
  inline void set_has_src_data();
  inline void clear_has_src_data();
  inline void set_has_dst_data();
  inline void clear_has_dst_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nvdla_prototest_interface::DataCube* src_data_;
  ::nvdla_prototest_interface::DataCube* dst_data_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static CDPSurfaceDesc* default_instance_;
};
// -------------------------------------------------------------------

class CDPOpDesc : public ::google::protobuf::Message {
 public:
  CDPOpDesc();
  virtual ~CDPOpDesc();

  CDPOpDesc(const CDPOpDesc& from);

  inline CDPOpDesc& operator=(const CDPOpDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CDPOpDesc& default_instance();

  void Swap(CDPOpDesc* other);

  // implements Message ----------------------------------------------

  CDPOpDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CDPOpDesc& from);
  void MergeFrom(const CDPOpDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.DataPrecision in_precision = 1;
  inline bool has_in_precision() const;
  inline void clear_in_precision();
  static const int kInPrecisionFieldNumber = 1;
  inline ::nvdla_prototest_interface::DataPrecision in_precision() const;
  inline void set_in_precision(::nvdla_prototest_interface::DataPrecision value);

  // required .nvdla_prototest_interface.DataPrecision out_precision = 2;
  inline bool has_out_precision() const;
  inline void clear_out_precision();
  static const int kOutPrecisionFieldNumber = 2;
  inline ::nvdla_prototest_interface::DataPrecision out_precision() const;
  inline void set_out_precision(::nvdla_prototest_interface::DataPrecision value);

  // required int32 lut_index = 3;
  inline bool has_lut_index() const;
  inline void clear_lut_index();
  static const int kLutIndexFieldNumber = 3;
  inline ::google::protobuf::int32 lut_index() const;
  inline void set_lut_index(::google::protobuf::int32 value);

  // required .nvdla_prototest_interface.CVTParam in_cvt = 4;
  inline bool has_in_cvt() const;
  inline void clear_in_cvt();
  static const int kInCvtFieldNumber = 4;
  inline const ::nvdla_prototest_interface::CVTParam& in_cvt() const;
  inline ::nvdla_prototest_interface::CVTParam* mutable_in_cvt();
  inline ::nvdla_prototest_interface::CVTParam* release_in_cvt();
  inline void set_allocated_in_cvt(::nvdla_prototest_interface::CVTParam* in_cvt);

  // required .nvdla_prototest_interface.CVTParam out_cvt = 5;
  inline bool has_out_cvt() const;
  inline void clear_out_cvt();
  static const int kOutCvtFieldNumber = 5;
  inline const ::nvdla_prototest_interface::CVTParam& out_cvt() const;
  inline ::nvdla_prototest_interface::CVTParam* mutable_out_cvt();
  inline ::nvdla_prototest_interface::CVTParam* release_out_cvt();
  inline void set_allocated_out_cvt(::nvdla_prototest_interface::CVTParam* out_cvt);

  // required uint32 local_size = 6;
  inline bool has_local_size() const;
  inline void clear_local_size();
  static const int kLocalSizeFieldNumber = 6;
  inline ::google::protobuf::uint32 local_size() const;
  inline void set_local_size(::google::protobuf::uint32 value);

  // required uint32 bypass_sqsum = 7;
  inline bool has_bypass_sqsum() const;
  inline void clear_bypass_sqsum();
  static const int kBypassSqsumFieldNumber = 7;
  inline ::google::protobuf::uint32 bypass_sqsum() const;
  inline void set_bypass_sqsum(::google::protobuf::uint32 value);

  // required uint32 bypass_out_mul = 8;
  inline bool has_bypass_out_mul() const;
  inline void clear_bypass_out_mul();
  static const int kBypassOutMulFieldNumber = 8;
  inline ::google::protobuf::uint32 bypass_out_mul() const;
  inline void set_bypass_out_mul(::google::protobuf::uint32 value);

  // optional uint32 reserved0 = 9 [default = 0];
  inline bool has_reserved0() const;
  inline void clear_reserved0();
  static const int kReserved0FieldNumber = 9;
  inline ::google::protobuf::uint32 reserved0() const;
  inline void set_reserved0(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.CDPOpDesc)
 private:
  inline void set_has_in_precision();
  inline void clear_has_in_precision();
  inline void set_has_out_precision();
  inline void clear_has_out_precision();
  inline void set_has_lut_index();
  inline void clear_has_lut_index();
  inline void set_has_in_cvt();
  inline void clear_has_in_cvt();
  inline void set_has_out_cvt();
  inline void clear_has_out_cvt();
  inline void set_has_local_size();
  inline void clear_has_local_size();
  inline void set_has_bypass_sqsum();
  inline void clear_has_bypass_sqsum();
  inline void set_has_bypass_out_mul();
  inline void clear_has_bypass_out_mul();
  inline void set_has_reserved0();
  inline void clear_has_reserved0();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int in_precision_;
  int out_precision_;
  ::nvdla_prototest_interface::CVTParam* in_cvt_;
  ::google::protobuf::int32 lut_index_;
  ::google::protobuf::uint32 local_size_;
  ::nvdla_prototest_interface::CVTParam* out_cvt_;
  ::google::protobuf::uint32 bypass_sqsum_;
  ::google::protobuf::uint32 bypass_out_mul_;
  ::google::protobuf::uint32 reserved0_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static CDPOpDesc* default_instance_;
};
// -------------------------------------------------------------------

class RUBIKSurfaceDesc : public ::google::protobuf::Message {
 public:
  RUBIKSurfaceDesc();
  virtual ~RUBIKSurfaceDesc();

  RUBIKSurfaceDesc(const RUBIKSurfaceDesc& from);

  inline RUBIKSurfaceDesc& operator=(const RUBIKSurfaceDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RUBIKSurfaceDesc& default_instance();

  void Swap(RUBIKSurfaceDesc* other);

  // implements Message ----------------------------------------------

  RUBIKSurfaceDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RUBIKSurfaceDesc& from);
  void MergeFrom(const RUBIKSurfaceDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.DataCube src_data = 1;
  inline bool has_src_data() const;
  inline void clear_src_data();
  static const int kSrcDataFieldNumber = 1;
  inline const ::nvdla_prototest_interface::DataCube& src_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_src_data();
  inline ::nvdla_prototest_interface::DataCube* release_src_data();
  inline void set_allocated_src_data(::nvdla_prototest_interface::DataCube* src_data);

  // required .nvdla_prototest_interface.DataCube dst_data = 2;
  inline bool has_dst_data() const;
  inline void clear_dst_data();
  static const int kDstDataFieldNumber = 2;
  inline const ::nvdla_prototest_interface::DataCube& dst_data() const;
  inline ::nvdla_prototest_interface::DataCube* mutable_dst_data();
  inline ::nvdla_prototest_interface::DataCube* release_dst_data();
  inline void set_allocated_dst_data(::nvdla_prototest_interface::DataCube* dst_data);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.RUBIKSurfaceDesc)
 private:
  inline void set_has_src_data();
  inline void clear_has_src_data();
  inline void set_has_dst_data();
  inline void clear_has_dst_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nvdla_prototest_interface::DataCube* src_data_;
  ::nvdla_prototest_interface::DataCube* dst_data_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static RUBIKSurfaceDesc* default_instance_;
};
// -------------------------------------------------------------------

class RUBIKOpDesc : public ::google::protobuf::Message {
 public:
  RUBIKOpDesc();
  virtual ~RUBIKOpDesc();

  RUBIKOpDesc(const RUBIKOpDesc& from);

  inline RUBIKOpDesc& operator=(const RUBIKOpDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RUBIKOpDesc& default_instance();

  void Swap(RUBIKOpDesc* other);

  // implements Message ----------------------------------------------

  RUBIKOpDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RUBIKOpDesc& from);
  void MergeFrom(const RUBIKOpDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.RUBIKMode mode = 1;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::nvdla_prototest_interface::RUBIKMode mode() const;
  inline void set_mode(::nvdla_prototest_interface::RUBIKMode value);

  // required .nvdla_prototest_interface.DataPrecision precision = 2;
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 2;
  inline ::nvdla_prototest_interface::DataPrecision precision() const;
  inline void set_precision(::nvdla_prototest_interface::DataPrecision value);

  // required uint32 stride_x = 3;
  inline bool has_stride_x() const;
  inline void clear_stride_x();
  static const int kStrideXFieldNumber = 3;
  inline ::google::protobuf::uint32 stride_x() const;
  inline void set_stride_x(::google::protobuf::uint32 value);

  // required uint32 stride_y = 4;
  inline bool has_stride_y() const;
  inline void clear_stride_y();
  static const int kStrideYFieldNumber = 4;
  inline ::google::protobuf::uint32 stride_y() const;
  inline void set_stride_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.RUBIKOpDesc)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_stride_x();
  inline void clear_has_stride_x();
  inline void set_has_stride_y();
  inline void clear_has_stride_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int mode_;
  int precision_;
  ::google::protobuf::uint32 stride_x_;
  ::google::protobuf::uint32 stride_y_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static RUBIKOpDesc* default_instance_;
};
// -------------------------------------------------------------------

class SurfaceContainer : public ::google::protobuf::Message {
 public:
  SurfaceContainer();
  virtual ~SurfaceContainer();

  SurfaceContainer(const SurfaceContainer& from);

  inline SurfaceContainer& operator=(const SurfaceContainer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SurfaceContainer& default_instance();

  enum SurfaceContainerOneofCase {
    kBdmaSurface = 1,
    kConvSurface = 2,
    kSdpSurface = 3,
    kPdpSurface = 4,
    kCdpSurface = 5,
    kRubikSurface = 6,
    SURFACE_CONTAINER_ONEOF_NOT_SET = 0,
  };

  void Swap(SurfaceContainer* other);

  // implements Message ----------------------------------------------

  SurfaceContainer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SurfaceContainer& from);
  void MergeFrom(const SurfaceContainer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nvdla_prototest_interface.BDMASurfaceDesc bdma_surface = 1;
  inline bool has_bdma_surface() const;
  inline void clear_bdma_surface();
  static const int kBdmaSurfaceFieldNumber = 1;
  inline const ::nvdla_prototest_interface::BDMASurfaceDesc& bdma_surface() const;
  inline ::nvdla_prototest_interface::BDMASurfaceDesc* mutable_bdma_surface();
  inline ::nvdla_prototest_interface::BDMASurfaceDesc* release_bdma_surface();
  inline void set_allocated_bdma_surface(::nvdla_prototest_interface::BDMASurfaceDesc* bdma_surface);

  // optional .nvdla_prototest_interface.CONVSurfaceDesc conv_surface = 2;
  inline bool has_conv_surface() const;
  inline void clear_conv_surface();
  static const int kConvSurfaceFieldNumber = 2;
  inline const ::nvdla_prototest_interface::CONVSurfaceDesc& conv_surface() const;
  inline ::nvdla_prototest_interface::CONVSurfaceDesc* mutable_conv_surface();
  inline ::nvdla_prototest_interface::CONVSurfaceDesc* release_conv_surface();
  inline void set_allocated_conv_surface(::nvdla_prototest_interface::CONVSurfaceDesc* conv_surface);

  // optional .nvdla_prototest_interface.SDPSurfaceDesc sdp_surface = 3;
  inline bool has_sdp_surface() const;
  inline void clear_sdp_surface();
  static const int kSdpSurfaceFieldNumber = 3;
  inline const ::nvdla_prototest_interface::SDPSurfaceDesc& sdp_surface() const;
  inline ::nvdla_prototest_interface::SDPSurfaceDesc* mutable_sdp_surface();
  inline ::nvdla_prototest_interface::SDPSurfaceDesc* release_sdp_surface();
  inline void set_allocated_sdp_surface(::nvdla_prototest_interface::SDPSurfaceDesc* sdp_surface);

  // optional .nvdla_prototest_interface.PDPSurfaceDesc pdp_surface = 4;
  inline bool has_pdp_surface() const;
  inline void clear_pdp_surface();
  static const int kPdpSurfaceFieldNumber = 4;
  inline const ::nvdla_prototest_interface::PDPSurfaceDesc& pdp_surface() const;
  inline ::nvdla_prototest_interface::PDPSurfaceDesc* mutable_pdp_surface();
  inline ::nvdla_prototest_interface::PDPSurfaceDesc* release_pdp_surface();
  inline void set_allocated_pdp_surface(::nvdla_prototest_interface::PDPSurfaceDesc* pdp_surface);

  // optional .nvdla_prototest_interface.CDPSurfaceDesc cdp_surface = 5;
  inline bool has_cdp_surface() const;
  inline void clear_cdp_surface();
  static const int kCdpSurfaceFieldNumber = 5;
  inline const ::nvdla_prototest_interface::CDPSurfaceDesc& cdp_surface() const;
  inline ::nvdla_prototest_interface::CDPSurfaceDesc* mutable_cdp_surface();
  inline ::nvdla_prototest_interface::CDPSurfaceDesc* release_cdp_surface();
  inline void set_allocated_cdp_surface(::nvdla_prototest_interface::CDPSurfaceDesc* cdp_surface);

  // optional .nvdla_prototest_interface.RUBIKSurfaceDesc rubik_surface = 6;
  inline bool has_rubik_surface() const;
  inline void clear_rubik_surface();
  static const int kRubikSurfaceFieldNumber = 6;
  inline const ::nvdla_prototest_interface::RUBIKSurfaceDesc& rubik_surface() const;
  inline ::nvdla_prototest_interface::RUBIKSurfaceDesc* mutable_rubik_surface();
  inline ::nvdla_prototest_interface::RUBIKSurfaceDesc* release_rubik_surface();
  inline void set_allocated_rubik_surface(::nvdla_prototest_interface::RUBIKSurfaceDesc* rubik_surface);

  inline SurfaceContainerOneofCase surface_container_oneof_case() const;
  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.SurfaceContainer)
 private:
  inline void set_has_bdma_surface();
  inline void set_has_conv_surface();
  inline void set_has_sdp_surface();
  inline void set_has_pdp_surface();
  inline void set_has_cdp_surface();
  inline void set_has_rubik_surface();

  inline bool has_surface_container_oneof();
  void clear_surface_container_oneof();
  inline void clear_has_surface_container_oneof();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union SurfaceContainerOneofUnion {
    ::nvdla_prototest_interface::BDMASurfaceDesc* bdma_surface_;
    ::nvdla_prototest_interface::CONVSurfaceDesc* conv_surface_;
    ::nvdla_prototest_interface::SDPSurfaceDesc* sdp_surface_;
    ::nvdla_prototest_interface::PDPSurfaceDesc* pdp_surface_;
    ::nvdla_prototest_interface::CDPSurfaceDesc* cdp_surface_;
    ::nvdla_prototest_interface::RUBIKSurfaceDesc* rubik_surface_;
  } surface_container_oneof_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static SurfaceContainer* default_instance_;
};
// -------------------------------------------------------------------

class OperationContainer : public ::google::protobuf::Message {
 public:
  OperationContainer();
  virtual ~OperationContainer();

  OperationContainer(const OperationContainer& from);

  inline OperationContainer& operator=(const OperationContainer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationContainer& default_instance();

  enum OpContainerOneofCase {
    kBdmaOp = 1,
    kConvOp = 2,
    kSdpOp = 3,
    kPdpOp = 4,
    kCdpOp = 5,
    kRubikOp = 6,
    OP_CONTAINER_ONEOF_NOT_SET = 0,
  };

  void Swap(OperationContainer* other);

  // implements Message ----------------------------------------------

  OperationContainer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationContainer& from);
  void MergeFrom(const OperationContainer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nvdla_prototest_interface.BDMAOpDesc bdma_op = 1;
  inline bool has_bdma_op() const;
  inline void clear_bdma_op();
  static const int kBdmaOpFieldNumber = 1;
  inline const ::nvdla_prototest_interface::BDMAOpDesc& bdma_op() const;
  inline ::nvdla_prototest_interface::BDMAOpDesc* mutable_bdma_op();
  inline ::nvdla_prototest_interface::BDMAOpDesc* release_bdma_op();
  inline void set_allocated_bdma_op(::nvdla_prototest_interface::BDMAOpDesc* bdma_op);

  // optional .nvdla_prototest_interface.CONVOpDesc conv_op = 2;
  inline bool has_conv_op() const;
  inline void clear_conv_op();
  static const int kConvOpFieldNumber = 2;
  inline const ::nvdla_prototest_interface::CONVOpDesc& conv_op() const;
  inline ::nvdla_prototest_interface::CONVOpDesc* mutable_conv_op();
  inline ::nvdla_prototest_interface::CONVOpDesc* release_conv_op();
  inline void set_allocated_conv_op(::nvdla_prototest_interface::CONVOpDesc* conv_op);

  // optional .nvdla_prototest_interface.SDPOpDesc sdp_op = 3;
  inline bool has_sdp_op() const;
  inline void clear_sdp_op();
  static const int kSdpOpFieldNumber = 3;
  inline const ::nvdla_prototest_interface::SDPOpDesc& sdp_op() const;
  inline ::nvdla_prototest_interface::SDPOpDesc* mutable_sdp_op();
  inline ::nvdla_prototest_interface::SDPOpDesc* release_sdp_op();
  inline void set_allocated_sdp_op(::nvdla_prototest_interface::SDPOpDesc* sdp_op);

  // optional .nvdla_prototest_interface.PDPOpDesc pdp_op = 4;
  inline bool has_pdp_op() const;
  inline void clear_pdp_op();
  static const int kPdpOpFieldNumber = 4;
  inline const ::nvdla_prototest_interface::PDPOpDesc& pdp_op() const;
  inline ::nvdla_prototest_interface::PDPOpDesc* mutable_pdp_op();
  inline ::nvdla_prototest_interface::PDPOpDesc* release_pdp_op();
  inline void set_allocated_pdp_op(::nvdla_prototest_interface::PDPOpDesc* pdp_op);

  // optional .nvdla_prototest_interface.CDPOpDesc cdp_op = 5;
  inline bool has_cdp_op() const;
  inline void clear_cdp_op();
  static const int kCdpOpFieldNumber = 5;
  inline const ::nvdla_prototest_interface::CDPOpDesc& cdp_op() const;
  inline ::nvdla_prototest_interface::CDPOpDesc* mutable_cdp_op();
  inline ::nvdla_prototest_interface::CDPOpDesc* release_cdp_op();
  inline void set_allocated_cdp_op(::nvdla_prototest_interface::CDPOpDesc* cdp_op);

  // optional .nvdla_prototest_interface.RUBIKOpDesc rubik_op = 6;
  inline bool has_rubik_op() const;
  inline void clear_rubik_op();
  static const int kRubikOpFieldNumber = 6;
  inline const ::nvdla_prototest_interface::RUBIKOpDesc& rubik_op() const;
  inline ::nvdla_prototest_interface::RUBIKOpDesc* mutable_rubik_op();
  inline ::nvdla_prototest_interface::RUBIKOpDesc* release_rubik_op();
  inline void set_allocated_rubik_op(::nvdla_prototest_interface::RUBIKOpDesc* rubik_op);

  inline OpContainerOneofCase op_container_oneof_case() const;
  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.OperationContainer)
 private:
  inline void set_has_bdma_op();
  inline void set_has_conv_op();
  inline void set_has_sdp_op();
  inline void set_has_pdp_op();
  inline void set_has_cdp_op();
  inline void set_has_rubik_op();

  inline bool has_op_container_oneof();
  void clear_op_container_oneof();
  inline void clear_has_op_container_oneof();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union OpContainerOneofUnion {
    ::nvdla_prototest_interface::BDMAOpDesc* bdma_op_;
    ::nvdla_prototest_interface::CONVOpDesc* conv_op_;
    ::nvdla_prototest_interface::SDPOpDesc* sdp_op_;
    ::nvdla_prototest_interface::PDPOpDesc* pdp_op_;
    ::nvdla_prototest_interface::CDPOpDesc* cdp_op_;
    ::nvdla_prototest_interface::RUBIKOpDesc* rubik_op_;
  } op_container_oneof_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static OperationContainer* default_instance_;
};
// -------------------------------------------------------------------

class Consumer : public ::google::protobuf::Message {
 public:
  Consumer();
  virtual ~Consumer();

  Consumer(const Consumer& from);

  inline Consumer& operator=(const Consumer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Consumer& default_instance();

  void Swap(Consumer* other);

  // implements Message ----------------------------------------------

  Consumer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Consumer& from);
  void MergeFrom(const Consumer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Consumer_EventType EventType;
  static const EventType OP_COMPLETED = Consumer_EventType_OP_COMPLETED;
  static const EventType OP_PROGRAMMED = Consumer_EventType_OP_PROGRAMMED;
  static const EventType OP_ENABLED = Consumer_EventType_OP_ENABLED;
  static const EventType CDMA_WT_DONE = Consumer_EventType_CDMA_WT_DONE;
  static const EventType CDMA_DT_DONE = Consumer_EventType_CDMA_DT_DONE;
  static inline bool EventType_IsValid(int value) {
    return Consumer_EventType_IsValid(value);
  }
  static const EventType EventType_MIN =
    Consumer_EventType_EventType_MIN;
  static const EventType EventType_MAX =
    Consumer_EventType_EventType_MAX;
  static const int EventType_ARRAYSIZE =
    Consumer_EventType_EventType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EventType_descriptor() {
    return Consumer_EventType_descriptor();
  }
  static inline const ::std::string& EventType_Name(EventType value) {
    return Consumer_EventType_Name(value);
  }
  static inline bool EventType_Parse(const ::std::string& name,
      EventType* value) {
    return Consumer_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required .nvdla_prototest_interface.LayerType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::nvdla_prototest_interface::LayerType type() const;
  inline void set_type(::nvdla_prototest_interface::LayerType value);

  // required .nvdla_prototest_interface.Consumer.EventType event = 3;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 3;
  inline ::nvdla_prototest_interface::Consumer_EventType event() const;
  inline void set_event(::nvdla_prototest_interface::Consumer_EventType value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.Consumer)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_event();
  inline void clear_has_event();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  int type_;
  int event_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static Consumer* default_instance_;
};
// -------------------------------------------------------------------

class Layer : public ::google::protobuf::Message {
 public:
  Layer();
  virtual ~Layer();

  Layer(const Layer& from);

  inline Layer& operator=(const Layer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Layer& default_instance();

  void Swap(Layer* other);

  // implements Message ----------------------------------------------

  Layer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Layer& from);
  void MergeFrom(const Layer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required int32 roi_index = 2;
  inline bool has_roi_index() const;
  inline void clear_roi_index();
  static const int kRoiIndexFieldNumber = 2;
  inline ::google::protobuf::int32 roi_index() const;
  inline void set_roi_index(::google::protobuf::int32 value);

  // required .nvdla_prototest_interface.LayerType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::nvdla_prototest_interface::LayerType type() const;
  inline void set_type(::nvdla_prototest_interface::LayerType value);

  // required uint32 dependency_count = 4;
  inline bool has_dependency_count() const;
  inline void clear_dependency_count();
  static const int kDependencyCountFieldNumber = 4;
  inline ::google::protobuf::uint32 dependency_count() const;
  inline void set_dependency_count(::google::protobuf::uint32 value);

  // repeated uint32 reserved = 5 [packed = true];
  inline int reserved_size() const;
  inline void clear_reserved();
  static const int kReservedFieldNumber = 5;
  inline ::google::protobuf::uint32 reserved(int index) const;
  inline void set_reserved(int index, ::google::protobuf::uint32 value);
  inline void add_reserved(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      reserved() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_reserved();

  // repeated .nvdla_prototest_interface.Consumer bottom = 6;
  inline int bottom_size() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 6;
  inline const ::nvdla_prototest_interface::Consumer& bottom(int index) const;
  inline ::nvdla_prototest_interface::Consumer* mutable_bottom(int index);
  inline ::nvdla_prototest_interface::Consumer* add_bottom();
  inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Consumer >&
      bottom() const;
  inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Consumer >*
      mutable_bottom();

  // optional .nvdla_prototest_interface.Consumer fused = 7;
  inline bool has_fused() const;
  inline void clear_fused();
  static const int kFusedFieldNumber = 7;
  inline const ::nvdla_prototest_interface::Consumer& fused() const;
  inline ::nvdla_prototest_interface::Consumer* mutable_fused();
  inline ::nvdla_prototest_interface::Consumer* release_fused();
  inline void set_allocated_fused(::nvdla_prototest_interface::Consumer* fused);

  // required .nvdla_prototest_interface.OperationContainer op_config = 8;
  inline bool has_op_config() const;
  inline void clear_op_config();
  static const int kOpConfigFieldNumber = 8;
  inline const ::nvdla_prototest_interface::OperationContainer& op_config() const;
  inline ::nvdla_prototest_interface::OperationContainer* mutable_op_config();
  inline ::nvdla_prototest_interface::OperationContainer* release_op_config();
  inline void set_allocated_op_config(::nvdla_prototest_interface::OperationContainer* op_config);

  // required .nvdla_prototest_interface.SurfaceContainer surface = 9;
  inline bool has_surface() const;
  inline void clear_surface();
  static const int kSurfaceFieldNumber = 9;
  inline const ::nvdla_prototest_interface::SurfaceContainer& surface() const;
  inline ::nvdla_prototest_interface::SurfaceContainer* mutable_surface();
  inline ::nvdla_prototest_interface::SurfaceContainer* release_surface();
  inline void set_allocated_surface(::nvdla_prototest_interface::SurfaceContainer* surface);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.Layer)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_roi_index();
  inline void clear_has_roi_index();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_dependency_count();
  inline void clear_has_dependency_count();
  inline void set_has_fused();
  inline void clear_has_fused();
  inline void set_has_op_config();
  inline void clear_has_op_config();
  inline void set_has_surface();
  inline void clear_has_surface();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 roi_index_;
  int type_;
  ::google::protobuf::uint32 dependency_count_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > reserved_;
  mutable int _reserved_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Consumer > bottom_;
  ::nvdla_prototest_interface::Consumer* fused_;
  ::nvdla_prototest_interface::OperationContainer* op_config_;
  ::nvdla_prototest_interface::SurfaceContainer* surface_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static Layer* default_instance_;
};
// -------------------------------------------------------------------

class NetworkLayer : public ::google::protobuf::Message {
 public:
  NetworkLayer();
  virtual ~NetworkLayer();

  NetworkLayer(const NetworkLayer& from);

  inline NetworkLayer& operator=(const NetworkLayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkLayer& default_instance();

  void Swap(NetworkLayer* other);

  // implements Message ----------------------------------------------

  NetworkLayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetworkLayer& from);
  void MergeFrom(const NetworkLayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nvdla_prototest_interface.Layer layer = 1;
  inline int layer_size() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 1;
  inline const ::nvdla_prototest_interface::Layer& layer(int index) const;
  inline ::nvdla_prototest_interface::Layer* mutable_layer(int index);
  inline ::nvdla_prototest_interface::Layer* add_layer();
  inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Layer >&
      layer() const;
  inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Layer >*
      mutable_layer();

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.NetworkLayer)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Layer > layer_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static NetworkLayer* default_instance_;
};
// -------------------------------------------------------------------

class NetworkDesc : public ::google::protobuf::Message {
 public:
  NetworkDesc();
  virtual ~NetworkDesc();

  NetworkDesc(const NetworkDesc& from);

  inline NetworkDesc& operator=(const NetworkDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkDesc& default_instance();

  void Swap(NetworkDesc* other);

  // implements Message ----------------------------------------------

  NetworkDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetworkDesc& from);
  void MergeFrom(const NetworkDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 operation_desc_index = 1;
  inline bool has_operation_desc_index() const;
  inline void clear_operation_desc_index();
  static const int kOperationDescIndexFieldNumber = 1;
  inline ::google::protobuf::int32 operation_desc_index() const;
  inline void set_operation_desc_index(::google::protobuf::int32 value);

  // required int32 surface_desc_index = 2;
  inline bool has_surface_desc_index() const;
  inline void clear_surface_desc_index();
  static const int kSurfaceDescIndexFieldNumber = 2;
  inline ::google::protobuf::int32 surface_desc_index() const;
  inline void set_surface_desc_index(::google::protobuf::int32 value);

  // required int32 dependency_graph_index = 3;
  inline bool has_dependency_graph_index() const;
  inline void clear_dependency_graph_index();
  static const int kDependencyGraphIndexFieldNumber = 3;
  inline ::google::protobuf::int32 dependency_graph_index() const;
  inline void set_dependency_graph_index(::google::protobuf::int32 value);

  // required int32 lut_data_index = 4;
  inline bool has_lut_data_index() const;
  inline void clear_lut_data_index();
  static const int kLutDataIndexFieldNumber = 4;
  inline ::google::protobuf::int32 lut_data_index() const;
  inline void set_lut_data_index(::google::protobuf::int32 value);

  // required int32 roi_array_index = 5;
  inline bool has_roi_array_index() const;
  inline void clear_roi_array_index();
  static const int kRoiArrayIndexFieldNumber = 5;
  inline ::google::protobuf::int32 roi_array_index() const;
  inline void set_roi_array_index(::google::protobuf::int32 value);

  // required int32 surface_index = 6;
  inline bool has_surface_index() const;
  inline void clear_surface_index();
  static const int kSurfaceIndexFieldNumber = 6;
  inline ::google::protobuf::int32 surface_index() const;
  inline void set_surface_index(::google::protobuf::int32 value);

  // optional int32 stat_list_index = 7 [default = -1];
  inline bool has_stat_list_index() const;
  inline void clear_stat_list_index();
  static const int kStatListIndexFieldNumber = 7;
  inline ::google::protobuf::int32 stat_list_index() const;
  inline void set_stat_list_index(::google::protobuf::int32 value);

  // optional int32 reserved1 = 8 [default = -1];
  inline bool has_reserved1() const;
  inline void clear_reserved1();
  static const int kReserved1FieldNumber = 8;
  inline ::google::protobuf::int32 reserved1() const;
  inline void set_reserved1(::google::protobuf::int32 value);

  // repeated int32 op_head = 9 [packed = true];
  inline int op_head_size() const;
  inline void clear_op_head();
  static const int kOpHeadFieldNumber = 9;
  inline ::google::protobuf::int32 op_head(int index) const;
  inline void set_op_head(int index, ::google::protobuf::int32 value);
  inline void add_op_head(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      op_head() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_op_head();

  // required uint32 num_rois = 10;
  inline bool has_num_rois() const;
  inline void clear_num_rois();
  static const int kNumRoisFieldNumber = 10;
  inline ::google::protobuf::uint32 num_rois() const;
  inline void set_num_rois(::google::protobuf::uint32 value);

  // required uint32 num_operations = 11;
  inline bool has_num_operations() const;
  inline void clear_num_operations();
  static const int kNumOperationsFieldNumber = 11;
  inline ::google::protobuf::uint32 num_operations() const;
  inline void set_num_operations(::google::protobuf::uint32 value);

  // required uint32 num_luts = 12;
  inline bool has_num_luts() const;
  inline void clear_num_luts();
  static const int kNumLutsFieldNumber = 12;
  inline ::google::protobuf::uint32 num_luts() const;
  inline void set_num_luts(::google::protobuf::uint32 value);

  // required uint32 num_addresses = 13;
  inline bool has_num_addresses() const;
  inline void clear_num_addresses();
  static const int kNumAddressesFieldNumber = 13;
  inline ::google::protobuf::uint32 num_addresses() const;
  inline void set_num_addresses(::google::protobuf::uint32 value);

  // required int32 input_layer = 14;
  inline bool has_input_layer() const;
  inline void clear_input_layer();
  static const int kInputLayerFieldNumber = 14;
  inline ::google::protobuf::int32 input_layer() const;
  inline void set_input_layer(::google::protobuf::int32 value);

  // required uint32 dynamic_roi = 15;
  inline bool has_dynamic_roi() const;
  inline void clear_dynamic_roi();
  static const int kDynamicRoiFieldNumber = 15;
  inline ::google::protobuf::uint32 dynamic_roi() const;
  inline void set_dynamic_roi(::google::protobuf::uint32 value);

  // optional uint32 reserved0 = 16 [default = 0];
  inline bool has_reserved0() const;
  inline void clear_reserved0();
  static const int kReserved0FieldNumber = 16;
  inline ::google::protobuf::uint32 reserved0() const;
  inline void set_reserved0(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.NetworkDesc)
 private:
  inline void set_has_operation_desc_index();
  inline void clear_has_operation_desc_index();
  inline void set_has_surface_desc_index();
  inline void clear_has_surface_desc_index();
  inline void set_has_dependency_graph_index();
  inline void clear_has_dependency_graph_index();
  inline void set_has_lut_data_index();
  inline void clear_has_lut_data_index();
  inline void set_has_roi_array_index();
  inline void clear_has_roi_array_index();
  inline void set_has_surface_index();
  inline void clear_has_surface_index();
  inline void set_has_stat_list_index();
  inline void clear_has_stat_list_index();
  inline void set_has_reserved1();
  inline void clear_has_reserved1();
  inline void set_has_num_rois();
  inline void clear_has_num_rois();
  inline void set_has_num_operations();
  inline void clear_has_num_operations();
  inline void set_has_num_luts();
  inline void clear_has_num_luts();
  inline void set_has_num_addresses();
  inline void clear_has_num_addresses();
  inline void set_has_input_layer();
  inline void clear_has_input_layer();
  inline void set_has_dynamic_roi();
  inline void clear_has_dynamic_roi();
  inline void set_has_reserved0();
  inline void clear_has_reserved0();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 operation_desc_index_;
  ::google::protobuf::int32 surface_desc_index_;
  ::google::protobuf::int32 dependency_graph_index_;
  ::google::protobuf::int32 lut_data_index_;
  ::google::protobuf::int32 roi_array_index_;
  ::google::protobuf::int32 surface_index_;
  ::google::protobuf::int32 stat_list_index_;
  ::google::protobuf::int32 reserved1_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > op_head_;
  mutable int _op_head_cached_byte_size_;
  ::google::protobuf::uint32 num_rois_;
  ::google::protobuf::uint32 num_operations_;
  ::google::protobuf::uint32 num_luts_;
  ::google::protobuf::uint32 num_addresses_;
  ::google::protobuf::int32 input_layer_;
  ::google::protobuf::uint32 dynamic_roi_;
  ::google::protobuf::uint32 reserved0_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static NetworkDesc* default_instance_;
};
// -------------------------------------------------------------------

class LUTParamList : public ::google::protobuf::Message {
 public:
  LUTParamList();
  virtual ~LUTParamList();

  LUTParamList(const LUTParamList& from);

  inline LUTParamList& operator=(const LUTParamList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LUTParamList& default_instance();

  void Swap(LUTParamList* other);

  // implements Message ----------------------------------------------

  LUTParamList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LUTParamList& from);
  void MergeFrom(const LUTParamList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nvdla_prototest_interface.LUTParam lut_param = 1;
  inline int lut_param_size() const;
  inline void clear_lut_param();
  static const int kLutParamFieldNumber = 1;
  inline const ::nvdla_prototest_interface::LUTParam& lut_param(int index) const;
  inline ::nvdla_prototest_interface::LUTParam* mutable_lut_param(int index);
  inline ::nvdla_prototest_interface::LUTParam* add_lut_param();
  inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::LUTParam >&
      lut_param() const;
  inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::LUTParam >*
      mutable_lut_param();

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.LUTParamList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::LUTParam > lut_param_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static LUTParamList* default_instance_;
};
// -------------------------------------------------------------------

class ROIArrayDesc : public ::google::protobuf::Message {
 public:
  ROIArrayDesc();
  virtual ~ROIArrayDesc();

  ROIArrayDesc(const ROIArrayDesc& from);

  inline ROIArrayDesc& operator=(const ROIArrayDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ROIArrayDesc& default_instance();

  void Swap(ROIArrayDesc* other);

  // implements Message ----------------------------------------------

  ROIArrayDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ROIArrayDesc& from);
  void MergeFrom(const ROIArrayDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 array_length = 1;
  inline bool has_array_length() const;
  inline void clear_array_length();
  static const int kArrayLengthFieldNumber = 1;
  inline ::google::protobuf::uint32 array_length() const;
  inline void set_array_length(::google::protobuf::uint32 value);

  // required uint32 array_reserved = 2;
  inline bool has_array_reserved() const;
  inline void clear_array_reserved();
  static const int kArrayReservedFieldNumber = 2;
  inline ::google::protobuf::uint32 array_reserved() const;
  inline void set_array_reserved(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.ROIArrayDesc)
 private:
  inline void set_has_array_length();
  inline void clear_has_array_length();
  inline void set_has_array_reserved();
  inline void clear_has_array_reserved();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 array_length_;
  ::google::protobuf::uint32 array_reserved_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static ROIArrayDesc* default_instance_;
};
// -------------------------------------------------------------------

class ROIDesc : public ::google::protobuf::Message {
 public:
  ROIDesc();
  virtual ~ROIDesc();

  ROIDesc(const ROIDesc& from);

  inline ROIDesc& operator=(const ROIDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ROIDesc& default_instance();

  void Swap(ROIDesc* other);

  // implements Message ----------------------------------------------

  ROIDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ROIDesc& from);
  void MergeFrom(const ROIDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::uint32 left() const;
  inline void set_left(::google::protobuf::uint32 value);

  // required uint32 top = 2;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 2;
  inline ::google::protobuf::uint32 top() const;
  inline void set_top(::google::protobuf::uint32 value);

  // required uint32 right = 3;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 3;
  inline ::google::protobuf::uint32 right() const;
  inline void set_right(::google::protobuf::uint32 value);

  // required uint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::uint32 bottom() const;
  inline void set_bottom(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.ROIDesc)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_bottom();
  inline void clear_has_bottom();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 left_;
  ::google::protobuf::uint32 top_;
  ::google::protobuf::uint32 right_;
  ::google::protobuf::uint32 bottom_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static ROIDesc* default_instance_;
};
// -------------------------------------------------------------------

class ROIDescription : public ::google::protobuf::Message {
 public:
  ROIDescription();
  virtual ~ROIDescription();

  ROIDescription(const ROIDescription& from);

  inline ROIDescription& operator=(const ROIDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ROIDescription& default_instance();

  void Swap(ROIDescription* other);

  // implements Message ----------------------------------------------

  ROIDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ROIDescription& from);
  void MergeFrom(const ROIDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.ROIArrayDesc roi_arr = 1;
  inline bool has_roi_arr() const;
  inline void clear_roi_arr();
  static const int kRoiArrFieldNumber = 1;
  inline const ::nvdla_prototest_interface::ROIArrayDesc& roi_arr() const;
  inline ::nvdla_prototest_interface::ROIArrayDesc* mutable_roi_arr();
  inline ::nvdla_prototest_interface::ROIArrayDesc* release_roi_arr();
  inline void set_allocated_roi_arr(::nvdla_prototest_interface::ROIArrayDesc* roi_arr);

  // repeated .nvdla_prototest_interface.ROIDesc roi_desc = 2;
  inline int roi_desc_size() const;
  inline void clear_roi_desc();
  static const int kRoiDescFieldNumber = 2;
  inline const ::nvdla_prototest_interface::ROIDesc& roi_desc(int index) const;
  inline ::nvdla_prototest_interface::ROIDesc* mutable_roi_desc(int index);
  inline ::nvdla_prototest_interface::ROIDesc* add_roi_desc();
  inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::ROIDesc >&
      roi_desc() const;
  inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::ROIDesc >*
      mutable_roi_desc();

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.ROIDescription)
 private:
  inline void set_has_roi_arr();
  inline void clear_has_roi_arr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nvdla_prototest_interface::ROIArrayDesc* roi_arr_;
  ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::ROIDesc > roi_desc_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static ROIDescription* default_instance_;
};
// -------------------------------------------------------------------

class Network : public ::google::protobuf::Message {
 public:
  Network();
  virtual ~Network();

  Network(const Network& from);

  inline Network& operator=(const Network& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Network& default_instance();

  void Swap(Network* other);

  // implements Message ----------------------------------------------

  Network* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Network& from);
  void MergeFrom(const Network& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.NetworkDesc param = 1;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 1;
  inline const ::nvdla_prototest_interface::NetworkDesc& param() const;
  inline ::nvdla_prototest_interface::NetworkDesc* mutable_param();
  inline ::nvdla_prototest_interface::NetworkDesc* release_param();
  inline void set_allocated_param(::nvdla_prototest_interface::NetworkDesc* param);

  // required .nvdla_prototest_interface.NetworkLayer layers = 2;
  inline bool has_layers() const;
  inline void clear_layers();
  static const int kLayersFieldNumber = 2;
  inline const ::nvdla_prototest_interface::NetworkLayer& layers() const;
  inline ::nvdla_prototest_interface::NetworkLayer* mutable_layers();
  inline ::nvdla_prototest_interface::NetworkLayer* release_layers();
  inline void set_allocated_layers(::nvdla_prototest_interface::NetworkLayer* layers);

  // required .nvdla_prototest_interface.LUTParamList lut_list = 3;
  inline bool has_lut_list() const;
  inline void clear_lut_list();
  static const int kLutListFieldNumber = 3;
  inline const ::nvdla_prototest_interface::LUTParamList& lut_list() const;
  inline ::nvdla_prototest_interface::LUTParamList* mutable_lut_list();
  inline ::nvdla_prototest_interface::LUTParamList* release_lut_list();
  inline void set_allocated_lut_list(::nvdla_prototest_interface::LUTParamList* lut_list);

  // required .nvdla_prototest_interface.ROIDescription roi_list = 4;
  inline bool has_roi_list() const;
  inline void clear_roi_list();
  static const int kRoiListFieldNumber = 4;
  inline const ::nvdla_prototest_interface::ROIDescription& roi_list() const;
  inline ::nvdla_prototest_interface::ROIDescription* mutable_roi_list();
  inline ::nvdla_prototest_interface::ROIDescription* release_roi_list();
  inline void set_allocated_roi_list(::nvdla_prototest_interface::ROIDescription* roi_list);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.Network)
 private:
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_layers();
  inline void clear_has_layers();
  inline void set_has_lut_list();
  inline void clear_has_lut_list();
  inline void set_has_roi_list();
  inline void clear_has_roi_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nvdla_prototest_interface::NetworkDesc* param_;
  ::nvdla_prototest_interface::NetworkLayer* layers_;
  ::nvdla_prototest_interface::LUTParamList* lut_list_;
  ::nvdla_prototest_interface::ROIDescription* roi_list_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static Network* default_instance_;
};
// -------------------------------------------------------------------

class TaskStatus : public ::google::protobuf::Message {
 public:
  TaskStatus();
  virtual ~TaskStatus();

  TaskStatus(const TaskStatus& from);

  inline TaskStatus& operator=(const TaskStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskStatus& default_instance();

  void Swap(TaskStatus* other);

  // implements Message ----------------------------------------------

  TaskStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskStatus& from);
  void MergeFrom(const TaskStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // required uint32 status_engine = 2;
  inline bool has_status_engine() const;
  inline void clear_status_engine();
  static const int kStatusEngineFieldNumber = 2;
  inline ::google::protobuf::uint32 status_engine() const;
  inline void set_status_engine(::google::protobuf::uint32 value);

  // required uint32 subframe = 3;
  inline bool has_subframe() const;
  inline void clear_subframe();
  static const int kSubframeFieldNumber = 3;
  inline ::google::protobuf::uint32 subframe() const;
  inline void set_subframe(::google::protobuf::uint32 value);

  // required uint32 status_task = 4;
  inline bool has_status_task() const;
  inline void clear_status_task();
  static const int kStatusTaskFieldNumber = 4;
  inline ::google::protobuf::uint32 status_task() const;
  inline void set_status_task(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.TaskStatus)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_status_engine();
  inline void clear_has_status_engine();
  inline void set_has_subframe();
  inline void clear_has_subframe();
  inline void set_has_status_task();
  inline void clear_has_status_task();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 status_engine_;
  ::google::protobuf::uint32 subframe_;
  ::google::protobuf::uint32 status_task_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static TaskStatus* default_instance_;
};
// -------------------------------------------------------------------

class Action : public ::google::protobuf::Message {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();

  void Swap(Action* other);

  // implements Message ----------------------------------------------

  Action* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 event_id = 1 [packed = true];
  inline int event_id_size() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 1;
  inline ::google::protobuf::uint32 event_id(int index) const;
  inline void set_event_id(int index, ::google::protobuf::uint32 value);
  inline void add_event_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      event_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_event_id();

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.Action)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > event_id_;
  mutable int _event_id_cached_byte_size_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static Action* default_instance_;
};
// -------------------------------------------------------------------

class TaskSchedule : public ::google::protobuf::Message {
 public:
  TaskSchedule();
  virtual ~TaskSchedule();

  TaskSchedule(const TaskSchedule& from);

  inline TaskSchedule& operator=(const TaskSchedule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskSchedule& default_instance();

  void Swap(TaskSchedule* other);

  // implements Message ----------------------------------------------

  TaskSchedule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskSchedule& from);
  void MergeFrom(const TaskSchedule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nvdla_prototest_interface.Action pre_actions = 1;
  inline bool has_pre_actions() const;
  inline void clear_pre_actions();
  static const int kPreActionsFieldNumber = 1;
  inline const ::nvdla_prototest_interface::Action& pre_actions() const;
  inline ::nvdla_prototest_interface::Action* mutable_pre_actions();
  inline ::nvdla_prototest_interface::Action* release_pre_actions();
  inline void set_allocated_pre_actions(::nvdla_prototest_interface::Action* pre_actions);

  // optional .nvdla_prototest_interface.Action post_actions = 2;
  inline bool has_post_actions() const;
  inline void clear_post_actions();
  static const int kPostActionsFieldNumber = 2;
  inline const ::nvdla_prototest_interface::Action& post_actions() const;
  inline ::nvdla_prototest_interface::Action* mutable_post_actions();
  inline ::nvdla_prototest_interface::Action* release_post_actions();
  inline void set_allocated_post_actions(::nvdla_prototest_interface::Action* post_actions);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.TaskSchedule)
 private:
  inline void set_has_pre_actions();
  inline void clear_has_pre_actions();
  inline void set_has_post_actions();
  inline void clear_has_post_actions();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nvdla_prototest_interface::Action* pre_actions_;
  ::nvdla_prototest_interface::Action* post_actions_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static TaskSchedule* default_instance_;
};
// -------------------------------------------------------------------

class TasksData : public ::google::protobuf::Message {
 public:
  TasksData();
  virtual ~TasksData();

  TasksData(const TasksData& from);

  inline TasksData& operator=(const TasksData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TasksData& default_instance();

  void Swap(TasksData* other);

  // implements Message ----------------------------------------------

  TasksData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TasksData& from);
  void MergeFrom(const TasksData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.EngineID engine_id = 2;
  inline bool has_engine_id() const;
  inline void clear_engine_id();
  static const int kEngineIdFieldNumber = 2;
  inline ::nvdla_prototest_interface::EngineID engine_id() const;
  inline void set_engine_id(::nvdla_prototest_interface::EngineID value);

  // required .nvdla_prototest_interface.Network network = 3;
  inline bool has_network() const;
  inline void clear_network();
  static const int kNetworkFieldNumber = 3;
  inline const ::nvdla_prototest_interface::Network& network() const;
  inline ::nvdla_prototest_interface::Network* mutable_network();
  inline ::nvdla_prototest_interface::Network* release_network();
  inline void set_allocated_network(::nvdla_prototest_interface::Network* network);

  // optional .nvdla_prototest_interface.TaskSchedule schedule = 4;
  inline bool has_schedule() const;
  inline void clear_schedule();
  static const int kScheduleFieldNumber = 4;
  inline const ::nvdla_prototest_interface::TaskSchedule& schedule() const;
  inline ::nvdla_prototest_interface::TaskSchedule* mutable_schedule();
  inline ::nvdla_prototest_interface::TaskSchedule* release_schedule();
  inline void set_allocated_schedule(::nvdla_prototest_interface::TaskSchedule* schedule);

  // optional .nvdla_prototest_interface.TaskStatus task_status = 5;
  inline bool has_task_status() const;
  inline void clear_task_status();
  static const int kTaskStatusFieldNumber = 5;
  inline const ::nvdla_prototest_interface::TaskStatus& task_status() const;
  inline ::nvdla_prototest_interface::TaskStatus* mutable_task_status();
  inline ::nvdla_prototest_interface::TaskStatus* release_task_status();
  inline void set_allocated_task_status(::nvdla_prototest_interface::TaskStatus* task_status);

  // optional uint32 task_timeout = 6 [default = 4294967295];
  inline bool has_task_timeout() const;
  inline void clear_task_timeout();
  static const int kTaskTimeoutFieldNumber = 6;
  inline ::google::protobuf::uint32 task_timeout() const;
  inline void set_task_timeout(::google::protobuf::uint32 value);

  // optional int32 task_result = 7 [default = 0];
  inline bool has_task_result() const;
  inline void clear_task_result();
  static const int kTaskResultFieldNumber = 7;
  inline ::google::protobuf::int32 task_result() const;
  inline void set_task_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.TasksData)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_engine_id();
  inline void clear_has_engine_id();
  inline void set_has_network();
  inline void clear_has_network();
  inline void set_has_schedule();
  inline void clear_has_schedule();
  inline void set_has_task_status();
  inline void clear_has_task_status();
  inline void set_has_task_timeout();
  inline void clear_has_task_timeout();
  inline void set_has_task_result();
  inline void clear_has_task_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 task_id_;
  int engine_id_;
  ::nvdla_prototest_interface::Network* network_;
  ::nvdla_prototest_interface::TaskSchedule* schedule_;
  ::nvdla_prototest_interface::TaskStatus* task_status_;
  ::google::protobuf::uint32 task_timeout_;
  ::google::protobuf::int32 task_result_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static TasksData* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  void Swap(Event* other);

  // implements Message ----------------------------------------------

  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Event_EventType EventType;
  static const EventType SYNCPOINT = Event_EventType_SYNCPOINT;
  static const EventType SYNCFD = Event_EventType_SYNCFD;
  static const EventType SEMAPHORE = Event_EventType_SEMAPHORE;
  static const EventType TS_SEMAPHORE = Event_EventType_TS_SEMAPHORE;
  static inline bool EventType_IsValid(int value) {
    return Event_EventType_IsValid(value);
  }
  static const EventType EventType_MIN =
    Event_EventType_EventType_MIN;
  static const EventType EventType_MAX =
    Event_EventType_EventType_MAX;
  static const int EventType_ARRAYSIZE =
    Event_EventType_EventType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EventType_descriptor() {
    return Event_EventType_descriptor();
  }
  static inline const ::std::string& EventType_Name(EventType value) {
    return Event_EventType_Name(value);
  }
  static inline bool EventType_Parse(const ::std::string& name,
      EventType* value) {
    return Event_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 event_id = 1;
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 1;
  inline ::google::protobuf::uint32 event_id() const;
  inline void set_event_id(::google::protobuf::uint32 value);

  // required .nvdla_prototest_interface.Event.EventType event_type = 2;
  inline bool has_event_type() const;
  inline void clear_event_type();
  static const int kEventTypeFieldNumber = 2;
  inline ::nvdla_prototest_interface::Event_EventType event_type() const;
  inline void set_event_type(::nvdla_prototest_interface::Event_EventType value);

  // required uint32 event_flags = 3;
  inline bool has_event_flags() const;
  inline void clear_event_flags();
  static const int kEventFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 event_flags() const;
  inline void set_event_flags(::google::protobuf::uint32 value);

  // optional uint32 event_timeout = 4 [default = 4294967295];
  inline bool has_event_timeout() const;
  inline void clear_event_timeout();
  static const int kEventTimeoutFieldNumber = 4;
  inline ::google::protobuf::uint32 event_timeout() const;
  inline void set_event_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.Event)
 private:
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_event_type();
  inline void clear_has_event_type();
  inline void set_has_event_flags();
  inline void clear_has_event_flags();
  inline void set_has_event_timeout();
  inline void clear_has_event_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 event_id_;
  int event_type_;
  ::google::protobuf::uint32 event_flags_;
  ::google::protobuf::uint32 event_timeout_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class EventList : public ::google::protobuf::Message {
 public:
  EventList();
  virtual ~EventList();

  EventList(const EventList& from);

  inline EventList& operator=(const EventList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventList& default_instance();

  void Swap(EventList* other);

  // implements Message ----------------------------------------------

  EventList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventList& from);
  void MergeFrom(const EventList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nvdla_prototest_interface.Event event = 1;
  inline int event_size() const;
  inline void clear_event();
  static const int kEventFieldNumber = 1;
  inline const ::nvdla_prototest_interface::Event& event(int index) const;
  inline ::nvdla_prototest_interface::Event* mutable_event(int index);
  inline ::nvdla_prototest_interface::Event* add_event();
  inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Event >&
      event() const;
  inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Event >*
      mutable_event();

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.EventList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Event > event_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static EventList* default_instance_;
};
// -------------------------------------------------------------------

class SubmitSlot : public ::google::protobuf::Message {
 public:
  SubmitSlot();
  virtual ~SubmitSlot();

  SubmitSlot(const SubmitSlot& from);

  inline SubmitSlot& operator=(const SubmitSlot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitSlot& default_instance();

  void Swap(SubmitSlot* other);

  // implements Message ----------------------------------------------

  SubmitSlot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitSlot& from);
  void MergeFrom(const SubmitSlot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 task_id = 1;
  inline int task_id_size() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::uint32 task_id(int index) const;
  inline void set_task_id(int index, ::google::protobuf::uint32 value);
  inline void add_task_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      task_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_task_id();

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.SubmitSlot)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > task_id_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static SubmitSlot* default_instance_;
};
// -------------------------------------------------------------------

class TestInfo : public ::google::protobuf::Message {
 public:
  TestInfo();
  virtual ~TestInfo();

  TestInfo(const TestInfo& from);

  inline TestInfo& operator=(const TestInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestInfo& default_instance();

  void Swap(TestInfo* other);

  // implements Message ----------------------------------------------

  TestInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestInfo& from);
  void MergeFrom(const TestInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 num_tasks = 1;
  inline bool has_num_tasks() const;
  inline void clear_num_tasks();
  static const int kNumTasksFieldNumber = 1;
  inline ::google::protobuf::uint32 num_tasks() const;
  inline void set_num_tasks(::google::protobuf::uint32 value);

  // required uint32 num_buffers = 2;
  inline bool has_num_buffers() const;
  inline void clear_num_buffers();
  static const int kNumBuffersFieldNumber = 2;
  inline ::google::protobuf::uint32 num_buffers() const;
  inline void set_num_buffers(::google::protobuf::uint32 value);

  // repeated .nvdla_prototest_interface.TasksData task = 3;
  inline int task_size() const;
  inline void clear_task();
  static const int kTaskFieldNumber = 3;
  inline const ::nvdla_prototest_interface::TasksData& task(int index) const;
  inline ::nvdla_prototest_interface::TasksData* mutable_task(int index);
  inline ::nvdla_prototest_interface::TasksData* add_task();
  inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::TasksData >&
      task() const;
  inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::TasksData >*
      mutable_task();

  // optional .nvdla_prototest_interface.EventList event_list = 4;
  inline bool has_event_list() const;
  inline void clear_event_list();
  static const int kEventListFieldNumber = 4;
  inline const ::nvdla_prototest_interface::EventList& event_list() const;
  inline ::nvdla_prototest_interface::EventList* mutable_event_list();
  inline ::nvdla_prototest_interface::EventList* release_event_list();
  inline void set_allocated_event_list(::nvdla_prototest_interface::EventList* event_list);

  // repeated .nvdla_prototest_interface.SubmitSlot slots = 5;
  inline int slots_size() const;
  inline void clear_slots();
  static const int kSlotsFieldNumber = 5;
  inline const ::nvdla_prototest_interface::SubmitSlot& slots(int index) const;
  inline ::nvdla_prototest_interface::SubmitSlot* mutable_slots(int index);
  inline ::nvdla_prototest_interface::SubmitSlot* add_slots();
  inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::SubmitSlot >&
      slots() const;
  inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::SubmitSlot >*
      mutable_slots();

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.TestInfo)
 private:
  inline void set_has_num_tasks();
  inline void clear_has_num_tasks();
  inline void set_has_num_buffers();
  inline void clear_has_num_buffers();
  inline void set_has_event_list();
  inline void clear_has_event_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 num_tasks_;
  ::google::protobuf::uint32 num_buffers_;
  ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::TasksData > task_;
  ::nvdla_prototest_interface::EventList* event_list_;
  ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::SubmitSlot > slots_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static TestInfo* default_instance_;
};
// -------------------------------------------------------------------

class Test : public ::google::protobuf::Message {
 public:
  Test();
  virtual ~Test();

  Test(const Test& from);

  inline Test& operator=(const Test& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Test& default_instance();

  void Swap(Test* other);

  // implements Message ----------------------------------------------

  Test* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Test& from);
  void MergeFrom(const Test& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .nvdla_prototest_interface.TestInfo test = 1;
  inline bool has_test() const;
  inline void clear_test();
  static const int kTestFieldNumber = 1;
  inline const ::nvdla_prototest_interface::TestInfo& test() const;
  inline ::nvdla_prototest_interface::TestInfo* mutable_test();
  inline ::nvdla_prototest_interface::TestInfo* release_test();
  inline void set_allocated_test(::nvdla_prototest_interface::TestInfo* test);

  // @@protoc_insertion_point(class_scope:nvdla_prototest_interface.Test)
 private:
  inline void set_has_test();
  inline void clear_has_test();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nvdla_prototest_interface::TestInfo* test_;
  friend void  protobuf_AddDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_AssignDesc_DlaPrototestInterface_2eproto();
  friend void protobuf_ShutdownFile_DlaPrototestInterface_2eproto();

  void InitAsDefaultInstance();
  static Test* default_instance_;
};
// ===================================================================


// ===================================================================

// LUTOffset

// optional int32 exp_offset = 1;
inline bool LUTOffset::has_exp_offset() const {
  return lut_offset_oneof_case() == kExpOffset;
}
inline void LUTOffset::set_has_exp_offset() {
  _oneof_case_[0] = kExpOffset;
}
inline void LUTOffset::clear_exp_offset() {
  if (has_exp_offset()) {
    lut_offset_oneof_.exp_offset_ = 0;
    clear_has_lut_offset_oneof();
  }
}
inline ::google::protobuf::int32 LUTOffset::exp_offset() const {
  if (has_exp_offset()) {
    return lut_offset_oneof_.exp_offset_;
  }
  return 0;
}
inline void LUTOffset::set_exp_offset(::google::protobuf::int32 value) {
  if (!has_exp_offset()) {
    clear_lut_offset_oneof();
    set_has_exp_offset();
  }
  lut_offset_oneof_.exp_offset_ = value;
}

// optional int32 frac_bits = 2;
inline bool LUTOffset::has_frac_bits() const {
  return lut_offset_oneof_case() == kFracBits;
}
inline void LUTOffset::set_has_frac_bits() {
  _oneof_case_[0] = kFracBits;
}
inline void LUTOffset::clear_frac_bits() {
  if (has_frac_bits()) {
    lut_offset_oneof_.frac_bits_ = 0;
    clear_has_lut_offset_oneof();
  }
}
inline ::google::protobuf::int32 LUTOffset::frac_bits() const {
  if (has_frac_bits()) {
    return lut_offset_oneof_.frac_bits_;
  }
  return 0;
}
inline void LUTOffset::set_frac_bits(::google::protobuf::int32 value) {
  if (!has_frac_bits()) {
    clear_lut_offset_oneof();
    set_has_frac_bits();
  }
  lut_offset_oneof_.frac_bits_ = value;
}

inline bool LUTOffset::has_lut_offset_oneof() {
  return lut_offset_oneof_case() != LUT_OFFSET_ONEOF_NOT_SET;
}
inline void LUTOffset::clear_has_lut_offset_oneof() {
  _oneof_case_[0] = LUT_OFFSET_ONEOF_NOT_SET;
}
inline LUTOffset::LutOffsetOneofCase LUTOffset::lut_offset_oneof_case() const {
  return LUTOffset::LutOffsetOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FloatData

// required int32 scale = 1;
inline bool FloatData::has_scale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloatData::set_has_scale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloatData::clear_has_scale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloatData::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline ::google::protobuf::int32 FloatData::scale() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.FloatData.scale)
  return scale_;
}
inline void FloatData::set_scale(::google::protobuf::int32 value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.FloatData.scale)
}

// required int32 shifter = 2;
inline bool FloatData::has_shifter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloatData::set_has_shifter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FloatData::clear_has_shifter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FloatData::clear_shifter() {
  shifter_ = 0;
  clear_has_shifter();
}
inline ::google::protobuf::int32 FloatData::shifter() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.FloatData.shifter)
  return shifter_;
}
inline void FloatData::set_shifter(::google::protobuf::int32 value) {
  set_has_shifter();
  shifter_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.FloatData.shifter)
}

// optional uint32 reserved0 = 3 [default = 0];
inline bool FloatData::has_reserved0() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FloatData::set_has_reserved0() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FloatData::clear_has_reserved0() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FloatData::clear_reserved0() {
  reserved0_ = 0u;
  clear_has_reserved0();
}
inline ::google::protobuf::uint32 FloatData::reserved0() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.FloatData.reserved0)
  return reserved0_;
}
inline void FloatData::set_reserved0(::google::protobuf::uint32 value) {
  set_has_reserved0();
  reserved0_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.FloatData.reserved0)
}

// -------------------------------------------------------------------

// DLASlope

// optional .nvdla_prototest_interface.FloatData data_i = 1;
inline bool DLASlope::has_data_i() const {
  return dla_slope_oneof_case() == kDataI;
}
inline void DLASlope::set_has_data_i() {
  _oneof_case_[0] = kDataI;
}
inline void DLASlope::clear_data_i() {
  if (has_data_i()) {
    delete dla_slope_oneof_.data_i_;
    clear_has_dla_slope_oneof();
  }
}
inline const ::nvdla_prototest_interface::FloatData& DLASlope::data_i() const {
  return has_data_i() ? *dla_slope_oneof_.data_i_
                      : ::nvdla_prototest_interface::FloatData::default_instance();
}
inline ::nvdla_prototest_interface::FloatData* DLASlope::mutable_data_i() {
  if (!has_data_i()) {
    clear_dla_slope_oneof();
    set_has_data_i();
    dla_slope_oneof_.data_i_ = new ::nvdla_prototest_interface::FloatData;
  }
  return dla_slope_oneof_.data_i_;
}
inline ::nvdla_prototest_interface::FloatData* DLASlope::release_data_i() {
  if (has_data_i()) {
    clear_has_dla_slope_oneof();
    ::nvdla_prototest_interface::FloatData* temp = dla_slope_oneof_.data_i_;
    dla_slope_oneof_.data_i_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DLASlope::set_allocated_data_i(::nvdla_prototest_interface::FloatData* data_i) {
  clear_dla_slope_oneof();
  if (data_i) {
    set_has_data_i();
    dla_slope_oneof_.data_i_ = data_i;
  }
}

// optional uint32 data_f = 2;
inline bool DLASlope::has_data_f() const {
  return dla_slope_oneof_case() == kDataF;
}
inline void DLASlope::set_has_data_f() {
  _oneof_case_[0] = kDataF;
}
inline void DLASlope::clear_data_f() {
  if (has_data_f()) {
    dla_slope_oneof_.data_f_ = 0u;
    clear_has_dla_slope_oneof();
  }
}
inline ::google::protobuf::uint32 DLASlope::data_f() const {
  if (has_data_f()) {
    return dla_slope_oneof_.data_f_;
  }
  return 0u;
}
inline void DLASlope::set_data_f(::google::protobuf::uint32 value) {
  if (!has_data_f()) {
    clear_dla_slope_oneof();
    set_has_data_f();
  }
  dla_slope_oneof_.data_f_ = value;
}

inline bool DLASlope::has_dla_slope_oneof() {
  return dla_slope_oneof_case() != DLA_SLOPE_ONEOF_NOT_SET;
}
inline void DLASlope::clear_has_dla_slope_oneof() {
  _oneof_case_[0] = DLA_SLOPE_ONEOF_NOT_SET;
}
inline DLASlope::DlaSlopeOneofCase DLASlope::dla_slope_oneof_case() const {
  return DLASlope::DlaSlopeOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DataFile

// required string name = 1;
inline bool DataFile::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataFile::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataFile::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataFile::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DataFile::name() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataFile.name)
  return *name_;
}
inline void DataFile::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataFile.name)
}
inline void DataFile::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:nvdla_prototest_interface.DataFile.name)
}
inline void DataFile::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nvdla_prototest_interface.DataFile.name)
}
inline ::std::string* DataFile::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.DataFile.name)
  return name_;
}
inline ::std::string* DataFile::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DataFile::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.DataFile.name)
}

// required .nvdla_prototest_interface.DataType data_type = 2;
inline bool DataFile::has_data_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataFile::set_has_data_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataFile::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataFile::clear_data_type() {
  data_type_ = 0;
  clear_has_data_type();
}
inline ::nvdla_prototest_interface::DataType DataFile::data_type() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataFile.data_type)
  return static_cast< ::nvdla_prototest_interface::DataType >(data_type_);
}
inline void DataFile::set_data_type(::nvdla_prototest_interface::DataType value) {
  assert(::nvdla_prototest_interface::DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataFile.data_type)
}

// required uint32 offset = 3;
inline bool DataFile::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataFile::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataFile::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataFile::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 DataFile::offset() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataFile.offset)
  return offset_;
}
inline void DataFile::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataFile.offset)
}

// required uint32 size = 4;
inline bool DataFile::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataFile::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataFile::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataFile::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 DataFile::size() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataFile.size)
  return size_;
}
inline void DataFile::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataFile.size)
}

// required .nvdla_prototest_interface.FileType file_type = 5;
inline bool DataFile::has_file_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataFile::set_has_file_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataFile::clear_has_file_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataFile::clear_file_type() {
  file_type_ = 0;
  clear_has_file_type();
}
inline ::nvdla_prototest_interface::FileType DataFile::file_type() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataFile.file_type)
  return static_cast< ::nvdla_prototest_interface::FileType >(file_type_);
}
inline void DataFile::set_file_type(::nvdla_prototest_interface::FileType value) {
  assert(::nvdla_prototest_interface::FileType_IsValid(value));
  set_has_file_type();
  file_type_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataFile.file_type)
}

// -------------------------------------------------------------------

// Constant

// required int32 value = 1;
inline bool Constant::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Constant::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Constant::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Constant::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 Constant::value() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Constant.value)
  return value_;
}
inline void Constant::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Constant.value)
}

// -------------------------------------------------------------------

// DataFiller

// optional .nvdla_prototest_interface.DataFile data_file = 1;
inline bool DataFiller::has_data_file() const {
  return data_filler_oneof_case() == kDataFile;
}
inline void DataFiller::set_has_data_file() {
  _oneof_case_[0] = kDataFile;
}
inline void DataFiller::clear_data_file() {
  if (has_data_file()) {
    delete data_filler_oneof_.data_file_;
    clear_has_data_filler_oneof();
  }
}
inline const ::nvdla_prototest_interface::DataFile& DataFiller::data_file() const {
  return has_data_file() ? *data_filler_oneof_.data_file_
                      : ::nvdla_prototest_interface::DataFile::default_instance();
}
inline ::nvdla_prototest_interface::DataFile* DataFiller::mutable_data_file() {
  if (!has_data_file()) {
    clear_data_filler_oneof();
    set_has_data_file();
    data_filler_oneof_.data_file_ = new ::nvdla_prototest_interface::DataFile;
  }
  return data_filler_oneof_.data_file_;
}
inline ::nvdla_prototest_interface::DataFile* DataFiller::release_data_file() {
  if (has_data_file()) {
    clear_has_data_filler_oneof();
    ::nvdla_prototest_interface::DataFile* temp = data_filler_oneof_.data_file_;
    data_filler_oneof_.data_file_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DataFiller::set_allocated_data_file(::nvdla_prototest_interface::DataFile* data_file) {
  clear_data_filler_oneof();
  if (data_file) {
    set_has_data_file();
    data_filler_oneof_.data_file_ = data_file;
  }
}

// optional .nvdla_prototest_interface.Constant const = 2;
inline bool DataFiller::has_const_() const {
  return data_filler_oneof_case() == kConst;
}
inline void DataFiller::set_has_const_() {
  _oneof_case_[0] = kConst;
}
inline void DataFiller::clear_const_() {
  if (has_const_()) {
    delete data_filler_oneof_.const__;
    clear_has_data_filler_oneof();
  }
}
inline const ::nvdla_prototest_interface::Constant& DataFiller::const_() const {
  return has_const_() ? *data_filler_oneof_.const__
                      : ::nvdla_prototest_interface::Constant::default_instance();
}
inline ::nvdla_prototest_interface::Constant* DataFiller::mutable_const_() {
  if (!has_const_()) {
    clear_data_filler_oneof();
    set_has_const_();
    data_filler_oneof_.const__ = new ::nvdla_prototest_interface::Constant;
  }
  return data_filler_oneof_.const__;
}
inline ::nvdla_prototest_interface::Constant* DataFiller::release_const_() {
  if (has_const_()) {
    clear_has_data_filler_oneof();
    ::nvdla_prototest_interface::Constant* temp = data_filler_oneof_.const__;
    data_filler_oneof_.const__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DataFiller::set_allocated_const_(::nvdla_prototest_interface::Constant* const_) {
  clear_data_filler_oneof();
  if (const_) {
    set_has_const_();
    data_filler_oneof_.const__ = const_;
  }
}

inline bool DataFiller::has_data_filler_oneof() {
  return data_filler_oneof_case() != DATA_FILLER_ONEOF_NOT_SET;
}
inline void DataFiller::clear_has_data_filler_oneof() {
  _oneof_case_[0] = DATA_FILLER_ONEOF_NOT_SET;
}
inline DataFiller::DataFillerOneofCase DataFiller::data_filler_oneof_case() const {
  return DataFiller::DataFillerOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LUTParam

// repeated int32 linear_exp_table = 1 [packed = true];
inline int LUTParam::linear_exp_table_size() const {
  return linear_exp_table_.size();
}
inline void LUTParam::clear_linear_exp_table() {
  linear_exp_table_.Clear();
}
inline ::google::protobuf::int32 LUTParam::linear_exp_table(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.linear_exp_table)
  return linear_exp_table_.Get(index);
}
inline void LUTParam::set_linear_exp_table(int index, ::google::protobuf::int32 value) {
  linear_exp_table_.Set(index, value);
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.LUTParam.linear_exp_table)
}
inline void LUTParam::add_linear_exp_table(::google::protobuf::int32 value) {
  linear_exp_table_.Add(value);
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.LUTParam.linear_exp_table)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LUTParam::linear_exp_table() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.LUTParam.linear_exp_table)
  return linear_exp_table_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LUTParam::mutable_linear_exp_table() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.LUTParam.linear_exp_table)
  return &linear_exp_table_;
}

// repeated int32 linear_only_table = 2 [packed = true];
inline int LUTParam::linear_only_table_size() const {
  return linear_only_table_.size();
}
inline void LUTParam::clear_linear_only_table() {
  linear_only_table_.Clear();
}
inline ::google::protobuf::int32 LUTParam::linear_only_table(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.linear_only_table)
  return linear_only_table_.Get(index);
}
inline void LUTParam::set_linear_only_table(int index, ::google::protobuf::int32 value) {
  linear_only_table_.Set(index, value);
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.LUTParam.linear_only_table)
}
inline void LUTParam::add_linear_only_table(::google::protobuf::int32 value) {
  linear_only_table_.Add(value);
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.LUTParam.linear_only_table)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LUTParam::linear_only_table() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.LUTParam.linear_only_table)
  return linear_only_table_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LUTParam::mutable_linear_only_table() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.LUTParam.linear_only_table)
  return &linear_only_table_;
}

// required .nvdla_prototest_interface.LUTOffset linear_exp_offset = 3;
inline bool LUTParam::has_linear_exp_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LUTParam::set_has_linear_exp_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LUTParam::clear_has_linear_exp_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LUTParam::clear_linear_exp_offset() {
  if (linear_exp_offset_ != NULL) linear_exp_offset_->::nvdla_prototest_interface::LUTOffset::Clear();
  clear_has_linear_exp_offset();
}
inline const ::nvdla_prototest_interface::LUTOffset& LUTParam::linear_exp_offset() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.linear_exp_offset)
  return linear_exp_offset_ != NULL ? *linear_exp_offset_ : *default_instance_->linear_exp_offset_;
}
inline ::nvdla_prototest_interface::LUTOffset* LUTParam::mutable_linear_exp_offset() {
  set_has_linear_exp_offset();
  if (linear_exp_offset_ == NULL) linear_exp_offset_ = new ::nvdla_prototest_interface::LUTOffset;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.LUTParam.linear_exp_offset)
  return linear_exp_offset_;
}
inline ::nvdla_prototest_interface::LUTOffset* LUTParam::release_linear_exp_offset() {
  clear_has_linear_exp_offset();
  ::nvdla_prototest_interface::LUTOffset* temp = linear_exp_offset_;
  linear_exp_offset_ = NULL;
  return temp;
}
inline void LUTParam::set_allocated_linear_exp_offset(::nvdla_prototest_interface::LUTOffset* linear_exp_offset) {
  delete linear_exp_offset_;
  linear_exp_offset_ = linear_exp_offset;
  if (linear_exp_offset) {
    set_has_linear_exp_offset();
  } else {
    clear_has_linear_exp_offset();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.LUTParam.linear_exp_offset)
}

// required .nvdla_prototest_interface.LUTOffset linear_only_offset = 4;
inline bool LUTParam::has_linear_only_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LUTParam::set_has_linear_only_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LUTParam::clear_has_linear_only_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LUTParam::clear_linear_only_offset() {
  if (linear_only_offset_ != NULL) linear_only_offset_->::nvdla_prototest_interface::LUTOffset::Clear();
  clear_has_linear_only_offset();
}
inline const ::nvdla_prototest_interface::LUTOffset& LUTParam::linear_only_offset() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.linear_only_offset)
  return linear_only_offset_ != NULL ? *linear_only_offset_ : *default_instance_->linear_only_offset_;
}
inline ::nvdla_prototest_interface::LUTOffset* LUTParam::mutable_linear_only_offset() {
  set_has_linear_only_offset();
  if (linear_only_offset_ == NULL) linear_only_offset_ = new ::nvdla_prototest_interface::LUTOffset;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.LUTParam.linear_only_offset)
  return linear_only_offset_;
}
inline ::nvdla_prototest_interface::LUTOffset* LUTParam::release_linear_only_offset() {
  clear_has_linear_only_offset();
  ::nvdla_prototest_interface::LUTOffset* temp = linear_only_offset_;
  linear_only_offset_ = NULL;
  return temp;
}
inline void LUTParam::set_allocated_linear_only_offset(::nvdla_prototest_interface::LUTOffset* linear_only_offset) {
  delete linear_only_offset_;
  linear_only_offset_ = linear_only_offset;
  if (linear_only_offset) {
    set_has_linear_only_offset();
  } else {
    clear_has_linear_only_offset();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.LUTParam.linear_only_offset)
}

// required uint64 linear_exp_start = 5;
inline bool LUTParam::has_linear_exp_start() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LUTParam::set_has_linear_exp_start() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LUTParam::clear_has_linear_exp_start() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LUTParam::clear_linear_exp_start() {
  linear_exp_start_ = GOOGLE_ULONGLONG(0);
  clear_has_linear_exp_start();
}
inline ::google::protobuf::uint64 LUTParam::linear_exp_start() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.linear_exp_start)
  return linear_exp_start_;
}
inline void LUTParam::set_linear_exp_start(::google::protobuf::uint64 value) {
  set_has_linear_exp_start();
  linear_exp_start_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.LUTParam.linear_exp_start)
}

// required uint64 linear_exp_end = 6;
inline bool LUTParam::has_linear_exp_end() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LUTParam::set_has_linear_exp_end() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LUTParam::clear_has_linear_exp_end() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LUTParam::clear_linear_exp_end() {
  linear_exp_end_ = GOOGLE_ULONGLONG(0);
  clear_has_linear_exp_end();
}
inline ::google::protobuf::uint64 LUTParam::linear_exp_end() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.linear_exp_end)
  return linear_exp_end_;
}
inline void LUTParam::set_linear_exp_end(::google::protobuf::uint64 value) {
  set_has_linear_exp_end();
  linear_exp_end_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.LUTParam.linear_exp_end)
}

// required uint64 linear_only_start = 7;
inline bool LUTParam::has_linear_only_start() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LUTParam::set_has_linear_only_start() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LUTParam::clear_has_linear_only_start() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LUTParam::clear_linear_only_start() {
  linear_only_start_ = GOOGLE_ULONGLONG(0);
  clear_has_linear_only_start();
}
inline ::google::protobuf::uint64 LUTParam::linear_only_start() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.linear_only_start)
  return linear_only_start_;
}
inline void LUTParam::set_linear_only_start(::google::protobuf::uint64 value) {
  set_has_linear_only_start();
  linear_only_start_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.LUTParam.linear_only_start)
}

// required uint64 linear_only_end = 8;
inline bool LUTParam::has_linear_only_end() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LUTParam::set_has_linear_only_end() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LUTParam::clear_has_linear_only_end() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LUTParam::clear_linear_only_end() {
  linear_only_end_ = GOOGLE_ULONGLONG(0);
  clear_has_linear_only_end();
}
inline ::google::protobuf::uint64 LUTParam::linear_only_end() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.linear_only_end)
  return linear_only_end_;
}
inline void LUTParam::set_linear_only_end(::google::protobuf::uint64 value) {
  set_has_linear_only_end();
  linear_only_end_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.LUTParam.linear_only_end)
}

// required .nvdla_prototest_interface.DLASlope linear_exp_underflow_slope = 9;
inline bool LUTParam::has_linear_exp_underflow_slope() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LUTParam::set_has_linear_exp_underflow_slope() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LUTParam::clear_has_linear_exp_underflow_slope() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LUTParam::clear_linear_exp_underflow_slope() {
  if (linear_exp_underflow_slope_ != NULL) linear_exp_underflow_slope_->::nvdla_prototest_interface::DLASlope::Clear();
  clear_has_linear_exp_underflow_slope();
}
inline const ::nvdla_prototest_interface::DLASlope& LUTParam::linear_exp_underflow_slope() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.linear_exp_underflow_slope)
  return linear_exp_underflow_slope_ != NULL ? *linear_exp_underflow_slope_ : *default_instance_->linear_exp_underflow_slope_;
}
inline ::nvdla_prototest_interface::DLASlope* LUTParam::mutable_linear_exp_underflow_slope() {
  set_has_linear_exp_underflow_slope();
  if (linear_exp_underflow_slope_ == NULL) linear_exp_underflow_slope_ = new ::nvdla_prototest_interface::DLASlope;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.LUTParam.linear_exp_underflow_slope)
  return linear_exp_underflow_slope_;
}
inline ::nvdla_prototest_interface::DLASlope* LUTParam::release_linear_exp_underflow_slope() {
  clear_has_linear_exp_underflow_slope();
  ::nvdla_prototest_interface::DLASlope* temp = linear_exp_underflow_slope_;
  linear_exp_underflow_slope_ = NULL;
  return temp;
}
inline void LUTParam::set_allocated_linear_exp_underflow_slope(::nvdla_prototest_interface::DLASlope* linear_exp_underflow_slope) {
  delete linear_exp_underflow_slope_;
  linear_exp_underflow_slope_ = linear_exp_underflow_slope;
  if (linear_exp_underflow_slope) {
    set_has_linear_exp_underflow_slope();
  } else {
    clear_has_linear_exp_underflow_slope();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.LUTParam.linear_exp_underflow_slope)
}

// required .nvdla_prototest_interface.DLASlope linear_exp_overflow_slope = 10;
inline bool LUTParam::has_linear_exp_overflow_slope() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LUTParam::set_has_linear_exp_overflow_slope() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LUTParam::clear_has_linear_exp_overflow_slope() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LUTParam::clear_linear_exp_overflow_slope() {
  if (linear_exp_overflow_slope_ != NULL) linear_exp_overflow_slope_->::nvdla_prototest_interface::DLASlope::Clear();
  clear_has_linear_exp_overflow_slope();
}
inline const ::nvdla_prototest_interface::DLASlope& LUTParam::linear_exp_overflow_slope() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.linear_exp_overflow_slope)
  return linear_exp_overflow_slope_ != NULL ? *linear_exp_overflow_slope_ : *default_instance_->linear_exp_overflow_slope_;
}
inline ::nvdla_prototest_interface::DLASlope* LUTParam::mutable_linear_exp_overflow_slope() {
  set_has_linear_exp_overflow_slope();
  if (linear_exp_overflow_slope_ == NULL) linear_exp_overflow_slope_ = new ::nvdla_prototest_interface::DLASlope;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.LUTParam.linear_exp_overflow_slope)
  return linear_exp_overflow_slope_;
}
inline ::nvdla_prototest_interface::DLASlope* LUTParam::release_linear_exp_overflow_slope() {
  clear_has_linear_exp_overflow_slope();
  ::nvdla_prototest_interface::DLASlope* temp = linear_exp_overflow_slope_;
  linear_exp_overflow_slope_ = NULL;
  return temp;
}
inline void LUTParam::set_allocated_linear_exp_overflow_slope(::nvdla_prototest_interface::DLASlope* linear_exp_overflow_slope) {
  delete linear_exp_overflow_slope_;
  linear_exp_overflow_slope_ = linear_exp_overflow_slope;
  if (linear_exp_overflow_slope) {
    set_has_linear_exp_overflow_slope();
  } else {
    clear_has_linear_exp_overflow_slope();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.LUTParam.linear_exp_overflow_slope)
}

// required .nvdla_prototest_interface.DLASlope linear_only_underflow_slope = 11;
inline bool LUTParam::has_linear_only_underflow_slope() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LUTParam::set_has_linear_only_underflow_slope() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LUTParam::clear_has_linear_only_underflow_slope() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LUTParam::clear_linear_only_underflow_slope() {
  if (linear_only_underflow_slope_ != NULL) linear_only_underflow_slope_->::nvdla_prototest_interface::DLASlope::Clear();
  clear_has_linear_only_underflow_slope();
}
inline const ::nvdla_prototest_interface::DLASlope& LUTParam::linear_only_underflow_slope() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.linear_only_underflow_slope)
  return linear_only_underflow_slope_ != NULL ? *linear_only_underflow_slope_ : *default_instance_->linear_only_underflow_slope_;
}
inline ::nvdla_prototest_interface::DLASlope* LUTParam::mutable_linear_only_underflow_slope() {
  set_has_linear_only_underflow_slope();
  if (linear_only_underflow_slope_ == NULL) linear_only_underflow_slope_ = new ::nvdla_prototest_interface::DLASlope;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.LUTParam.linear_only_underflow_slope)
  return linear_only_underflow_slope_;
}
inline ::nvdla_prototest_interface::DLASlope* LUTParam::release_linear_only_underflow_slope() {
  clear_has_linear_only_underflow_slope();
  ::nvdla_prototest_interface::DLASlope* temp = linear_only_underflow_slope_;
  linear_only_underflow_slope_ = NULL;
  return temp;
}
inline void LUTParam::set_allocated_linear_only_underflow_slope(::nvdla_prototest_interface::DLASlope* linear_only_underflow_slope) {
  delete linear_only_underflow_slope_;
  linear_only_underflow_slope_ = linear_only_underflow_slope;
  if (linear_only_underflow_slope) {
    set_has_linear_only_underflow_slope();
  } else {
    clear_has_linear_only_underflow_slope();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.LUTParam.linear_only_underflow_slope)
}

// required .nvdla_prototest_interface.DLASlope linear_only_overflow_slope = 12;
inline bool LUTParam::has_linear_only_overflow_slope() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LUTParam::set_has_linear_only_overflow_slope() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LUTParam::clear_has_linear_only_overflow_slope() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LUTParam::clear_linear_only_overflow_slope() {
  if (linear_only_overflow_slope_ != NULL) linear_only_overflow_slope_->::nvdla_prototest_interface::DLASlope::Clear();
  clear_has_linear_only_overflow_slope();
}
inline const ::nvdla_prototest_interface::DLASlope& LUTParam::linear_only_overflow_slope() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.linear_only_overflow_slope)
  return linear_only_overflow_slope_ != NULL ? *linear_only_overflow_slope_ : *default_instance_->linear_only_overflow_slope_;
}
inline ::nvdla_prototest_interface::DLASlope* LUTParam::mutable_linear_only_overflow_slope() {
  set_has_linear_only_overflow_slope();
  if (linear_only_overflow_slope_ == NULL) linear_only_overflow_slope_ = new ::nvdla_prototest_interface::DLASlope;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.LUTParam.linear_only_overflow_slope)
  return linear_only_overflow_slope_;
}
inline ::nvdla_prototest_interface::DLASlope* LUTParam::release_linear_only_overflow_slope() {
  clear_has_linear_only_overflow_slope();
  ::nvdla_prototest_interface::DLASlope* temp = linear_only_overflow_slope_;
  linear_only_overflow_slope_ = NULL;
  return temp;
}
inline void LUTParam::set_allocated_linear_only_overflow_slope(::nvdla_prototest_interface::DLASlope* linear_only_overflow_slope) {
  delete linear_only_overflow_slope_;
  linear_only_overflow_slope_ = linear_only_overflow_slope;
  if (linear_only_overflow_slope) {
    set_has_linear_only_overflow_slope();
  } else {
    clear_has_linear_only_overflow_slope();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.LUTParam.linear_only_overflow_slope)
}

// required uint32 hybrid_priority = 13;
inline bool LUTParam::has_hybrid_priority() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LUTParam::set_has_hybrid_priority() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LUTParam::clear_has_hybrid_priority() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LUTParam::clear_hybrid_priority() {
  hybrid_priority_ = 0u;
  clear_has_hybrid_priority();
}
inline ::google::protobuf::uint32 LUTParam::hybrid_priority() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.hybrid_priority)
  return hybrid_priority_;
}
inline void LUTParam::set_hybrid_priority(::google::protobuf::uint32 value) {
  set_has_hybrid_priority();
  hybrid_priority_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.LUTParam.hybrid_priority)
}

// required uint32 underflow_priority = 14;
inline bool LUTParam::has_underflow_priority() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LUTParam::set_has_underflow_priority() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LUTParam::clear_has_underflow_priority() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LUTParam::clear_underflow_priority() {
  underflow_priority_ = 0u;
  clear_has_underflow_priority();
}
inline ::google::protobuf::uint32 LUTParam::underflow_priority() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.underflow_priority)
  return underflow_priority_;
}
inline void LUTParam::set_underflow_priority(::google::protobuf::uint32 value) {
  set_has_underflow_priority();
  underflow_priority_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.LUTParam.underflow_priority)
}

// required uint32 overflow_priority = 15;
inline bool LUTParam::has_overflow_priority() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LUTParam::set_has_overflow_priority() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LUTParam::clear_has_overflow_priority() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LUTParam::clear_overflow_priority() {
  overflow_priority_ = 0u;
  clear_has_overflow_priority();
}
inline ::google::protobuf::uint32 LUTParam::overflow_priority() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.overflow_priority)
  return overflow_priority_;
}
inline void LUTParam::set_overflow_priority(::google::protobuf::uint32 value) {
  set_has_overflow_priority();
  overflow_priority_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.LUTParam.overflow_priority)
}

// required .nvdla_prototest_interface.LUTMethod method = 16;
inline bool LUTParam::has_method() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LUTParam::set_has_method() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LUTParam::clear_has_method() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LUTParam::clear_method() {
  method_ = 0;
  clear_has_method();
}
inline ::nvdla_prototest_interface::LUTMethod LUTParam::method() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.method)
  return static_cast< ::nvdla_prototest_interface::LUTMethod >(method_);
}
inline void LUTParam::set_method(::nvdla_prototest_interface::LUTMethod value) {
  assert(::nvdla_prototest_interface::LUTMethod_IsValid(value));
  set_has_method();
  method_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.LUTParam.method)
}

// optional .nvdla_prototest_interface.FillerType fill_type = 17 [default = FILL_NONE];
inline bool LUTParam::has_fill_type() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LUTParam::set_has_fill_type() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LUTParam::clear_has_fill_type() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LUTParam::clear_fill_type() {
  fill_type_ = 0;
  clear_has_fill_type();
}
inline ::nvdla_prototest_interface::FillerType LUTParam::fill_type() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.fill_type)
  return static_cast< ::nvdla_prototest_interface::FillerType >(fill_type_);
}
inline void LUTParam::set_fill_type(::nvdla_prototest_interface::FillerType value) {
  assert(::nvdla_prototest_interface::FillerType_IsValid(value));
  set_has_fill_type();
  fill_type_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.LUTParam.fill_type)
}

// optional .nvdla_prototest_interface.DataFiller filler = 18;
inline bool LUTParam::has_filler() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LUTParam::set_has_filler() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LUTParam::clear_has_filler() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LUTParam::clear_filler() {
  if (filler_ != NULL) filler_->::nvdla_prototest_interface::DataFiller::Clear();
  clear_has_filler();
}
inline const ::nvdla_prototest_interface::DataFiller& LUTParam::filler() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.filler)
  return filler_ != NULL ? *filler_ : *default_instance_->filler_;
}
inline ::nvdla_prototest_interface::DataFiller* LUTParam::mutable_filler() {
  set_has_filler();
  if (filler_ == NULL) filler_ = new ::nvdla_prototest_interface::DataFiller;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.LUTParam.filler)
  return filler_;
}
inline ::nvdla_prototest_interface::DataFiller* LUTParam::release_filler() {
  clear_has_filler();
  ::nvdla_prototest_interface::DataFiller* temp = filler_;
  filler_ = NULL;
  return temp;
}
inline void LUTParam::set_allocated_filler(::nvdla_prototest_interface::DataFiller* filler) {
  delete filler_;
  filler_ = filler;
  if (filler) {
    set_has_filler();
  } else {
    clear_has_filler();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.LUTParam.filler)
}

// optional .nvdla_prototest_interface.DataPrecision precision = 19 [default = PRECISION_INT16];
inline bool LUTParam::has_precision() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LUTParam::set_has_precision() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LUTParam::clear_has_precision() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LUTParam::clear_precision() {
  precision_ = 1;
  clear_has_precision();
}
inline ::nvdla_prototest_interface::DataPrecision LUTParam::precision() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParam.precision)
  return static_cast< ::nvdla_prototest_interface::DataPrecision >(precision_);
}
inline void LUTParam::set_precision(::nvdla_prototest_interface::DataPrecision value) {
  assert(::nvdla_prototest_interface::DataPrecision_IsValid(value));
  set_has_precision();
  precision_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.LUTParam.precision)
}

// -------------------------------------------------------------------

// BDMATransferDesc

// required int32 source_address = 1;
inline bool BDMATransferDesc::has_source_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BDMATransferDesc::set_has_source_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BDMATransferDesc::clear_has_source_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BDMATransferDesc::clear_source_address() {
  source_address_ = 0;
  clear_has_source_address();
}
inline ::google::protobuf::int32 BDMATransferDesc::source_address() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMATransferDesc.source_address)
  return source_address_;
}
inline void BDMATransferDesc::set_source_address(::google::protobuf::int32 value) {
  set_has_source_address();
  source_address_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMATransferDesc.source_address)
}

// required int32 destination_address = 2;
inline bool BDMATransferDesc::has_destination_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BDMATransferDesc::set_has_destination_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BDMATransferDesc::clear_has_destination_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BDMATransferDesc::clear_destination_address() {
  destination_address_ = 0;
  clear_has_destination_address();
}
inline ::google::protobuf::int32 BDMATransferDesc::destination_address() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMATransferDesc.destination_address)
  return destination_address_;
}
inline void BDMATransferDesc::set_destination_address(::google::protobuf::int32 value) {
  set_has_destination_address();
  destination_address_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMATransferDesc.destination_address)
}

// required uint32 line_size = 3;
inline bool BDMATransferDesc::has_line_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BDMATransferDesc::set_has_line_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BDMATransferDesc::clear_has_line_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BDMATransferDesc::clear_line_size() {
  line_size_ = 0u;
  clear_has_line_size();
}
inline ::google::protobuf::uint32 BDMATransferDesc::line_size() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMATransferDesc.line_size)
  return line_size_;
}
inline void BDMATransferDesc::set_line_size(::google::protobuf::uint32 value) {
  set_has_line_size();
  line_size_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMATransferDesc.line_size)
}

// required uint32 line_repeat = 4;
inline bool BDMATransferDesc::has_line_repeat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BDMATransferDesc::set_has_line_repeat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BDMATransferDesc::clear_has_line_repeat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BDMATransferDesc::clear_line_repeat() {
  line_repeat_ = 0u;
  clear_has_line_repeat();
}
inline ::google::protobuf::uint32 BDMATransferDesc::line_repeat() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMATransferDesc.line_repeat)
  return line_repeat_;
}
inline void BDMATransferDesc::set_line_repeat(::google::protobuf::uint32 value) {
  set_has_line_repeat();
  line_repeat_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMATransferDesc.line_repeat)
}

// required uint32 source_line = 5;
inline bool BDMATransferDesc::has_source_line() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BDMATransferDesc::set_has_source_line() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BDMATransferDesc::clear_has_source_line() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BDMATransferDesc::clear_source_line() {
  source_line_ = 0u;
  clear_has_source_line();
}
inline ::google::protobuf::uint32 BDMATransferDesc::source_line() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMATransferDesc.source_line)
  return source_line_;
}
inline void BDMATransferDesc::set_source_line(::google::protobuf::uint32 value) {
  set_has_source_line();
  source_line_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMATransferDesc.source_line)
}

// required uint32 destination_line = 6;
inline bool BDMATransferDesc::has_destination_line() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BDMATransferDesc::set_has_destination_line() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BDMATransferDesc::clear_has_destination_line() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BDMATransferDesc::clear_destination_line() {
  destination_line_ = 0u;
  clear_has_destination_line();
}
inline ::google::protobuf::uint32 BDMATransferDesc::destination_line() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMATransferDesc.destination_line)
  return destination_line_;
}
inline void BDMATransferDesc::set_destination_line(::google::protobuf::uint32 value) {
  set_has_destination_line();
  destination_line_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMATransferDesc.destination_line)
}

// required uint32 surface_repeat = 7;
inline bool BDMATransferDesc::has_surface_repeat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BDMATransferDesc::set_has_surface_repeat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BDMATransferDesc::clear_has_surface_repeat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BDMATransferDesc::clear_surface_repeat() {
  surface_repeat_ = 0u;
  clear_has_surface_repeat();
}
inline ::google::protobuf::uint32 BDMATransferDesc::surface_repeat() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMATransferDesc.surface_repeat)
  return surface_repeat_;
}
inline void BDMATransferDesc::set_surface_repeat(::google::protobuf::uint32 value) {
  set_has_surface_repeat();
  surface_repeat_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMATransferDesc.surface_repeat)
}

// required uint32 source_surface = 8;
inline bool BDMATransferDesc::has_source_surface() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BDMATransferDesc::set_has_source_surface() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BDMATransferDesc::clear_has_source_surface() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BDMATransferDesc::clear_source_surface() {
  source_surface_ = 0u;
  clear_has_source_surface();
}
inline ::google::protobuf::uint32 BDMATransferDesc::source_surface() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMATransferDesc.source_surface)
  return source_surface_;
}
inline void BDMATransferDesc::set_source_surface(::google::protobuf::uint32 value) {
  set_has_source_surface();
  source_surface_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMATransferDesc.source_surface)
}

// required uint32 destination_surface = 9;
inline bool BDMATransferDesc::has_destination_surface() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BDMATransferDesc::set_has_destination_surface() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BDMATransferDesc::clear_has_destination_surface() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BDMATransferDesc::clear_destination_surface() {
  destination_surface_ = 0u;
  clear_has_destination_surface();
}
inline ::google::protobuf::uint32 BDMATransferDesc::destination_surface() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMATransferDesc.destination_surface)
  return destination_surface_;
}
inline void BDMATransferDesc::set_destination_surface(::google::protobuf::uint32 value) {
  set_has_destination_surface();
  destination_surface_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMATransferDesc.destination_surface)
}

// required .nvdla_prototest_interface.MemInfo src_mem_info = 10;
inline bool BDMATransferDesc::has_src_mem_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BDMATransferDesc::set_has_src_mem_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BDMATransferDesc::clear_has_src_mem_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BDMATransferDesc::clear_src_mem_info() {
  if (src_mem_info_ != NULL) src_mem_info_->::nvdla_prototest_interface::MemInfo::Clear();
  clear_has_src_mem_info();
}
inline const ::nvdla_prototest_interface::MemInfo& BDMATransferDesc::src_mem_info() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMATransferDesc.src_mem_info)
  return src_mem_info_ != NULL ? *src_mem_info_ : *default_instance_->src_mem_info_;
}
inline ::nvdla_prototest_interface::MemInfo* BDMATransferDesc::mutable_src_mem_info() {
  set_has_src_mem_info();
  if (src_mem_info_ == NULL) src_mem_info_ = new ::nvdla_prototest_interface::MemInfo;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.BDMATransferDesc.src_mem_info)
  return src_mem_info_;
}
inline ::nvdla_prototest_interface::MemInfo* BDMATransferDesc::release_src_mem_info() {
  clear_has_src_mem_info();
  ::nvdla_prototest_interface::MemInfo* temp = src_mem_info_;
  src_mem_info_ = NULL;
  return temp;
}
inline void BDMATransferDesc::set_allocated_src_mem_info(::nvdla_prototest_interface::MemInfo* src_mem_info) {
  delete src_mem_info_;
  src_mem_info_ = src_mem_info;
  if (src_mem_info) {
    set_has_src_mem_info();
  } else {
    clear_has_src_mem_info();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.BDMATransferDesc.src_mem_info)
}

// required .nvdla_prototest_interface.MemInfo dst_mem_info = 11;
inline bool BDMATransferDesc::has_dst_mem_info() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BDMATransferDesc::set_has_dst_mem_info() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BDMATransferDesc::clear_has_dst_mem_info() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BDMATransferDesc::clear_dst_mem_info() {
  if (dst_mem_info_ != NULL) dst_mem_info_->::nvdla_prototest_interface::MemInfo::Clear();
  clear_has_dst_mem_info();
}
inline const ::nvdla_prototest_interface::MemInfo& BDMATransferDesc::dst_mem_info() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMATransferDesc.dst_mem_info)
  return dst_mem_info_ != NULL ? *dst_mem_info_ : *default_instance_->dst_mem_info_;
}
inline ::nvdla_prototest_interface::MemInfo* BDMATransferDesc::mutable_dst_mem_info() {
  set_has_dst_mem_info();
  if (dst_mem_info_ == NULL) dst_mem_info_ = new ::nvdla_prototest_interface::MemInfo;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.BDMATransferDesc.dst_mem_info)
  return dst_mem_info_;
}
inline ::nvdla_prototest_interface::MemInfo* BDMATransferDesc::release_dst_mem_info() {
  clear_has_dst_mem_info();
  ::nvdla_prototest_interface::MemInfo* temp = dst_mem_info_;
  dst_mem_info_ = NULL;
  return temp;
}
inline void BDMATransferDesc::set_allocated_dst_mem_info(::nvdla_prototest_interface::MemInfo* dst_mem_info) {
  delete dst_mem_info_;
  dst_mem_info_ = dst_mem_info;
  if (dst_mem_info) {
    set_has_dst_mem_info();
  } else {
    clear_has_dst_mem_info();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.BDMATransferDesc.dst_mem_info)
}

// -------------------------------------------------------------------

// BDMASurfaceDesc

// required .nvdla_prototest_interface.MemType source_type = 1;
inline bool BDMASurfaceDesc::has_source_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BDMASurfaceDesc::set_has_source_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BDMASurfaceDesc::clear_has_source_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BDMASurfaceDesc::clear_source_type() {
  source_type_ = 0;
  clear_has_source_type();
}
inline ::nvdla_prototest_interface::MemType BDMASurfaceDesc::source_type() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMASurfaceDesc.source_type)
  return static_cast< ::nvdla_prototest_interface::MemType >(source_type_);
}
inline void BDMASurfaceDesc::set_source_type(::nvdla_prototest_interface::MemType value) {
  assert(::nvdla_prototest_interface::MemType_IsValid(value));
  set_has_source_type();
  source_type_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMASurfaceDesc.source_type)
}

// required .nvdla_prototest_interface.MemType destination_type = 2;
inline bool BDMASurfaceDesc::has_destination_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BDMASurfaceDesc::set_has_destination_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BDMASurfaceDesc::clear_has_destination_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BDMASurfaceDesc::clear_destination_type() {
  destination_type_ = 0;
  clear_has_destination_type();
}
inline ::nvdla_prototest_interface::MemType BDMASurfaceDesc::destination_type() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMASurfaceDesc.destination_type)
  return static_cast< ::nvdla_prototest_interface::MemType >(destination_type_);
}
inline void BDMASurfaceDesc::set_destination_type(::nvdla_prototest_interface::MemType value) {
  assert(::nvdla_prototest_interface::MemType_IsValid(value));
  set_has_destination_type();
  destination_type_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMASurfaceDesc.destination_type)
}

// required uint32 num_transfers = 3;
inline bool BDMASurfaceDesc::has_num_transfers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BDMASurfaceDesc::set_has_num_transfers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BDMASurfaceDesc::clear_has_num_transfers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BDMASurfaceDesc::clear_num_transfers() {
  num_transfers_ = 0u;
  clear_has_num_transfers();
}
inline ::google::protobuf::uint32 BDMASurfaceDesc::num_transfers() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMASurfaceDesc.num_transfers)
  return num_transfers_;
}
inline void BDMASurfaceDesc::set_num_transfers(::google::protobuf::uint32 value) {
  set_has_num_transfers();
  num_transfers_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMASurfaceDesc.num_transfers)
}

// repeated .nvdla_prototest_interface.BDMATransferDesc transfers = 4;
inline int BDMASurfaceDesc::transfers_size() const {
  return transfers_.size();
}
inline void BDMASurfaceDesc::clear_transfers() {
  transfers_.Clear();
}
inline const ::nvdla_prototest_interface::BDMATransferDesc& BDMASurfaceDesc::transfers(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMASurfaceDesc.transfers)
  return transfers_.Get(index);
}
inline ::nvdla_prototest_interface::BDMATransferDesc* BDMASurfaceDesc::mutable_transfers(int index) {
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.BDMASurfaceDesc.transfers)
  return transfers_.Mutable(index);
}
inline ::nvdla_prototest_interface::BDMATransferDesc* BDMASurfaceDesc::add_transfers() {
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.BDMASurfaceDesc.transfers)
  return transfers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::BDMATransferDesc >&
BDMASurfaceDesc::transfers() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.BDMASurfaceDesc.transfers)
  return transfers_;
}
inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::BDMATransferDesc >*
BDMASurfaceDesc::mutable_transfers() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.BDMASurfaceDesc.transfers)
  return &transfers_;
}

// -------------------------------------------------------------------

// BDMAOpDesc

// required uint32 num_transfers = 1;
inline bool BDMAOpDesc::has_num_transfers() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BDMAOpDesc::set_has_num_transfers() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BDMAOpDesc::clear_has_num_transfers() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BDMAOpDesc::clear_num_transfers() {
  num_transfers_ = 0u;
  clear_has_num_transfers();
}
inline ::google::protobuf::uint32 BDMAOpDesc::num_transfers() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMAOpDesc.num_transfers)
  return num_transfers_;
}
inline void BDMAOpDesc::set_num_transfers(::google::protobuf::uint32 value) {
  set_has_num_transfers();
  num_transfers_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMAOpDesc.num_transfers)
}

// optional uint32 reserved0 = 2 [default = 0];
inline bool BDMAOpDesc::has_reserved0() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BDMAOpDesc::set_has_reserved0() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BDMAOpDesc::clear_has_reserved0() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BDMAOpDesc::clear_reserved0() {
  reserved0_ = 0u;
  clear_has_reserved0();
}
inline ::google::protobuf::uint32 BDMAOpDesc::reserved0() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.BDMAOpDesc.reserved0)
  return reserved0_;
}
inline void BDMAOpDesc::set_reserved0(::google::protobuf::uint32 value) {
  set_has_reserved0();
  reserved0_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.BDMAOpDesc.reserved0)
}

// -------------------------------------------------------------------

// CVTParam

// required int32 scale = 1;
inline bool CVTParam::has_scale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CVTParam::set_has_scale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CVTParam::clear_has_scale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CVTParam::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline ::google::protobuf::int32 CVTParam::scale() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CVTParam.scale)
  return scale_;
}
inline void CVTParam::set_scale(::google::protobuf::int32 value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CVTParam.scale)
}

// required uint32 truncate = 2;
inline bool CVTParam::has_truncate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CVTParam::set_has_truncate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CVTParam::clear_has_truncate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CVTParam::clear_truncate() {
  truncate_ = 0u;
  clear_has_truncate();
}
inline ::google::protobuf::uint32 CVTParam::truncate() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CVTParam.truncate)
  return truncate_;
}
inline void CVTParam::set_truncate(::google::protobuf::uint32 value) {
  set_has_truncate();
  truncate_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CVTParam.truncate)
}

// required uint32 enable = 3;
inline bool CVTParam::has_enable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CVTParam::set_has_enable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CVTParam::clear_has_enable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CVTParam::clear_enable() {
  enable_ = 0u;
  clear_has_enable();
}
inline ::google::protobuf::uint32 CVTParam::enable() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CVTParam.enable)
  return enable_;
}
inline void CVTParam::set_enable(::google::protobuf::uint32 value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CVTParam.enable)
}

// required int32 offset = 4;
inline bool CVTParam::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CVTParam::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CVTParam::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CVTParam::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 CVTParam::offset() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CVTParam.offset)
  return offset_;
}
inline void CVTParam::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CVTParam.offset)
}

// -------------------------------------------------------------------

// MemInfo

// required int32 mem_id = 1 [default = -1];
inline bool MemInfo::has_mem_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemInfo::set_has_mem_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemInfo::clear_has_mem_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemInfo::clear_mem_id() {
  mem_id_ = -1;
  clear_has_mem_id();
}
inline ::google::protobuf::int32 MemInfo::mem_id() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.MemInfo.mem_id)
  return mem_id_;
}
inline void MemInfo::set_mem_id(::google::protobuf::int32 value) {
  set_has_mem_id();
  mem_id_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.MemInfo.mem_id)
}

// required uint32 mem_size = 2 [default = 0];
inline bool MemInfo::has_mem_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemInfo::set_has_mem_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemInfo::clear_has_mem_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemInfo::clear_mem_size() {
  mem_size_ = 0u;
  clear_has_mem_size();
}
inline ::google::protobuf::uint32 MemInfo::mem_size() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.MemInfo.mem_size)
  return mem_size_;
}
inline void MemInfo::set_mem_size(::google::protobuf::uint32 value) {
  set_has_mem_size();
  mem_size_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.MemInfo.mem_size)
}

// required uint32 offset = 3 [default = 0];
inline bool MemInfo::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemInfo::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemInfo::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemInfo::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 MemInfo::offset() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.MemInfo.offset)
  return offset_;
}
inline void MemInfo::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.MemInfo.offset)
}

// optional .nvdla_prototest_interface.FillerType fill_type = 4 [default = FILL_NONE];
inline bool MemInfo::has_fill_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemInfo::set_has_fill_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemInfo::clear_has_fill_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemInfo::clear_fill_type() {
  fill_type_ = 0;
  clear_has_fill_type();
}
inline ::nvdla_prototest_interface::FillerType MemInfo::fill_type() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.MemInfo.fill_type)
  return static_cast< ::nvdla_prototest_interface::FillerType >(fill_type_);
}
inline void MemInfo::set_fill_type(::nvdla_prototest_interface::FillerType value) {
  assert(::nvdla_prototest_interface::FillerType_IsValid(value));
  set_has_fill_type();
  fill_type_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.MemInfo.fill_type)
}

// optional .nvdla_prototest_interface.DataFiller filler = 5;
inline bool MemInfo::has_filler() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MemInfo::set_has_filler() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MemInfo::clear_has_filler() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MemInfo::clear_filler() {
  if (filler_ != NULL) filler_->::nvdla_prototest_interface::DataFiller::Clear();
  clear_has_filler();
}
inline const ::nvdla_prototest_interface::DataFiller& MemInfo::filler() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.MemInfo.filler)
  return filler_ != NULL ? *filler_ : *default_instance_->filler_;
}
inline ::nvdla_prototest_interface::DataFiller* MemInfo::mutable_filler() {
  set_has_filler();
  if (filler_ == NULL) filler_ = new ::nvdla_prototest_interface::DataFiller;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.MemInfo.filler)
  return filler_;
}
inline ::nvdla_prototest_interface::DataFiller* MemInfo::release_filler() {
  clear_has_filler();
  ::nvdla_prototest_interface::DataFiller* temp = filler_;
  filler_ = NULL;
  return temp;
}
inline void MemInfo::set_allocated_filler(::nvdla_prototest_interface::DataFiller* filler) {
  delete filler_;
  filler_ = filler;
  if (filler) {
    set_has_filler();
  } else {
    clear_has_filler();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.MemInfo.filler)
}

// optional .nvdla_prototest_interface.MemFlag flag = 6 [default = DLA_MEM_ALLOC];
inline bool MemInfo::has_flag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MemInfo::set_has_flag() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MemInfo::clear_has_flag() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MemInfo::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::nvdla_prototest_interface::MemFlag MemInfo::flag() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.MemInfo.flag)
  return static_cast< ::nvdla_prototest_interface::MemFlag >(flag_);
}
inline void MemInfo::set_flag(::nvdla_prototest_interface::MemFlag value) {
  assert(::nvdla_prototest_interface::MemFlag_IsValid(value));
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.MemInfo.flag)
}

// optional .nvdla_prototest_interface.DataPrecision precision = 7 [default = PRECISION_INT8];
inline bool MemInfo::has_precision() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MemInfo::set_has_precision() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MemInfo::clear_has_precision() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MemInfo::clear_precision() {
  precision_ = 0;
  clear_has_precision();
}
inline ::nvdla_prototest_interface::DataPrecision MemInfo::precision() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.MemInfo.precision)
  return static_cast< ::nvdla_prototest_interface::DataPrecision >(precision_);
}
inline void MemInfo::set_precision(::nvdla_prototest_interface::DataPrecision value) {
  assert(::nvdla_prototest_interface::DataPrecision_IsValid(value));
  set_has_precision();
  precision_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.MemInfo.precision)
}

// optional uint32 sw_dilation_x = 8 [default = 1];
inline bool MemInfo::has_sw_dilation_x() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MemInfo::set_has_sw_dilation_x() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MemInfo::clear_has_sw_dilation_x() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MemInfo::clear_sw_dilation_x() {
  sw_dilation_x_ = 1u;
  clear_has_sw_dilation_x();
}
inline ::google::protobuf::uint32 MemInfo::sw_dilation_x() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.MemInfo.sw_dilation_x)
  return sw_dilation_x_;
}
inline void MemInfo::set_sw_dilation_x(::google::protobuf::uint32 value) {
  set_has_sw_dilation_x();
  sw_dilation_x_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.MemInfo.sw_dilation_x)
}

// optional uint32 sw_dilation_y = 9 [default = 1];
inline bool MemInfo::has_sw_dilation_y() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MemInfo::set_has_sw_dilation_y() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MemInfo::clear_has_sw_dilation_y() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MemInfo::clear_sw_dilation_y() {
  sw_dilation_y_ = 1u;
  clear_has_sw_dilation_y();
}
inline ::google::protobuf::uint32 MemInfo::sw_dilation_y() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.MemInfo.sw_dilation_y)
  return sw_dilation_y_;
}
inline void MemInfo::set_sw_dilation_y(::google::protobuf::uint32 value) {
  set_has_sw_dilation_y();
  sw_dilation_y_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.MemInfo.sw_dilation_y)
}

// -------------------------------------------------------------------

// DataCube

// optional uint32 reserved0 = 1 [default = 0];
inline bool DataCube::has_reserved0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataCube::set_has_reserved0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataCube::clear_has_reserved0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataCube::clear_reserved0() {
  reserved0_ = 0u;
  clear_has_reserved0();
}
inline ::google::protobuf::uint32 DataCube::reserved0() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataCube.reserved0)
  return reserved0_;
}
inline void DataCube::set_reserved0(::google::protobuf::uint32 value) {
  set_has_reserved0();
  reserved0_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataCube.reserved0)
}

// required .nvdla_prototest_interface.MemType type = 2;
inline bool DataCube::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataCube::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataCube::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataCube::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::nvdla_prototest_interface::MemType DataCube::type() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataCube.type)
  return static_cast< ::nvdla_prototest_interface::MemType >(type_);
}
inline void DataCube::set_type(::nvdla_prototest_interface::MemType value) {
  assert(::nvdla_prototest_interface::MemType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataCube.type)
}

// required int32 address = 3;
inline bool DataCube::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataCube::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataCube::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataCube::clear_address() {
  address_ = 0;
  clear_has_address();
}
inline ::google::protobuf::int32 DataCube::address() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataCube.address)
  return address_;
}
inline void DataCube::set_address(::google::protobuf::int32 value) {
  set_has_address();
  address_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataCube.address)
}

// required uint32 size = 4;
inline bool DataCube::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataCube::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataCube::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataCube::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 DataCube::size() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataCube.size)
  return size_;
}
inline void DataCube::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataCube.size)
}

// required uint32 width = 5;
inline bool DataCube::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataCube::set_has_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataCube::clear_has_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataCube::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 DataCube::width() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataCube.width)
  return width_;
}
inline void DataCube::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataCube.width)
}

// required uint32 height = 6;
inline bool DataCube::has_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataCube::set_has_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataCube::clear_has_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataCube::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 DataCube::height() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataCube.height)
  return height_;
}
inline void DataCube::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataCube.height)
}

// required uint32 channel = 7;
inline bool DataCube::has_channel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataCube::set_has_channel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataCube::clear_has_channel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataCube::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 DataCube::channel() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataCube.channel)
  return channel_;
}
inline void DataCube::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataCube.channel)
}

// optional uint32 reserved1 = 8 [default = 0];
inline bool DataCube::has_reserved1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataCube::set_has_reserved1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataCube::clear_has_reserved1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataCube::clear_reserved1() {
  reserved1_ = 0u;
  clear_has_reserved1();
}
inline ::google::protobuf::uint32 DataCube::reserved1() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataCube.reserved1)
  return reserved1_;
}
inline void DataCube::set_reserved1(::google::protobuf::uint32 value) {
  set_has_reserved1();
  reserved1_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataCube.reserved1)
}

// required uint32 line_stride = 9;
inline bool DataCube::has_line_stride() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataCube::set_has_line_stride() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataCube::clear_has_line_stride() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataCube::clear_line_stride() {
  line_stride_ = 0u;
  clear_has_line_stride();
}
inline ::google::protobuf::uint32 DataCube::line_stride() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataCube.line_stride)
  return line_stride_;
}
inline void DataCube::set_line_stride(::google::protobuf::uint32 value) {
  set_has_line_stride();
  line_stride_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataCube.line_stride)
}

// required uint32 surf_stride = 10;
inline bool DataCube::has_surf_stride() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DataCube::set_has_surf_stride() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DataCube::clear_has_surf_stride() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DataCube::clear_surf_stride() {
  surf_stride_ = 0u;
  clear_has_surf_stride();
}
inline ::google::protobuf::uint32 DataCube::surf_stride() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataCube.surf_stride)
  return surf_stride_;
}
inline void DataCube::set_surf_stride(::google::protobuf::uint32 value) {
  set_has_surf_stride();
  surf_stride_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataCube.surf_stride)
}

// required uint32 plane_stride = 11;
inline bool DataCube::has_plane_stride() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DataCube::set_has_plane_stride() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DataCube::clear_has_plane_stride() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DataCube::clear_plane_stride() {
  plane_stride_ = 0u;
  clear_has_plane_stride();
}
inline ::google::protobuf::uint32 DataCube::plane_stride() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataCube.plane_stride)
  return plane_stride_;
}
inline void DataCube::set_plane_stride(::google::protobuf::uint32 value) {
  set_has_plane_stride();
  plane_stride_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.DataCube.plane_stride)
}

// required .nvdla_prototest_interface.MemInfo mem_info = 12;
inline bool DataCube::has_mem_info() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DataCube::set_has_mem_info() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DataCube::clear_has_mem_info() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DataCube::clear_mem_info() {
  if (mem_info_ != NULL) mem_info_->::nvdla_prototest_interface::MemInfo::Clear();
  clear_has_mem_info();
}
inline const ::nvdla_prototest_interface::MemInfo& DataCube::mem_info() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.DataCube.mem_info)
  return mem_info_ != NULL ? *mem_info_ : *default_instance_->mem_info_;
}
inline ::nvdla_prototest_interface::MemInfo* DataCube::mutable_mem_info() {
  set_has_mem_info();
  if (mem_info_ == NULL) mem_info_ = new ::nvdla_prototest_interface::MemInfo;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.DataCube.mem_info)
  return mem_info_;
}
inline ::nvdla_prototest_interface::MemInfo* DataCube::release_mem_info() {
  clear_has_mem_info();
  ::nvdla_prototest_interface::MemInfo* temp = mem_info_;
  mem_info_ = NULL;
  return temp;
}
inline void DataCube::set_allocated_mem_info(::nvdla_prototest_interface::MemInfo* mem_info) {
  delete mem_info_;
  mem_info_ = mem_info;
  if (mem_info) {
    set_has_mem_info();
  } else {
    clear_has_mem_info();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.DataCube.mem_info)
}

// -------------------------------------------------------------------

// CONVSurfaceDesc

// required .nvdla_prototest_interface.DataCube weight_data = 1;
inline bool CONVSurfaceDesc::has_weight_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CONVSurfaceDesc::set_has_weight_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CONVSurfaceDesc::clear_has_weight_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CONVSurfaceDesc::clear_weight_data() {
  if (weight_data_ != NULL) weight_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_weight_data();
}
inline const ::nvdla_prototest_interface::DataCube& CONVSurfaceDesc::weight_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVSurfaceDesc.weight_data)
  return weight_data_ != NULL ? *weight_data_ : *default_instance_->weight_data_;
}
inline ::nvdla_prototest_interface::DataCube* CONVSurfaceDesc::mutable_weight_data() {
  set_has_weight_data();
  if (weight_data_ == NULL) weight_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.CONVSurfaceDesc.weight_data)
  return weight_data_;
}
inline ::nvdla_prototest_interface::DataCube* CONVSurfaceDesc::release_weight_data() {
  clear_has_weight_data();
  ::nvdla_prototest_interface::DataCube* temp = weight_data_;
  weight_data_ = NULL;
  return temp;
}
inline void CONVSurfaceDesc::set_allocated_weight_data(::nvdla_prototest_interface::DataCube* weight_data) {
  delete weight_data_;
  weight_data_ = weight_data;
  if (weight_data) {
    set_has_weight_data();
  } else {
    clear_has_weight_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.CONVSurfaceDesc.weight_data)
}

// optional .nvdla_prototest_interface.DataCube wmb_data = 2;
inline bool CONVSurfaceDesc::has_wmb_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CONVSurfaceDesc::set_has_wmb_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CONVSurfaceDesc::clear_has_wmb_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CONVSurfaceDesc::clear_wmb_data() {
  if (wmb_data_ != NULL) wmb_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_wmb_data();
}
inline const ::nvdla_prototest_interface::DataCube& CONVSurfaceDesc::wmb_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVSurfaceDesc.wmb_data)
  return wmb_data_ != NULL ? *wmb_data_ : *default_instance_->wmb_data_;
}
inline ::nvdla_prototest_interface::DataCube* CONVSurfaceDesc::mutable_wmb_data() {
  set_has_wmb_data();
  if (wmb_data_ == NULL) wmb_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.CONVSurfaceDesc.wmb_data)
  return wmb_data_;
}
inline ::nvdla_prototest_interface::DataCube* CONVSurfaceDesc::release_wmb_data() {
  clear_has_wmb_data();
  ::nvdla_prototest_interface::DataCube* temp = wmb_data_;
  wmb_data_ = NULL;
  return temp;
}
inline void CONVSurfaceDesc::set_allocated_wmb_data(::nvdla_prototest_interface::DataCube* wmb_data) {
  delete wmb_data_;
  wmb_data_ = wmb_data;
  if (wmb_data) {
    set_has_wmb_data();
  } else {
    clear_has_wmb_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.CONVSurfaceDesc.wmb_data)
}

// optional .nvdla_prototest_interface.DataCube wgs_data = 3;
inline bool CONVSurfaceDesc::has_wgs_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CONVSurfaceDesc::set_has_wgs_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CONVSurfaceDesc::clear_has_wgs_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CONVSurfaceDesc::clear_wgs_data() {
  if (wgs_data_ != NULL) wgs_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_wgs_data();
}
inline const ::nvdla_prototest_interface::DataCube& CONVSurfaceDesc::wgs_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVSurfaceDesc.wgs_data)
  return wgs_data_ != NULL ? *wgs_data_ : *default_instance_->wgs_data_;
}
inline ::nvdla_prototest_interface::DataCube* CONVSurfaceDesc::mutable_wgs_data() {
  set_has_wgs_data();
  if (wgs_data_ == NULL) wgs_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.CONVSurfaceDesc.wgs_data)
  return wgs_data_;
}
inline ::nvdla_prototest_interface::DataCube* CONVSurfaceDesc::release_wgs_data() {
  clear_has_wgs_data();
  ::nvdla_prototest_interface::DataCube* temp = wgs_data_;
  wgs_data_ = NULL;
  return temp;
}
inline void CONVSurfaceDesc::set_allocated_wgs_data(::nvdla_prototest_interface::DataCube* wgs_data) {
  delete wgs_data_;
  wgs_data_ = wgs_data;
  if (wgs_data) {
    set_has_wgs_data();
  } else {
    clear_has_wgs_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.CONVSurfaceDesc.wgs_data)
}

// required .nvdla_prototest_interface.DataCube src_data = 4;
inline bool CONVSurfaceDesc::has_src_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CONVSurfaceDesc::set_has_src_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CONVSurfaceDesc::clear_has_src_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CONVSurfaceDesc::clear_src_data() {
  if (src_data_ != NULL) src_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_src_data();
}
inline const ::nvdla_prototest_interface::DataCube& CONVSurfaceDesc::src_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVSurfaceDesc.src_data)
  return src_data_ != NULL ? *src_data_ : *default_instance_->src_data_;
}
inline ::nvdla_prototest_interface::DataCube* CONVSurfaceDesc::mutable_src_data() {
  set_has_src_data();
  if (src_data_ == NULL) src_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.CONVSurfaceDesc.src_data)
  return src_data_;
}
inline ::nvdla_prototest_interface::DataCube* CONVSurfaceDesc::release_src_data() {
  clear_has_src_data();
  ::nvdla_prototest_interface::DataCube* temp = src_data_;
  src_data_ = NULL;
  return temp;
}
inline void CONVSurfaceDesc::set_allocated_src_data(::nvdla_prototest_interface::DataCube* src_data) {
  delete src_data_;
  src_data_ = src_data;
  if (src_data) {
    set_has_src_data();
  } else {
    clear_has_src_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.CONVSurfaceDesc.src_data)
}

// required .nvdla_prototest_interface.DataCube dst_data = 5;
inline bool CONVSurfaceDesc::has_dst_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CONVSurfaceDesc::set_has_dst_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CONVSurfaceDesc::clear_has_dst_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CONVSurfaceDesc::clear_dst_data() {
  if (dst_data_ != NULL) dst_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_dst_data();
}
inline const ::nvdla_prototest_interface::DataCube& CONVSurfaceDesc::dst_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVSurfaceDesc.dst_data)
  return dst_data_ != NULL ? *dst_data_ : *default_instance_->dst_data_;
}
inline ::nvdla_prototest_interface::DataCube* CONVSurfaceDesc::mutable_dst_data() {
  set_has_dst_data();
  if (dst_data_ == NULL) dst_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.CONVSurfaceDesc.dst_data)
  return dst_data_;
}
inline ::nvdla_prototest_interface::DataCube* CONVSurfaceDesc::release_dst_data() {
  clear_has_dst_data();
  ::nvdla_prototest_interface::DataCube* temp = dst_data_;
  dst_data_ = NULL;
  return temp;
}
inline void CONVSurfaceDesc::set_allocated_dst_data(::nvdla_prototest_interface::DataCube* dst_data) {
  delete dst_data_;
  dst_data_ = dst_data;
  if (dst_data) {
    set_has_dst_data();
  } else {
    clear_has_dst_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.CONVSurfaceDesc.dst_data)
}

// required int64 offset_u = 6;
inline bool CONVSurfaceDesc::has_offset_u() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CONVSurfaceDesc::set_has_offset_u() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CONVSurfaceDesc::clear_has_offset_u() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CONVSurfaceDesc::clear_offset_u() {
  offset_u_ = GOOGLE_LONGLONG(0);
  clear_has_offset_u();
}
inline ::google::protobuf::int64 CONVSurfaceDesc::offset_u() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVSurfaceDesc.offset_u)
  return offset_u_;
}
inline void CONVSurfaceDesc::set_offset_u(::google::protobuf::int64 value) {
  set_has_offset_u();
  offset_u_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVSurfaceDesc.offset_u)
}

// required uint32 in_line_uv_stride = 7;
inline bool CONVSurfaceDesc::has_in_line_uv_stride() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CONVSurfaceDesc::set_has_in_line_uv_stride() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CONVSurfaceDesc::clear_has_in_line_uv_stride() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CONVSurfaceDesc::clear_in_line_uv_stride() {
  in_line_uv_stride_ = 0u;
  clear_has_in_line_uv_stride();
}
inline ::google::protobuf::uint32 CONVSurfaceDesc::in_line_uv_stride() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVSurfaceDesc.in_line_uv_stride)
  return in_line_uv_stride_;
}
inline void CONVSurfaceDesc::set_in_line_uv_stride(::google::protobuf::uint32 value) {
  set_has_in_line_uv_stride();
  in_line_uv_stride_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVSurfaceDesc.in_line_uv_stride)
}

// -------------------------------------------------------------------

// CONVOpDesc

// required .nvdla_prototest_interface.ConvMode conv_mode = 1;
inline bool CONVOpDesc::has_conv_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CONVOpDesc::set_has_conv_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CONVOpDesc::clear_has_conv_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CONVOpDesc::clear_conv_mode() {
  conv_mode_ = 0;
  clear_has_conv_mode();
}
inline ::nvdla_prototest_interface::ConvMode CONVOpDesc::conv_mode() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.conv_mode)
  return static_cast< ::nvdla_prototest_interface::ConvMode >(conv_mode_);
}
inline void CONVOpDesc::set_conv_mode(::nvdla_prototest_interface::ConvMode value) {
  assert(::nvdla_prototest_interface::ConvMode_IsValid(value));
  set_has_conv_mode();
  conv_mode_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.conv_mode)
}

// required uint32 data_reuse = 2;
inline bool CONVOpDesc::has_data_reuse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CONVOpDesc::set_has_data_reuse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CONVOpDesc::clear_has_data_reuse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CONVOpDesc::clear_data_reuse() {
  data_reuse_ = 0u;
  clear_has_data_reuse();
}
inline ::google::protobuf::uint32 CONVOpDesc::data_reuse() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.data_reuse)
  return data_reuse_;
}
inline void CONVOpDesc::set_data_reuse(::google::protobuf::uint32 value) {
  set_has_data_reuse();
  data_reuse_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.data_reuse)
}

// required uint32 weight_reuse = 3;
inline bool CONVOpDesc::has_weight_reuse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CONVOpDesc::set_has_weight_reuse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CONVOpDesc::clear_has_weight_reuse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CONVOpDesc::clear_weight_reuse() {
  weight_reuse_ = 0u;
  clear_has_weight_reuse();
}
inline ::google::protobuf::uint32 CONVOpDesc::weight_reuse() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.weight_reuse)
  return weight_reuse_;
}
inline void CONVOpDesc::set_weight_reuse(::google::protobuf::uint32 value) {
  set_has_weight_reuse();
  weight_reuse_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.weight_reuse)
}

// required uint32 skip_data_rls = 4;
inline bool CONVOpDesc::has_skip_data_rls() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CONVOpDesc::set_has_skip_data_rls() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CONVOpDesc::clear_has_skip_data_rls() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CONVOpDesc::clear_skip_data_rls() {
  skip_data_rls_ = 0u;
  clear_has_skip_data_rls();
}
inline ::google::protobuf::uint32 CONVOpDesc::skip_data_rls() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.skip_data_rls)
  return skip_data_rls_;
}
inline void CONVOpDesc::set_skip_data_rls(::google::protobuf::uint32 value) {
  set_has_skip_data_rls();
  skip_data_rls_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.skip_data_rls)
}

// required uint32 skip_weight_rls = 5;
inline bool CONVOpDesc::has_skip_weight_rls() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CONVOpDesc::set_has_skip_weight_rls() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CONVOpDesc::clear_has_skip_weight_rls() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CONVOpDesc::clear_skip_weight_rls() {
  skip_weight_rls_ = 0u;
  clear_has_skip_weight_rls();
}
inline ::google::protobuf::uint32 CONVOpDesc::skip_weight_rls() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.skip_weight_rls)
  return skip_weight_rls_;
}
inline void CONVOpDesc::set_skip_weight_rls(::google::protobuf::uint32 value) {
  set_has_skip_weight_rls();
  skip_weight_rls_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.skip_weight_rls)
}

// optional uint32 reserved0 = 6 [default = 0];
inline bool CONVOpDesc::has_reserved0() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CONVOpDesc::set_has_reserved0() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CONVOpDesc::clear_has_reserved0() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CONVOpDesc::clear_reserved0() {
  reserved0_ = 0u;
  clear_has_reserved0();
}
inline ::google::protobuf::uint32 CONVOpDesc::reserved0() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.reserved0)
  return reserved0_;
}
inline void CONVOpDesc::set_reserved0(::google::protobuf::uint32 value) {
  set_has_reserved0();
  reserved0_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.reserved0)
}

// required uint32 entry_per_slice = 7;
inline bool CONVOpDesc::has_entry_per_slice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CONVOpDesc::set_has_entry_per_slice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CONVOpDesc::clear_has_entry_per_slice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CONVOpDesc::clear_entry_per_slice() {
  entry_per_slice_ = 0u;
  clear_has_entry_per_slice();
}
inline ::google::protobuf::uint32 CONVOpDesc::entry_per_slice() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.entry_per_slice)
  return entry_per_slice_;
}
inline void CONVOpDesc::set_entry_per_slice(::google::protobuf::uint32 value) {
  set_has_entry_per_slice();
  entry_per_slice_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.entry_per_slice)
}

// required .nvdla_prototest_interface.DataFormat data_format = 8;
inline bool CONVOpDesc::has_data_format() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CONVOpDesc::set_has_data_format() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CONVOpDesc::clear_has_data_format() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CONVOpDesc::clear_data_format() {
  data_format_ = 0;
  clear_has_data_format();
}
inline ::nvdla_prototest_interface::DataFormat CONVOpDesc::data_format() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.data_format)
  return static_cast< ::nvdla_prototest_interface::DataFormat >(data_format_);
}
inline void CONVOpDesc::set_data_format(::nvdla_prototest_interface::DataFormat value) {
  assert(::nvdla_prototest_interface::DataFormat_IsValid(value));
  set_has_data_format();
  data_format_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.data_format)
}

// required uint32 pixel_mapping = 9;
inline bool CONVOpDesc::has_pixel_mapping() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CONVOpDesc::set_has_pixel_mapping() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CONVOpDesc::clear_has_pixel_mapping() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CONVOpDesc::clear_pixel_mapping() {
  pixel_mapping_ = 0u;
  clear_has_pixel_mapping();
}
inline ::google::protobuf::uint32 CONVOpDesc::pixel_mapping() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.pixel_mapping)
  return pixel_mapping_;
}
inline void CONVOpDesc::set_pixel_mapping(::google::protobuf::uint32 value) {
  set_has_pixel_mapping();
  pixel_mapping_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.pixel_mapping)
}

// required uint32 fetch_grain = 10;
inline bool CONVOpDesc::has_fetch_grain() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CONVOpDesc::set_has_fetch_grain() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CONVOpDesc::clear_has_fetch_grain() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CONVOpDesc::clear_fetch_grain() {
  fetch_grain_ = 0u;
  clear_has_fetch_grain();
}
inline ::google::protobuf::uint32 CONVOpDesc::fetch_grain() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.fetch_grain)
  return fetch_grain_;
}
inline void CONVOpDesc::set_fetch_grain(::google::protobuf::uint32 value) {
  set_has_fetch_grain();
  fetch_grain_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.fetch_grain)
}

// required uint32 pixel_offset_x = 11;
inline bool CONVOpDesc::has_pixel_offset_x() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CONVOpDesc::set_has_pixel_offset_x() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CONVOpDesc::clear_has_pixel_offset_x() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CONVOpDesc::clear_pixel_offset_x() {
  pixel_offset_x_ = 0u;
  clear_has_pixel_offset_x();
}
inline ::google::protobuf::uint32 CONVOpDesc::pixel_offset_x() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.pixel_offset_x)
  return pixel_offset_x_;
}
inline void CONVOpDesc::set_pixel_offset_x(::google::protobuf::uint32 value) {
  set_has_pixel_offset_x();
  pixel_offset_x_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.pixel_offset_x)
}

// required uint32 pixel_offset_y = 12;
inline bool CONVOpDesc::has_pixel_offset_y() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CONVOpDesc::set_has_pixel_offset_y() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CONVOpDesc::clear_has_pixel_offset_y() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CONVOpDesc::clear_pixel_offset_y() {
  pixel_offset_y_ = 0u;
  clear_has_pixel_offset_y();
}
inline ::google::protobuf::uint32 CONVOpDesc::pixel_offset_y() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.pixel_offset_y)
  return pixel_offset_y_;
}
inline void CONVOpDesc::set_pixel_offset_y(::google::protobuf::uint32 value) {
  set_has_pixel_offset_y();
  pixel_offset_y_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.pixel_offset_y)
}

// required uint32 gob_per_line = 13;
inline bool CONVOpDesc::has_gob_per_line() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CONVOpDesc::set_has_gob_per_line() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CONVOpDesc::clear_has_gob_per_line() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CONVOpDesc::clear_gob_per_line() {
  gob_per_line_ = 0u;
  clear_has_gob_per_line();
}
inline ::google::protobuf::uint32 CONVOpDesc::gob_per_line() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.gob_per_line)
  return gob_per_line_;
}
inline void CONVOpDesc::set_gob_per_line(::google::protobuf::uint32 value) {
  set_has_gob_per_line();
  gob_per_line_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.gob_per_line)
}

// required uint32 gob_height = 14;
inline bool CONVOpDesc::has_gob_height() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CONVOpDesc::set_has_gob_height() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CONVOpDesc::clear_has_gob_height() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CONVOpDesc::clear_gob_height() {
  gob_height_ = 0u;
  clear_has_gob_height();
}
inline ::google::protobuf::uint32 CONVOpDesc::gob_height() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.gob_height)
  return gob_height_;
}
inline void CONVOpDesc::set_gob_height(::google::protobuf::uint32 value) {
  set_has_gob_height();
  gob_height_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.gob_height)
}

// required uint32 gob_y_index = 15;
inline bool CONVOpDesc::has_gob_y_index() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CONVOpDesc::set_has_gob_y_index() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CONVOpDesc::clear_has_gob_y_index() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CONVOpDesc::clear_gob_y_index() {
  gob_y_index_ = 0u;
  clear_has_gob_y_index();
}
inline ::google::protobuf::uint32 CONVOpDesc::gob_y_index() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.gob_y_index)
  return gob_y_index_;
}
inline void CONVOpDesc::set_gob_y_index(::google::protobuf::uint32 value) {
  set_has_gob_y_index();
  gob_y_index_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.gob_y_index)
}

// required uint32 gob_per_uv_line = 16;
inline bool CONVOpDesc::has_gob_per_uv_line() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CONVOpDesc::set_has_gob_per_uv_line() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CONVOpDesc::clear_has_gob_per_uv_line() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CONVOpDesc::clear_gob_per_uv_line() {
  gob_per_uv_line_ = 0u;
  clear_has_gob_per_uv_line();
}
inline ::google::protobuf::uint32 CONVOpDesc::gob_per_uv_line() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.gob_per_uv_line)
  return gob_per_uv_line_;
}
inline void CONVOpDesc::set_gob_per_uv_line(::google::protobuf::uint32 value) {
  set_has_gob_per_uv_line();
  gob_per_uv_line_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.gob_per_uv_line)
}

// required uint32 batch = 17;
inline bool CONVOpDesc::has_batch() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CONVOpDesc::set_has_batch() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CONVOpDesc::clear_has_batch() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CONVOpDesc::clear_batch() {
  batch_ = 0u;
  clear_has_batch();
}
inline ::google::protobuf::uint32 CONVOpDesc::batch() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.batch)
  return batch_;
}
inline void CONVOpDesc::set_batch(::google::protobuf::uint32 value) {
  set_has_batch();
  batch_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.batch)
}

// required .nvdla_prototest_interface.WeightFormat weight_format = 18;
inline bool CONVOpDesc::has_weight_format() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CONVOpDesc::set_has_weight_format() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CONVOpDesc::clear_has_weight_format() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CONVOpDesc::clear_weight_format() {
  weight_format_ = 0;
  clear_has_weight_format();
}
inline ::nvdla_prototest_interface::WeightFormat CONVOpDesc::weight_format() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.weight_format)
  return static_cast< ::nvdla_prototest_interface::WeightFormat >(weight_format_);
}
inline void CONVOpDesc::set_weight_format(::nvdla_prototest_interface::WeightFormat value) {
  assert(::nvdla_prototest_interface::WeightFormat_IsValid(value));
  set_has_weight_format();
  weight_format_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.weight_format)
}

// required uint32 data_bank = 19;
inline bool CONVOpDesc::has_data_bank() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CONVOpDesc::set_has_data_bank() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CONVOpDesc::clear_has_data_bank() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CONVOpDesc::clear_data_bank() {
  data_bank_ = 0u;
  clear_has_data_bank();
}
inline ::google::protobuf::uint32 CONVOpDesc::data_bank() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.data_bank)
  return data_bank_;
}
inline void CONVOpDesc::set_data_bank(::google::protobuf::uint32 value) {
  set_has_data_bank();
  data_bank_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.data_bank)
}

// required uint32 weight_bank = 20;
inline bool CONVOpDesc::has_weight_bank() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CONVOpDesc::set_has_weight_bank() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CONVOpDesc::clear_has_weight_bank() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CONVOpDesc::clear_weight_bank() {
  weight_bank_ = 0u;
  clear_has_weight_bank();
}
inline ::google::protobuf::uint32 CONVOpDesc::weight_bank() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.weight_bank)
  return weight_bank_;
}
inline void CONVOpDesc::set_weight_bank(::google::protobuf::uint32 value) {
  set_has_weight_bank();
  weight_bank_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.weight_bank)
}

// required uint32 batch_stride = 21;
inline bool CONVOpDesc::has_batch_stride() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CONVOpDesc::set_has_batch_stride() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CONVOpDesc::clear_has_batch_stride() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CONVOpDesc::clear_batch_stride() {
  batch_stride_ = 0u;
  clear_has_batch_stride();
}
inline ::google::protobuf::uint32 CONVOpDesc::batch_stride() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.batch_stride)
  return batch_stride_;
}
inline void CONVOpDesc::set_batch_stride(::google::protobuf::uint32 value) {
  set_has_batch_stride();
  batch_stride_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.batch_stride)
}

// required uint32 post_extension = 22;
inline bool CONVOpDesc::has_post_extension() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CONVOpDesc::set_has_post_extension() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CONVOpDesc::clear_has_post_extension() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CONVOpDesc::clear_post_extension() {
  post_extension_ = 0u;
  clear_has_post_extension();
}
inline ::google::protobuf::uint32 CONVOpDesc::post_extension() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.post_extension)
  return post_extension_;
}
inline void CONVOpDesc::set_post_extension(::google::protobuf::uint32 value) {
  set_has_post_extension();
  post_extension_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.post_extension)
}

// optional .nvdla_prototest_interface.PixelOverride pixel_override = 23;
inline bool CONVOpDesc::has_pixel_override() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CONVOpDesc::set_has_pixel_override() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CONVOpDesc::clear_has_pixel_override() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CONVOpDesc::clear_pixel_override() {
  pixel_override_ = 0;
  clear_has_pixel_override();
}
inline ::nvdla_prototest_interface::PixelOverride CONVOpDesc::pixel_override() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.pixel_override)
  return static_cast< ::nvdla_prototest_interface::PixelOverride >(pixel_override_);
}
inline void CONVOpDesc::set_pixel_override(::nvdla_prototest_interface::PixelOverride value) {
  assert(::nvdla_prototest_interface::PixelOverride_IsValid(value));
  set_has_pixel_override();
  pixel_override_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.pixel_override)
}

// required uint32 release = 24;
inline bool CONVOpDesc::has_release() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CONVOpDesc::set_has_release() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CONVOpDesc::clear_has_release() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CONVOpDesc::clear_release() {
  release_ = 0u;
  clear_has_release();
}
inline ::google::protobuf::uint32 CONVOpDesc::release() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.release)
  return release_;
}
inline void CONVOpDesc::set_release(::google::protobuf::uint32 value) {
  set_has_release();
  release_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.release)
}

// required uint32 input_width_csc = 25;
inline bool CONVOpDesc::has_input_width_csc() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CONVOpDesc::set_has_input_width_csc() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CONVOpDesc::clear_has_input_width_csc() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CONVOpDesc::clear_input_width_csc() {
  input_width_csc_ = 0u;
  clear_has_input_width_csc();
}
inline ::google::protobuf::uint32 CONVOpDesc::input_width_csc() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.input_width_csc)
  return input_width_csc_;
}
inline void CONVOpDesc::set_input_width_csc(::google::protobuf::uint32 value) {
  set_has_input_width_csc();
  input_width_csc_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.input_width_csc)
}

// required uint32 input_height_csc = 26;
inline bool CONVOpDesc::has_input_height_csc() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CONVOpDesc::set_has_input_height_csc() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CONVOpDesc::clear_has_input_height_csc() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CONVOpDesc::clear_input_height_csc() {
  input_height_csc_ = 0u;
  clear_has_input_height_csc();
}
inline ::google::protobuf::uint32 CONVOpDesc::input_height_csc() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.input_height_csc)
  return input_height_csc_;
}
inline void CONVOpDesc::set_input_height_csc(::google::protobuf::uint32 value) {
  set_has_input_height_csc();
  input_height_csc_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.input_height_csc)
}

// required uint32 input_channel_csc = 27;
inline bool CONVOpDesc::has_input_channel_csc() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CONVOpDesc::set_has_input_channel_csc() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CONVOpDesc::clear_has_input_channel_csc() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CONVOpDesc::clear_input_channel_csc() {
  input_channel_csc_ = 0u;
  clear_has_input_channel_csc();
}
inline ::google::protobuf::uint32 CONVOpDesc::input_channel_csc() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.input_channel_csc)
  return input_channel_csc_;
}
inline void CONVOpDesc::set_input_channel_csc(::google::protobuf::uint32 value) {
  set_has_input_channel_csc();
  input_channel_csc_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.input_channel_csc)
}

// required uint32 kernel_width_csc = 28;
inline bool CONVOpDesc::has_kernel_width_csc() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CONVOpDesc::set_has_kernel_width_csc() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CONVOpDesc::clear_has_kernel_width_csc() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CONVOpDesc::clear_kernel_width_csc() {
  kernel_width_csc_ = 0u;
  clear_has_kernel_width_csc();
}
inline ::google::protobuf::uint32 CONVOpDesc::kernel_width_csc() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.kernel_width_csc)
  return kernel_width_csc_;
}
inline void CONVOpDesc::set_kernel_width_csc(::google::protobuf::uint32 value) {
  set_has_kernel_width_csc();
  kernel_width_csc_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.kernel_width_csc)
}

// required uint32 kernel_height_csc = 29;
inline bool CONVOpDesc::has_kernel_height_csc() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CONVOpDesc::set_has_kernel_height_csc() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CONVOpDesc::clear_has_kernel_height_csc() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CONVOpDesc::clear_kernel_height_csc() {
  kernel_height_csc_ = 0u;
  clear_has_kernel_height_csc();
}
inline ::google::protobuf::uint32 CONVOpDesc::kernel_height_csc() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.kernel_height_csc)
  return kernel_height_csc_;
}
inline void CONVOpDesc::set_kernel_height_csc(::google::protobuf::uint32 value) {
  set_has_kernel_height_csc();
  kernel_height_csc_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.kernel_height_csc)
}

// required uint32 kernel_channel_csc = 30;
inline bool CONVOpDesc::has_kernel_channel_csc() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CONVOpDesc::set_has_kernel_channel_csc() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CONVOpDesc::clear_has_kernel_channel_csc() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CONVOpDesc::clear_kernel_channel_csc() {
  kernel_channel_csc_ = 0u;
  clear_has_kernel_channel_csc();
}
inline ::google::protobuf::uint32 CONVOpDesc::kernel_channel_csc() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.kernel_channel_csc)
  return kernel_channel_csc_;
}
inline void CONVOpDesc::set_kernel_channel_csc(::google::protobuf::uint32 value) {
  set_has_kernel_channel_csc();
  kernel_channel_csc_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.kernel_channel_csc)
}

// required uint32 input_width_cmac = 31;
inline bool CONVOpDesc::has_input_width_cmac() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CONVOpDesc::set_has_input_width_cmac() {
  _has_bits_[0] |= 0x40000000u;
}
inline void CONVOpDesc::clear_has_input_width_cmac() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void CONVOpDesc::clear_input_width_cmac() {
  input_width_cmac_ = 0u;
  clear_has_input_width_cmac();
}
inline ::google::protobuf::uint32 CONVOpDesc::input_width_cmac() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.input_width_cmac)
  return input_width_cmac_;
}
inline void CONVOpDesc::set_input_width_cmac(::google::protobuf::uint32 value) {
  set_has_input_width_cmac();
  input_width_cmac_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.input_width_cmac)
}

// required uint32 input_height_cmac = 32;
inline bool CONVOpDesc::has_input_height_cmac() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void CONVOpDesc::set_has_input_height_cmac() {
  _has_bits_[0] |= 0x80000000u;
}
inline void CONVOpDesc::clear_has_input_height_cmac() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void CONVOpDesc::clear_input_height_cmac() {
  input_height_cmac_ = 0u;
  clear_has_input_height_cmac();
}
inline ::google::protobuf::uint32 CONVOpDesc::input_height_cmac() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.input_height_cmac)
  return input_height_cmac_;
}
inline void CONVOpDesc::set_input_height_cmac(::google::protobuf::uint32 value) {
  set_has_input_height_cmac();
  input_height_cmac_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.input_height_cmac)
}

// required uint32 bytes_per_kernel = 33;
inline bool CONVOpDesc::has_bytes_per_kernel() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void CONVOpDesc::set_has_bytes_per_kernel() {
  _has_bits_[1] |= 0x00000001u;
}
inline void CONVOpDesc::clear_has_bytes_per_kernel() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void CONVOpDesc::clear_bytes_per_kernel() {
  bytes_per_kernel_ = 0u;
  clear_has_bytes_per_kernel();
}
inline ::google::protobuf::uint32 CONVOpDesc::bytes_per_kernel() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.bytes_per_kernel)
  return bytes_per_kernel_;
}
inline void CONVOpDesc::set_bytes_per_kernel(::google::protobuf::uint32 value) {
  set_has_bytes_per_kernel();
  bytes_per_kernel_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.bytes_per_kernel)
}

// required int32 mean_ry = 34;
inline bool CONVOpDesc::has_mean_ry() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void CONVOpDesc::set_has_mean_ry() {
  _has_bits_[1] |= 0x00000002u;
}
inline void CONVOpDesc::clear_has_mean_ry() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void CONVOpDesc::clear_mean_ry() {
  mean_ry_ = 0;
  clear_has_mean_ry();
}
inline ::google::protobuf::int32 CONVOpDesc::mean_ry() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.mean_ry)
  return mean_ry_;
}
inline void CONVOpDesc::set_mean_ry(::google::protobuf::int32 value) {
  set_has_mean_ry();
  mean_ry_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.mean_ry)
}

// required int32 mean_gu = 35;
inline bool CONVOpDesc::has_mean_gu() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void CONVOpDesc::set_has_mean_gu() {
  _has_bits_[1] |= 0x00000004u;
}
inline void CONVOpDesc::clear_has_mean_gu() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void CONVOpDesc::clear_mean_gu() {
  mean_gu_ = 0;
  clear_has_mean_gu();
}
inline ::google::protobuf::int32 CONVOpDesc::mean_gu() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.mean_gu)
  return mean_gu_;
}
inline void CONVOpDesc::set_mean_gu(::google::protobuf::int32 value) {
  set_has_mean_gu();
  mean_gu_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.mean_gu)
}

// required int32 mean_bv = 36;
inline bool CONVOpDesc::has_mean_bv() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void CONVOpDesc::set_has_mean_bv() {
  _has_bits_[1] |= 0x00000008u;
}
inline void CONVOpDesc::clear_has_mean_bv() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void CONVOpDesc::clear_mean_bv() {
  mean_bv_ = 0;
  clear_has_mean_bv();
}
inline ::google::protobuf::int32 CONVOpDesc::mean_bv() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.mean_bv)
  return mean_bv_;
}
inline void CONVOpDesc::set_mean_bv(::google::protobuf::int32 value) {
  set_has_mean_bv();
  mean_bv_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.mean_bv)
}

// required int32 mean_ax = 37;
inline bool CONVOpDesc::has_mean_ax() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void CONVOpDesc::set_has_mean_ax() {
  _has_bits_[1] |= 0x00000010u;
}
inline void CONVOpDesc::clear_has_mean_ax() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void CONVOpDesc::clear_mean_ax() {
  mean_ax_ = 0;
  clear_has_mean_ax();
}
inline ::google::protobuf::int32 CONVOpDesc::mean_ax() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.mean_ax)
  return mean_ax_;
}
inline void CONVOpDesc::set_mean_ax(::google::protobuf::int32 value) {
  set_has_mean_ax();
  mean_ax_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.mean_ax)
}

// required .nvdla_prototest_interface.MeanFormat mean_format = 38;
inline bool CONVOpDesc::has_mean_format() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void CONVOpDesc::set_has_mean_format() {
  _has_bits_[1] |= 0x00000020u;
}
inline void CONVOpDesc::clear_has_mean_format() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void CONVOpDesc::clear_mean_format() {
  mean_format_ = 0;
  clear_has_mean_format();
}
inline ::nvdla_prototest_interface::MeanFormat CONVOpDesc::mean_format() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.mean_format)
  return static_cast< ::nvdla_prototest_interface::MeanFormat >(mean_format_);
}
inline void CONVOpDesc::set_mean_format(::nvdla_prototest_interface::MeanFormat value) {
  assert(::nvdla_prototest_interface::MeanFormat_IsValid(value));
  set_has_mean_format();
  mean_format_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.mean_format)
}

// required uint32 conv_stride_x = 39;
inline bool CONVOpDesc::has_conv_stride_x() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void CONVOpDesc::set_has_conv_stride_x() {
  _has_bits_[1] |= 0x00000040u;
}
inline void CONVOpDesc::clear_has_conv_stride_x() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void CONVOpDesc::clear_conv_stride_x() {
  conv_stride_x_ = 0u;
  clear_has_conv_stride_x();
}
inline ::google::protobuf::uint32 CONVOpDesc::conv_stride_x() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.conv_stride_x)
  return conv_stride_x_;
}
inline void CONVOpDesc::set_conv_stride_x(::google::protobuf::uint32 value) {
  set_has_conv_stride_x();
  conv_stride_x_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.conv_stride_x)
}

// required uint32 conv_stride_y = 40;
inline bool CONVOpDesc::has_conv_stride_y() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void CONVOpDesc::set_has_conv_stride_y() {
  _has_bits_[1] |= 0x00000080u;
}
inline void CONVOpDesc::clear_has_conv_stride_y() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void CONVOpDesc::clear_conv_stride_y() {
  conv_stride_y_ = 0u;
  clear_has_conv_stride_y();
}
inline ::google::protobuf::uint32 CONVOpDesc::conv_stride_y() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.conv_stride_y)
  return conv_stride_y_;
}
inline void CONVOpDesc::set_conv_stride_y(::google::protobuf::uint32 value) {
  set_has_conv_stride_y();
  conv_stride_y_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.conv_stride_y)
}

// required uint32 pad_x_left = 41;
inline bool CONVOpDesc::has_pad_x_left() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void CONVOpDesc::set_has_pad_x_left() {
  _has_bits_[1] |= 0x00000100u;
}
inline void CONVOpDesc::clear_has_pad_x_left() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void CONVOpDesc::clear_pad_x_left() {
  pad_x_left_ = 0u;
  clear_has_pad_x_left();
}
inline ::google::protobuf::uint32 CONVOpDesc::pad_x_left() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.pad_x_left)
  return pad_x_left_;
}
inline void CONVOpDesc::set_pad_x_left(::google::protobuf::uint32 value) {
  set_has_pad_x_left();
  pad_x_left_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.pad_x_left)
}

// required uint32 pad_x_right = 42;
inline bool CONVOpDesc::has_pad_x_right() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void CONVOpDesc::set_has_pad_x_right() {
  _has_bits_[1] |= 0x00000200u;
}
inline void CONVOpDesc::clear_has_pad_x_right() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void CONVOpDesc::clear_pad_x_right() {
  pad_x_right_ = 0u;
  clear_has_pad_x_right();
}
inline ::google::protobuf::uint32 CONVOpDesc::pad_x_right() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.pad_x_right)
  return pad_x_right_;
}
inline void CONVOpDesc::set_pad_x_right(::google::protobuf::uint32 value) {
  set_has_pad_x_right();
  pad_x_right_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.pad_x_right)
}

// required uint32 pad_y_top = 43;
inline bool CONVOpDesc::has_pad_y_top() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void CONVOpDesc::set_has_pad_y_top() {
  _has_bits_[1] |= 0x00000400u;
}
inline void CONVOpDesc::clear_has_pad_y_top() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void CONVOpDesc::clear_pad_y_top() {
  pad_y_top_ = 0u;
  clear_has_pad_y_top();
}
inline ::google::protobuf::uint32 CONVOpDesc::pad_y_top() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.pad_y_top)
  return pad_y_top_;
}
inline void CONVOpDesc::set_pad_y_top(::google::protobuf::uint32 value) {
  set_has_pad_y_top();
  pad_y_top_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.pad_y_top)
}

// required uint32 pad_y_bottom = 44;
inline bool CONVOpDesc::has_pad_y_bottom() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void CONVOpDesc::set_has_pad_y_bottom() {
  _has_bits_[1] |= 0x00000800u;
}
inline void CONVOpDesc::clear_has_pad_y_bottom() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void CONVOpDesc::clear_pad_y_bottom() {
  pad_y_bottom_ = 0u;
  clear_has_pad_y_bottom();
}
inline ::google::protobuf::uint32 CONVOpDesc::pad_y_bottom() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.pad_y_bottom)
  return pad_y_bottom_;
}
inline void CONVOpDesc::set_pad_y_bottom(::google::protobuf::uint32 value) {
  set_has_pad_y_bottom();
  pad_y_bottom_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.pad_y_bottom)
}

// required uint32 dilation_x = 45;
inline bool CONVOpDesc::has_dilation_x() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void CONVOpDesc::set_has_dilation_x() {
  _has_bits_[1] |= 0x00001000u;
}
inline void CONVOpDesc::clear_has_dilation_x() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void CONVOpDesc::clear_dilation_x() {
  dilation_x_ = 0u;
  clear_has_dilation_x();
}
inline ::google::protobuf::uint32 CONVOpDesc::dilation_x() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.dilation_x)
  return dilation_x_;
}
inline void CONVOpDesc::set_dilation_x(::google::protobuf::uint32 value) {
  set_has_dilation_x();
  dilation_x_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.dilation_x)
}

// required uint32 dilation_y = 46;
inline bool CONVOpDesc::has_dilation_y() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void CONVOpDesc::set_has_dilation_y() {
  _has_bits_[1] |= 0x00002000u;
}
inline void CONVOpDesc::clear_has_dilation_y() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void CONVOpDesc::clear_dilation_y() {
  dilation_y_ = 0u;
  clear_has_dilation_y();
}
inline ::google::protobuf::uint32 CONVOpDesc::dilation_y() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.dilation_y)
  return dilation_y_;
}
inline void CONVOpDesc::set_dilation_y(::google::protobuf::uint32 value) {
  set_has_dilation_y();
  dilation_y_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.dilation_y)
}

// repeated uint32 reserved2 = 47 [packed = true];
inline int CONVOpDesc::reserved2_size() const {
  return reserved2_.size();
}
inline void CONVOpDesc::clear_reserved2() {
  reserved2_.Clear();
}
inline ::google::protobuf::uint32 CONVOpDesc::reserved2(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.reserved2)
  return reserved2_.Get(index);
}
inline void CONVOpDesc::set_reserved2(int index, ::google::protobuf::uint32 value) {
  reserved2_.Set(index, value);
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.reserved2)
}
inline void CONVOpDesc::add_reserved2(::google::protobuf::uint32 value) {
  reserved2_.Add(value);
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.CONVOpDesc.reserved2)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CONVOpDesc::reserved2() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.CONVOpDesc.reserved2)
  return reserved2_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CONVOpDesc::mutable_reserved2() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.CONVOpDesc.reserved2)
  return &reserved2_;
}

// required uint32 pra_truncate = 48;
inline bool CONVOpDesc::has_pra_truncate() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void CONVOpDesc::set_has_pra_truncate() {
  _has_bits_[1] |= 0x00008000u;
}
inline void CONVOpDesc::clear_has_pra_truncate() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void CONVOpDesc::clear_pra_truncate() {
  pra_truncate_ = 0u;
  clear_has_pra_truncate();
}
inline ::google::protobuf::uint32 CONVOpDesc::pra_truncate() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.pra_truncate)
  return pra_truncate_;
}
inline void CONVOpDesc::set_pra_truncate(::google::protobuf::uint32 value) {
  set_has_pra_truncate();
  pra_truncate_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.pra_truncate)
}

// required .nvdla_prototest_interface.DataPrecision in_precision = 49;
inline bool CONVOpDesc::has_in_precision() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void CONVOpDesc::set_has_in_precision() {
  _has_bits_[1] |= 0x00010000u;
}
inline void CONVOpDesc::clear_has_in_precision() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void CONVOpDesc::clear_in_precision() {
  in_precision_ = 0;
  clear_has_in_precision();
}
inline ::nvdla_prototest_interface::DataPrecision CONVOpDesc::in_precision() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.in_precision)
  return static_cast< ::nvdla_prototest_interface::DataPrecision >(in_precision_);
}
inline void CONVOpDesc::set_in_precision(::nvdla_prototest_interface::DataPrecision value) {
  assert(::nvdla_prototest_interface::DataPrecision_IsValid(value));
  set_has_in_precision();
  in_precision_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.in_precision)
}

// required .nvdla_prototest_interface.DataPrecision out_precision = 50;
inline bool CONVOpDesc::has_out_precision() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void CONVOpDesc::set_has_out_precision() {
  _has_bits_[1] |= 0x00020000u;
}
inline void CONVOpDesc::clear_has_out_precision() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void CONVOpDesc::clear_out_precision() {
  out_precision_ = 0;
  clear_has_out_precision();
}
inline ::nvdla_prototest_interface::DataPrecision CONVOpDesc::out_precision() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.out_precision)
  return static_cast< ::nvdla_prototest_interface::DataPrecision >(out_precision_);
}
inline void CONVOpDesc::set_out_precision(::nvdla_prototest_interface::DataPrecision value) {
  assert(::nvdla_prototest_interface::DataPrecision_IsValid(value));
  set_has_out_precision();
  out_precision_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.out_precision)
}

// required int32 pad_val = 51;
inline bool CONVOpDesc::has_pad_val() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void CONVOpDesc::set_has_pad_val() {
  _has_bits_[1] |= 0x00040000u;
}
inline void CONVOpDesc::clear_has_pad_val() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void CONVOpDesc::clear_pad_val() {
  pad_val_ = 0;
  clear_has_pad_val();
}
inline ::google::protobuf::int32 CONVOpDesc::pad_val() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.pad_val)
  return pad_val_;
}
inline void CONVOpDesc::set_pad_val(::google::protobuf::int32 value) {
  set_has_pad_val();
  pad_val_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CONVOpDesc.pad_val)
}

// required .nvdla_prototest_interface.CVTParam in_cvt = 52;
inline bool CONVOpDesc::has_in_cvt() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void CONVOpDesc::set_has_in_cvt() {
  _has_bits_[1] |= 0x00080000u;
}
inline void CONVOpDesc::clear_has_in_cvt() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void CONVOpDesc::clear_in_cvt() {
  if (in_cvt_ != NULL) in_cvt_->::nvdla_prototest_interface::CVTParam::Clear();
  clear_has_in_cvt();
}
inline const ::nvdla_prototest_interface::CVTParam& CONVOpDesc::in_cvt() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.in_cvt)
  return in_cvt_ != NULL ? *in_cvt_ : *default_instance_->in_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* CONVOpDesc::mutable_in_cvt() {
  set_has_in_cvt();
  if (in_cvt_ == NULL) in_cvt_ = new ::nvdla_prototest_interface::CVTParam;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.CONVOpDesc.in_cvt)
  return in_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* CONVOpDesc::release_in_cvt() {
  clear_has_in_cvt();
  ::nvdla_prototest_interface::CVTParam* temp = in_cvt_;
  in_cvt_ = NULL;
  return temp;
}
inline void CONVOpDesc::set_allocated_in_cvt(::nvdla_prototest_interface::CVTParam* in_cvt) {
  delete in_cvt_;
  in_cvt_ = in_cvt;
  if (in_cvt) {
    set_has_in_cvt();
  } else {
    clear_has_in_cvt();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.CONVOpDesc.in_cvt)
}

// required .nvdla_prototest_interface.CVTParam out_cvt = 53;
inline bool CONVOpDesc::has_out_cvt() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void CONVOpDesc::set_has_out_cvt() {
  _has_bits_[1] |= 0x00100000u;
}
inline void CONVOpDesc::clear_has_out_cvt() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void CONVOpDesc::clear_out_cvt() {
  if (out_cvt_ != NULL) out_cvt_->::nvdla_prototest_interface::CVTParam::Clear();
  clear_has_out_cvt();
}
inline const ::nvdla_prototest_interface::CVTParam& CONVOpDesc::out_cvt() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CONVOpDesc.out_cvt)
  return out_cvt_ != NULL ? *out_cvt_ : *default_instance_->out_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* CONVOpDesc::mutable_out_cvt() {
  set_has_out_cvt();
  if (out_cvt_ == NULL) out_cvt_ = new ::nvdla_prototest_interface::CVTParam;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.CONVOpDesc.out_cvt)
  return out_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* CONVOpDesc::release_out_cvt() {
  clear_has_out_cvt();
  ::nvdla_prototest_interface::CVTParam* temp = out_cvt_;
  out_cvt_ = NULL;
  return temp;
}
inline void CONVOpDesc::set_allocated_out_cvt(::nvdla_prototest_interface::CVTParam* out_cvt) {
  delete out_cvt_;
  out_cvt_ = out_cvt;
  if (out_cvt) {
    set_has_out_cvt();
  } else {
    clear_has_out_cvt();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.CONVOpDesc.out_cvt)
}

// -------------------------------------------------------------------

// SDPCvt

// required .nvdla_prototest_interface.CVTParam alu_cvt = 1;
inline bool SDPCvt::has_alu_cvt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SDPCvt::set_has_alu_cvt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SDPCvt::clear_has_alu_cvt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SDPCvt::clear_alu_cvt() {
  if (alu_cvt_ != NULL) alu_cvt_->::nvdla_prototest_interface::CVTParam::Clear();
  clear_has_alu_cvt();
}
inline const ::nvdla_prototest_interface::CVTParam& SDPCvt::alu_cvt() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPCvt.alu_cvt)
  return alu_cvt_ != NULL ? *alu_cvt_ : *default_instance_->alu_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* SDPCvt::mutable_alu_cvt() {
  set_has_alu_cvt();
  if (alu_cvt_ == NULL) alu_cvt_ = new ::nvdla_prototest_interface::CVTParam;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.SDPCvt.alu_cvt)
  return alu_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* SDPCvt::release_alu_cvt() {
  clear_has_alu_cvt();
  ::nvdla_prototest_interface::CVTParam* temp = alu_cvt_;
  alu_cvt_ = NULL;
  return temp;
}
inline void SDPCvt::set_allocated_alu_cvt(::nvdla_prototest_interface::CVTParam* alu_cvt) {
  delete alu_cvt_;
  alu_cvt_ = alu_cvt;
  if (alu_cvt) {
    set_has_alu_cvt();
  } else {
    clear_has_alu_cvt();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.SDPCvt.alu_cvt)
}

// required .nvdla_prototest_interface.CVTParam mul_cvt = 2;
inline bool SDPCvt::has_mul_cvt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SDPCvt::set_has_mul_cvt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SDPCvt::clear_has_mul_cvt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SDPCvt::clear_mul_cvt() {
  if (mul_cvt_ != NULL) mul_cvt_->::nvdla_prototest_interface::CVTParam::Clear();
  clear_has_mul_cvt();
}
inline const ::nvdla_prototest_interface::CVTParam& SDPCvt::mul_cvt() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPCvt.mul_cvt)
  return mul_cvt_ != NULL ? *mul_cvt_ : *default_instance_->mul_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* SDPCvt::mutable_mul_cvt() {
  set_has_mul_cvt();
  if (mul_cvt_ == NULL) mul_cvt_ = new ::nvdla_prototest_interface::CVTParam;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.SDPCvt.mul_cvt)
  return mul_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* SDPCvt::release_mul_cvt() {
  clear_has_mul_cvt();
  ::nvdla_prototest_interface::CVTParam* temp = mul_cvt_;
  mul_cvt_ = NULL;
  return temp;
}
inline void SDPCvt::set_allocated_mul_cvt(::nvdla_prototest_interface::CVTParam* mul_cvt) {
  delete mul_cvt_;
  mul_cvt_ = mul_cvt;
  if (mul_cvt) {
    set_has_mul_cvt();
  } else {
    clear_has_mul_cvt();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.SDPCvt.mul_cvt)
}

// -------------------------------------------------------------------

// SDPOp

// required uint32 enable = 1;
inline bool SDPOp::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SDPOp::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SDPOp::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SDPOp::clear_enable() {
  enable_ = 0u;
  clear_has_enable();
}
inline ::google::protobuf::uint32 SDPOp::enable() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOp.enable)
  return enable_;
}
inline void SDPOp::set_enable(::google::protobuf::uint32 value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOp.enable)
}

// required .nvdla_prototest_interface.ALUType alu_type = 2;
inline bool SDPOp::has_alu_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SDPOp::set_has_alu_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SDPOp::clear_has_alu_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SDPOp::clear_alu_type() {
  alu_type_ = 0;
  clear_has_alu_type();
}
inline ::nvdla_prototest_interface::ALUType SDPOp::alu_type() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOp.alu_type)
  return static_cast< ::nvdla_prototest_interface::ALUType >(alu_type_);
}
inline void SDPOp::set_alu_type(::nvdla_prototest_interface::ALUType value) {
  assert(::nvdla_prototest_interface::ALUType_IsValid(value));
  set_has_alu_type();
  alu_type_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOp.alu_type)
}

// required .nvdla_prototest_interface.SDPOpType type = 3;
inline bool SDPOp::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SDPOp::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SDPOp::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SDPOp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::nvdla_prototest_interface::SDPOpType SDPOp::type() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOp.type)
  return static_cast< ::nvdla_prototest_interface::SDPOpType >(type_);
}
inline void SDPOp::set_type(::nvdla_prototest_interface::SDPOpType value) {
  assert(::nvdla_prototest_interface::SDPOpType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOp.type)
}

// required .nvdla_prototest_interface.SDPOp.SDPOpMode mode = 4;
inline bool SDPOp::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SDPOp::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SDPOp::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SDPOp::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::nvdla_prototest_interface::SDPOp_SDPOpMode SDPOp::mode() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOp.mode)
  return static_cast< ::nvdla_prototest_interface::SDPOp_SDPOpMode >(mode_);
}
inline void SDPOp::set_mode(::nvdla_prototest_interface::SDPOp_SDPOpMode value) {
  assert(::nvdla_prototest_interface::SDPOp_SDPOpMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOp.mode)
}

// required .nvdla_prototest_interface.SDPActivation act = 5;
inline bool SDPOp::has_act() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SDPOp::set_has_act() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SDPOp::clear_has_act() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SDPOp::clear_act() {
  act_ = 0;
  clear_has_act();
}
inline ::nvdla_prototest_interface::SDPActivation SDPOp::act() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOp.act)
  return static_cast< ::nvdla_prototest_interface::SDPActivation >(act_);
}
inline void SDPOp::set_act(::nvdla_prototest_interface::SDPActivation value) {
  assert(::nvdla_prototest_interface::SDPActivation_IsValid(value));
  set_has_act();
  act_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOp.act)
}

// required uint32 shift_value = 6;
inline bool SDPOp::has_shift_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SDPOp::set_has_shift_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SDPOp::clear_has_shift_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SDPOp::clear_shift_value() {
  shift_value_ = 0u;
  clear_has_shift_value();
}
inline ::google::protobuf::uint32 SDPOp::shift_value() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOp.shift_value)
  return shift_value_;
}
inline void SDPOp::set_shift_value(::google::protobuf::uint32 value) {
  set_has_shift_value();
  shift_value_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOp.shift_value)
}

// required uint32 truncate = 7;
inline bool SDPOp::has_truncate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SDPOp::set_has_truncate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SDPOp::clear_has_truncate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SDPOp::clear_truncate() {
  truncate_ = 0u;
  clear_has_truncate();
}
inline ::google::protobuf::uint32 SDPOp::truncate() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOp.truncate)
  return truncate_;
}
inline void SDPOp::set_truncate(::google::protobuf::uint32 value) {
  set_has_truncate();
  truncate_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOp.truncate)
}

// required .nvdla_prototest_interface.DataPrecision precision = 8;
inline bool SDPOp::has_precision() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SDPOp::set_has_precision() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SDPOp::clear_has_precision() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SDPOp::clear_precision() {
  precision_ = 0;
  clear_has_precision();
}
inline ::nvdla_prototest_interface::DataPrecision SDPOp::precision() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOp.precision)
  return static_cast< ::nvdla_prototest_interface::DataPrecision >(precision_);
}
inline void SDPOp::set_precision(::nvdla_prototest_interface::DataPrecision value) {
  assert(::nvdla_prototest_interface::DataPrecision_IsValid(value));
  set_has_precision();
  precision_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOp.precision)
}

// required int32 alu_operand = 9;
inline bool SDPOp::has_alu_operand() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SDPOp::set_has_alu_operand() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SDPOp::clear_has_alu_operand() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SDPOp::clear_alu_operand() {
  alu_operand_ = 0;
  clear_has_alu_operand();
}
inline ::google::protobuf::int32 SDPOp::alu_operand() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOp.alu_operand)
  return alu_operand_;
}
inline void SDPOp::set_alu_operand(::google::protobuf::int32 value) {
  set_has_alu_operand();
  alu_operand_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOp.alu_operand)
}

// required int32 mul_operand = 10;
inline bool SDPOp::has_mul_operand() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SDPOp::set_has_mul_operand() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SDPOp::clear_has_mul_operand() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SDPOp::clear_mul_operand() {
  mul_operand_ = 0;
  clear_has_mul_operand();
}
inline ::google::protobuf::int32 SDPOp::mul_operand() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOp.mul_operand)
  return mul_operand_;
}
inline void SDPOp::set_mul_operand(::google::protobuf::int32 value) {
  set_has_mul_operand();
  mul_operand_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOp.mul_operand)
}

// required .nvdla_prototest_interface.SDPCvt cvt = 11;
inline bool SDPOp::has_cvt() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SDPOp::set_has_cvt() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SDPOp::clear_has_cvt() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SDPOp::clear_cvt() {
  if (cvt_ != NULL) cvt_->::nvdla_prototest_interface::SDPCvt::Clear();
  clear_has_cvt();
}
inline const ::nvdla_prototest_interface::SDPCvt& SDPOp::cvt() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOp.cvt)
  return cvt_ != NULL ? *cvt_ : *default_instance_->cvt_;
}
inline ::nvdla_prototest_interface::SDPCvt* SDPOp::mutable_cvt() {
  set_has_cvt();
  if (cvt_ == NULL) cvt_ = new ::nvdla_prototest_interface::SDPCvt;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.SDPOp.cvt)
  return cvt_;
}
inline ::nvdla_prototest_interface::SDPCvt* SDPOp::release_cvt() {
  clear_has_cvt();
  ::nvdla_prototest_interface::SDPCvt* temp = cvt_;
  cvt_ = NULL;
  return temp;
}
inline void SDPOp::set_allocated_cvt(::nvdla_prototest_interface::SDPCvt* cvt) {
  delete cvt_;
  cvt_ = cvt;
  if (cvt) {
    set_has_cvt();
  } else {
    clear_has_cvt();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.SDPOp.cvt)
}

// -------------------------------------------------------------------

// SDPSurfaceDesc

// required .nvdla_prototest_interface.DataCube src_data = 1;
inline bool SDPSurfaceDesc::has_src_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SDPSurfaceDesc::set_has_src_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SDPSurfaceDesc::clear_has_src_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SDPSurfaceDesc::clear_src_data() {
  if (src_data_ != NULL) src_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_src_data();
}
inline const ::nvdla_prototest_interface::DataCube& SDPSurfaceDesc::src_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPSurfaceDesc.src_data)
  return src_data_ != NULL ? *src_data_ : *default_instance_->src_data_;
}
inline ::nvdla_prototest_interface::DataCube* SDPSurfaceDesc::mutable_src_data() {
  set_has_src_data();
  if (src_data_ == NULL) src_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.SDPSurfaceDesc.src_data)
  return src_data_;
}
inline ::nvdla_prototest_interface::DataCube* SDPSurfaceDesc::release_src_data() {
  clear_has_src_data();
  ::nvdla_prototest_interface::DataCube* temp = src_data_;
  src_data_ = NULL;
  return temp;
}
inline void SDPSurfaceDesc::set_allocated_src_data(::nvdla_prototest_interface::DataCube* src_data) {
  delete src_data_;
  src_data_ = src_data;
  if (src_data) {
    set_has_src_data();
  } else {
    clear_has_src_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.SDPSurfaceDesc.src_data)
}

// optional .nvdla_prototest_interface.DataCube x1_data = 2;
inline bool SDPSurfaceDesc::has_x1_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SDPSurfaceDesc::set_has_x1_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SDPSurfaceDesc::clear_has_x1_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SDPSurfaceDesc::clear_x1_data() {
  if (x1_data_ != NULL) x1_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_x1_data();
}
inline const ::nvdla_prototest_interface::DataCube& SDPSurfaceDesc::x1_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPSurfaceDesc.x1_data)
  return x1_data_ != NULL ? *x1_data_ : *default_instance_->x1_data_;
}
inline ::nvdla_prototest_interface::DataCube* SDPSurfaceDesc::mutable_x1_data() {
  set_has_x1_data();
  if (x1_data_ == NULL) x1_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.SDPSurfaceDesc.x1_data)
  return x1_data_;
}
inline ::nvdla_prototest_interface::DataCube* SDPSurfaceDesc::release_x1_data() {
  clear_has_x1_data();
  ::nvdla_prototest_interface::DataCube* temp = x1_data_;
  x1_data_ = NULL;
  return temp;
}
inline void SDPSurfaceDesc::set_allocated_x1_data(::nvdla_prototest_interface::DataCube* x1_data) {
  delete x1_data_;
  x1_data_ = x1_data;
  if (x1_data) {
    set_has_x1_data();
  } else {
    clear_has_x1_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.SDPSurfaceDesc.x1_data)
}

// optional .nvdla_prototest_interface.DataCube x2_data = 3;
inline bool SDPSurfaceDesc::has_x2_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SDPSurfaceDesc::set_has_x2_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SDPSurfaceDesc::clear_has_x2_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SDPSurfaceDesc::clear_x2_data() {
  if (x2_data_ != NULL) x2_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_x2_data();
}
inline const ::nvdla_prototest_interface::DataCube& SDPSurfaceDesc::x2_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPSurfaceDesc.x2_data)
  return x2_data_ != NULL ? *x2_data_ : *default_instance_->x2_data_;
}
inline ::nvdla_prototest_interface::DataCube* SDPSurfaceDesc::mutable_x2_data() {
  set_has_x2_data();
  if (x2_data_ == NULL) x2_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.SDPSurfaceDesc.x2_data)
  return x2_data_;
}
inline ::nvdla_prototest_interface::DataCube* SDPSurfaceDesc::release_x2_data() {
  clear_has_x2_data();
  ::nvdla_prototest_interface::DataCube* temp = x2_data_;
  x2_data_ = NULL;
  return temp;
}
inline void SDPSurfaceDesc::set_allocated_x2_data(::nvdla_prototest_interface::DataCube* x2_data) {
  delete x2_data_;
  x2_data_ = x2_data;
  if (x2_data) {
    set_has_x2_data();
  } else {
    clear_has_x2_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.SDPSurfaceDesc.x2_data)
}

// optional .nvdla_prototest_interface.DataCube y_data = 4;
inline bool SDPSurfaceDesc::has_y_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SDPSurfaceDesc::set_has_y_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SDPSurfaceDesc::clear_has_y_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SDPSurfaceDesc::clear_y_data() {
  if (y_data_ != NULL) y_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_y_data();
}
inline const ::nvdla_prototest_interface::DataCube& SDPSurfaceDesc::y_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPSurfaceDesc.y_data)
  return y_data_ != NULL ? *y_data_ : *default_instance_->y_data_;
}
inline ::nvdla_prototest_interface::DataCube* SDPSurfaceDesc::mutable_y_data() {
  set_has_y_data();
  if (y_data_ == NULL) y_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.SDPSurfaceDesc.y_data)
  return y_data_;
}
inline ::nvdla_prototest_interface::DataCube* SDPSurfaceDesc::release_y_data() {
  clear_has_y_data();
  ::nvdla_prototest_interface::DataCube* temp = y_data_;
  y_data_ = NULL;
  return temp;
}
inline void SDPSurfaceDesc::set_allocated_y_data(::nvdla_prototest_interface::DataCube* y_data) {
  delete y_data_;
  y_data_ = y_data;
  if (y_data) {
    set_has_y_data();
  } else {
    clear_has_y_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.SDPSurfaceDesc.y_data)
}

// required .nvdla_prototest_interface.DataCube dst_data = 5;
inline bool SDPSurfaceDesc::has_dst_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SDPSurfaceDesc::set_has_dst_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SDPSurfaceDesc::clear_has_dst_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SDPSurfaceDesc::clear_dst_data() {
  if (dst_data_ != NULL) dst_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_dst_data();
}
inline const ::nvdla_prototest_interface::DataCube& SDPSurfaceDesc::dst_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPSurfaceDesc.dst_data)
  return dst_data_ != NULL ? *dst_data_ : *default_instance_->dst_data_;
}
inline ::nvdla_prototest_interface::DataCube* SDPSurfaceDesc::mutable_dst_data() {
  set_has_dst_data();
  if (dst_data_ == NULL) dst_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.SDPSurfaceDesc.dst_data)
  return dst_data_;
}
inline ::nvdla_prototest_interface::DataCube* SDPSurfaceDesc::release_dst_data() {
  clear_has_dst_data();
  ::nvdla_prototest_interface::DataCube* temp = dst_data_;
  dst_data_ = NULL;
  return temp;
}
inline void SDPSurfaceDesc::set_allocated_dst_data(::nvdla_prototest_interface::DataCube* dst_data) {
  delete dst_data_;
  dst_data_ = dst_data;
  if (dst_data) {
    set_has_dst_data();
  } else {
    clear_has_dst_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.SDPSurfaceDesc.dst_data)
}

// -------------------------------------------------------------------

// SDPOpDesc

// required .nvdla_prototest_interface.DataPrecision src_precision = 1;
inline bool SDPOpDesc::has_src_precision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SDPOpDesc::set_has_src_precision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SDPOpDesc::clear_has_src_precision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SDPOpDesc::clear_src_precision() {
  src_precision_ = 0;
  clear_has_src_precision();
}
inline ::nvdla_prototest_interface::DataPrecision SDPOpDesc::src_precision() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOpDesc.src_precision)
  return static_cast< ::nvdla_prototest_interface::DataPrecision >(src_precision_);
}
inline void SDPOpDesc::set_src_precision(::nvdla_prototest_interface::DataPrecision value) {
  assert(::nvdla_prototest_interface::DataPrecision_IsValid(value));
  set_has_src_precision();
  src_precision_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOpDesc.src_precision)
}

// required .nvdla_prototest_interface.DataPrecision dst_precision = 2;
inline bool SDPOpDesc::has_dst_precision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SDPOpDesc::set_has_dst_precision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SDPOpDesc::clear_has_dst_precision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SDPOpDesc::clear_dst_precision() {
  dst_precision_ = 0;
  clear_has_dst_precision();
}
inline ::nvdla_prototest_interface::DataPrecision SDPOpDesc::dst_precision() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOpDesc.dst_precision)
  return static_cast< ::nvdla_prototest_interface::DataPrecision >(dst_precision_);
}
inline void SDPOpDesc::set_dst_precision(::nvdla_prototest_interface::DataPrecision value) {
  assert(::nvdla_prototest_interface::DataPrecision_IsValid(value));
  set_has_dst_precision();
  dst_precision_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOpDesc.dst_precision)
}

// required int32 lut_index = 3;
inline bool SDPOpDesc::has_lut_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SDPOpDesc::set_has_lut_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SDPOpDesc::clear_has_lut_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SDPOpDesc::clear_lut_index() {
  lut_index_ = 0;
  clear_has_lut_index();
}
inline ::google::protobuf::int32 SDPOpDesc::lut_index() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOpDesc.lut_index)
  return lut_index_;
}
inline void SDPOpDesc::set_lut_index(::google::protobuf::int32 value) {
  set_has_lut_index();
  lut_index_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOpDesc.lut_index)
}

// required .nvdla_prototest_interface.CVTParam out_cvt = 4;
inline bool SDPOpDesc::has_out_cvt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SDPOpDesc::set_has_out_cvt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SDPOpDesc::clear_has_out_cvt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SDPOpDesc::clear_out_cvt() {
  if (out_cvt_ != NULL) out_cvt_->::nvdla_prototest_interface::CVTParam::Clear();
  clear_has_out_cvt();
}
inline const ::nvdla_prototest_interface::CVTParam& SDPOpDesc::out_cvt() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOpDesc.out_cvt)
  return out_cvt_ != NULL ? *out_cvt_ : *default_instance_->out_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* SDPOpDesc::mutable_out_cvt() {
  set_has_out_cvt();
  if (out_cvt_ == NULL) out_cvt_ = new ::nvdla_prototest_interface::CVTParam;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.SDPOpDesc.out_cvt)
  return out_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* SDPOpDesc::release_out_cvt() {
  clear_has_out_cvt();
  ::nvdla_prototest_interface::CVTParam* temp = out_cvt_;
  out_cvt_ = NULL;
  return temp;
}
inline void SDPOpDesc::set_allocated_out_cvt(::nvdla_prototest_interface::CVTParam* out_cvt) {
  delete out_cvt_;
  out_cvt_ = out_cvt;
  if (out_cvt) {
    set_has_out_cvt();
  } else {
    clear_has_out_cvt();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.SDPOpDesc.out_cvt)
}

// required .nvdla_prototest_interface.ConvMode conv_mode = 5;
inline bool SDPOpDesc::has_conv_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SDPOpDesc::set_has_conv_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SDPOpDesc::clear_has_conv_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SDPOpDesc::clear_conv_mode() {
  conv_mode_ = 0;
  clear_has_conv_mode();
}
inline ::nvdla_prototest_interface::ConvMode SDPOpDesc::conv_mode() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOpDesc.conv_mode)
  return static_cast< ::nvdla_prototest_interface::ConvMode >(conv_mode_);
}
inline void SDPOpDesc::set_conv_mode(::nvdla_prototest_interface::ConvMode value) {
  assert(::nvdla_prototest_interface::ConvMode_IsValid(value));
  set_has_conv_mode();
  conv_mode_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOpDesc.conv_mode)
}

// required uint32 batch_num = 6;
inline bool SDPOpDesc::has_batch_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SDPOpDesc::set_has_batch_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SDPOpDesc::clear_has_batch_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SDPOpDesc::clear_batch_num() {
  batch_num_ = 0u;
  clear_has_batch_num();
}
inline ::google::protobuf::uint32 SDPOpDesc::batch_num() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOpDesc.batch_num)
  return batch_num_;
}
inline void SDPOpDesc::set_batch_num(::google::protobuf::uint32 value) {
  set_has_batch_num();
  batch_num_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOpDesc.batch_num)
}

// optional uint32 reserved0 = 7 [default = 0];
inline bool SDPOpDesc::has_reserved0() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SDPOpDesc::set_has_reserved0() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SDPOpDesc::clear_has_reserved0() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SDPOpDesc::clear_reserved0() {
  reserved0_ = 0u;
  clear_has_reserved0();
}
inline ::google::protobuf::uint32 SDPOpDesc::reserved0() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOpDesc.reserved0)
  return reserved0_;
}
inline void SDPOpDesc::set_reserved0(::google::protobuf::uint32 value) {
  set_has_reserved0();
  reserved0_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOpDesc.reserved0)
}

// required uint32 batch_stride = 8;
inline bool SDPOpDesc::has_batch_stride() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SDPOpDesc::set_has_batch_stride() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SDPOpDesc::clear_has_batch_stride() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SDPOpDesc::clear_batch_stride() {
  batch_stride_ = 0u;
  clear_has_batch_stride();
}
inline ::google::protobuf::uint32 SDPOpDesc::batch_stride() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOpDesc.batch_stride)
  return batch_stride_;
}
inline void SDPOpDesc::set_batch_stride(::google::protobuf::uint32 value) {
  set_has_batch_stride();
  batch_stride_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SDPOpDesc.batch_stride)
}

// required .nvdla_prototest_interface.SDPOp x1_op = 9;
inline bool SDPOpDesc::has_x1_op() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SDPOpDesc::set_has_x1_op() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SDPOpDesc::clear_has_x1_op() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SDPOpDesc::clear_x1_op() {
  if (x1_op_ != NULL) x1_op_->::nvdla_prototest_interface::SDPOp::Clear();
  clear_has_x1_op();
}
inline const ::nvdla_prototest_interface::SDPOp& SDPOpDesc::x1_op() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOpDesc.x1_op)
  return x1_op_ != NULL ? *x1_op_ : *default_instance_->x1_op_;
}
inline ::nvdla_prototest_interface::SDPOp* SDPOpDesc::mutable_x1_op() {
  set_has_x1_op();
  if (x1_op_ == NULL) x1_op_ = new ::nvdla_prototest_interface::SDPOp;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.SDPOpDesc.x1_op)
  return x1_op_;
}
inline ::nvdla_prototest_interface::SDPOp* SDPOpDesc::release_x1_op() {
  clear_has_x1_op();
  ::nvdla_prototest_interface::SDPOp* temp = x1_op_;
  x1_op_ = NULL;
  return temp;
}
inline void SDPOpDesc::set_allocated_x1_op(::nvdla_prototest_interface::SDPOp* x1_op) {
  delete x1_op_;
  x1_op_ = x1_op;
  if (x1_op) {
    set_has_x1_op();
  } else {
    clear_has_x1_op();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.SDPOpDesc.x1_op)
}

// required .nvdla_prototest_interface.SDPOp x2_op = 10;
inline bool SDPOpDesc::has_x2_op() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SDPOpDesc::set_has_x2_op() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SDPOpDesc::clear_has_x2_op() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SDPOpDesc::clear_x2_op() {
  if (x2_op_ != NULL) x2_op_->::nvdla_prototest_interface::SDPOp::Clear();
  clear_has_x2_op();
}
inline const ::nvdla_prototest_interface::SDPOp& SDPOpDesc::x2_op() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOpDesc.x2_op)
  return x2_op_ != NULL ? *x2_op_ : *default_instance_->x2_op_;
}
inline ::nvdla_prototest_interface::SDPOp* SDPOpDesc::mutable_x2_op() {
  set_has_x2_op();
  if (x2_op_ == NULL) x2_op_ = new ::nvdla_prototest_interface::SDPOp;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.SDPOpDesc.x2_op)
  return x2_op_;
}
inline ::nvdla_prototest_interface::SDPOp* SDPOpDesc::release_x2_op() {
  clear_has_x2_op();
  ::nvdla_prototest_interface::SDPOp* temp = x2_op_;
  x2_op_ = NULL;
  return temp;
}
inline void SDPOpDesc::set_allocated_x2_op(::nvdla_prototest_interface::SDPOp* x2_op) {
  delete x2_op_;
  x2_op_ = x2_op;
  if (x2_op) {
    set_has_x2_op();
  } else {
    clear_has_x2_op();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.SDPOpDesc.x2_op)
}

// required .nvdla_prototest_interface.SDPOp y_op = 11;
inline bool SDPOpDesc::has_y_op() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SDPOpDesc::set_has_y_op() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SDPOpDesc::clear_has_y_op() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SDPOpDesc::clear_y_op() {
  if (y_op_ != NULL) y_op_->::nvdla_prototest_interface::SDPOp::Clear();
  clear_has_y_op();
}
inline const ::nvdla_prototest_interface::SDPOp& SDPOpDesc::y_op() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SDPOpDesc.y_op)
  return y_op_ != NULL ? *y_op_ : *default_instance_->y_op_;
}
inline ::nvdla_prototest_interface::SDPOp* SDPOpDesc::mutable_y_op() {
  set_has_y_op();
  if (y_op_ == NULL) y_op_ = new ::nvdla_prototest_interface::SDPOp;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.SDPOpDesc.y_op)
  return y_op_;
}
inline ::nvdla_prototest_interface::SDPOp* SDPOpDesc::release_y_op() {
  clear_has_y_op();
  ::nvdla_prototest_interface::SDPOp* temp = y_op_;
  y_op_ = NULL;
  return temp;
}
inline void SDPOpDesc::set_allocated_y_op(::nvdla_prototest_interface::SDPOp* y_op) {
  delete y_op_;
  y_op_ = y_op;
  if (y_op) {
    set_has_y_op();
  } else {
    clear_has_y_op();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.SDPOpDesc.y_op)
}

// -------------------------------------------------------------------

// PDPSurfaceDesc

// required .nvdla_prototest_interface.DataCube src_data = 1;
inline bool PDPSurfaceDesc::has_src_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PDPSurfaceDesc::set_has_src_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PDPSurfaceDesc::clear_has_src_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PDPSurfaceDesc::clear_src_data() {
  if (src_data_ != NULL) src_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_src_data();
}
inline const ::nvdla_prototest_interface::DataCube& PDPSurfaceDesc::src_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPSurfaceDesc.src_data)
  return src_data_ != NULL ? *src_data_ : *default_instance_->src_data_;
}
inline ::nvdla_prototest_interface::DataCube* PDPSurfaceDesc::mutable_src_data() {
  set_has_src_data();
  if (src_data_ == NULL) src_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.PDPSurfaceDesc.src_data)
  return src_data_;
}
inline ::nvdla_prototest_interface::DataCube* PDPSurfaceDesc::release_src_data() {
  clear_has_src_data();
  ::nvdla_prototest_interface::DataCube* temp = src_data_;
  src_data_ = NULL;
  return temp;
}
inline void PDPSurfaceDesc::set_allocated_src_data(::nvdla_prototest_interface::DataCube* src_data) {
  delete src_data_;
  src_data_ = src_data;
  if (src_data) {
    set_has_src_data();
  } else {
    clear_has_src_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.PDPSurfaceDesc.src_data)
}

// required .nvdla_prototest_interface.DataCube dst_data = 2;
inline bool PDPSurfaceDesc::has_dst_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PDPSurfaceDesc::set_has_dst_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PDPSurfaceDesc::clear_has_dst_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PDPSurfaceDesc::clear_dst_data() {
  if (dst_data_ != NULL) dst_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_dst_data();
}
inline const ::nvdla_prototest_interface::DataCube& PDPSurfaceDesc::dst_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPSurfaceDesc.dst_data)
  return dst_data_ != NULL ? *dst_data_ : *default_instance_->dst_data_;
}
inline ::nvdla_prototest_interface::DataCube* PDPSurfaceDesc::mutable_dst_data() {
  set_has_dst_data();
  if (dst_data_ == NULL) dst_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.PDPSurfaceDesc.dst_data)
  return dst_data_;
}
inline ::nvdla_prototest_interface::DataCube* PDPSurfaceDesc::release_dst_data() {
  clear_has_dst_data();
  ::nvdla_prototest_interface::DataCube* temp = dst_data_;
  dst_data_ = NULL;
  return temp;
}
inline void PDPSurfaceDesc::set_allocated_dst_data(::nvdla_prototest_interface::DataCube* dst_data) {
  delete dst_data_;
  dst_data_ = dst_data;
  if (dst_data) {
    set_has_dst_data();
  } else {
    clear_has_dst_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.PDPSurfaceDesc.dst_data)
}

// -------------------------------------------------------------------

// PDPOpDesc

// required uint32 partial_in_width_first = 1;
inline bool PDPOpDesc::has_partial_in_width_first() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PDPOpDesc::set_has_partial_in_width_first() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PDPOpDesc::clear_has_partial_in_width_first() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PDPOpDesc::clear_partial_in_width_first() {
  partial_in_width_first_ = 0u;
  clear_has_partial_in_width_first();
}
inline ::google::protobuf::uint32 PDPOpDesc::partial_in_width_first() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.partial_in_width_first)
  return partial_in_width_first_;
}
inline void PDPOpDesc::set_partial_in_width_first(::google::protobuf::uint32 value) {
  set_has_partial_in_width_first();
  partial_in_width_first_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.partial_in_width_first)
}

// required uint32 partial_in_width_mid = 2;
inline bool PDPOpDesc::has_partial_in_width_mid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PDPOpDesc::set_has_partial_in_width_mid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PDPOpDesc::clear_has_partial_in_width_mid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PDPOpDesc::clear_partial_in_width_mid() {
  partial_in_width_mid_ = 0u;
  clear_has_partial_in_width_mid();
}
inline ::google::protobuf::uint32 PDPOpDesc::partial_in_width_mid() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.partial_in_width_mid)
  return partial_in_width_mid_;
}
inline void PDPOpDesc::set_partial_in_width_mid(::google::protobuf::uint32 value) {
  set_has_partial_in_width_mid();
  partial_in_width_mid_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.partial_in_width_mid)
}

// required uint32 partial_in_width_last = 3;
inline bool PDPOpDesc::has_partial_in_width_last() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PDPOpDesc::set_has_partial_in_width_last() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PDPOpDesc::clear_has_partial_in_width_last() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PDPOpDesc::clear_partial_in_width_last() {
  partial_in_width_last_ = 0u;
  clear_has_partial_in_width_last();
}
inline ::google::protobuf::uint32 PDPOpDesc::partial_in_width_last() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.partial_in_width_last)
  return partial_in_width_last_;
}
inline void PDPOpDesc::set_partial_in_width_last(::google::protobuf::uint32 value) {
  set_has_partial_in_width_last();
  partial_in_width_last_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.partial_in_width_last)
}

// required uint32 partial_width_first = 4;
inline bool PDPOpDesc::has_partial_width_first() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PDPOpDesc::set_has_partial_width_first() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PDPOpDesc::clear_has_partial_width_first() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PDPOpDesc::clear_partial_width_first() {
  partial_width_first_ = 0u;
  clear_has_partial_width_first();
}
inline ::google::protobuf::uint32 PDPOpDesc::partial_width_first() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.partial_width_first)
  return partial_width_first_;
}
inline void PDPOpDesc::set_partial_width_first(::google::protobuf::uint32 value) {
  set_has_partial_width_first();
  partial_width_first_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.partial_width_first)
}

// required uint32 partial_width_mid = 5;
inline bool PDPOpDesc::has_partial_width_mid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PDPOpDesc::set_has_partial_width_mid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PDPOpDesc::clear_has_partial_width_mid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PDPOpDesc::clear_partial_width_mid() {
  partial_width_mid_ = 0u;
  clear_has_partial_width_mid();
}
inline ::google::protobuf::uint32 PDPOpDesc::partial_width_mid() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.partial_width_mid)
  return partial_width_mid_;
}
inline void PDPOpDesc::set_partial_width_mid(::google::protobuf::uint32 value) {
  set_has_partial_width_mid();
  partial_width_mid_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.partial_width_mid)
}

// required uint32 partial_width_last = 6;
inline bool PDPOpDesc::has_partial_width_last() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PDPOpDesc::set_has_partial_width_last() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PDPOpDesc::clear_has_partial_width_last() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PDPOpDesc::clear_partial_width_last() {
  partial_width_last_ = 0u;
  clear_has_partial_width_last();
}
inline ::google::protobuf::uint32 PDPOpDesc::partial_width_last() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.partial_width_last)
  return partial_width_last_;
}
inline void PDPOpDesc::set_partial_width_last(::google::protobuf::uint32 value) {
  set_has_partial_width_last();
  partial_width_last_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.partial_width_last)
}

// required uint32 split_num = 7;
inline bool PDPOpDesc::has_split_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PDPOpDesc::set_has_split_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PDPOpDesc::clear_has_split_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PDPOpDesc::clear_split_num() {
  split_num_ = 0u;
  clear_has_split_num();
}
inline ::google::protobuf::uint32 PDPOpDesc::split_num() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.split_num)
  return split_num_;
}
inline void PDPOpDesc::set_split_num(::google::protobuf::uint32 value) {
  set_has_split_num();
  split_num_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.split_num)
}

// required .nvdla_prototest_interface.PDPOpDesc.PoolingMode pool_mode = 8;
inline bool PDPOpDesc::has_pool_mode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PDPOpDesc::set_has_pool_mode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PDPOpDesc::clear_has_pool_mode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PDPOpDesc::clear_pool_mode() {
  pool_mode_ = 0;
  clear_has_pool_mode();
}
inline ::nvdla_prototest_interface::PDPOpDesc_PoolingMode PDPOpDesc::pool_mode() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.pool_mode)
  return static_cast< ::nvdla_prototest_interface::PDPOpDesc_PoolingMode >(pool_mode_);
}
inline void PDPOpDesc::set_pool_mode(::nvdla_prototest_interface::PDPOpDesc_PoolingMode value) {
  assert(::nvdla_prototest_interface::PDPOpDesc_PoolingMode_IsValid(value));
  set_has_pool_mode();
  pool_mode_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.pool_mode)
}

// required .nvdla_prototest_interface.PoolSize pool_width = 9;
inline bool PDPOpDesc::has_pool_width() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PDPOpDesc::set_has_pool_width() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PDPOpDesc::clear_has_pool_width() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PDPOpDesc::clear_pool_width() {
  pool_width_ = 0;
  clear_has_pool_width();
}
inline ::nvdla_prototest_interface::PoolSize PDPOpDesc::pool_width() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.pool_width)
  return static_cast< ::nvdla_prototest_interface::PoolSize >(pool_width_);
}
inline void PDPOpDesc::set_pool_width(::nvdla_prototest_interface::PoolSize value) {
  assert(::nvdla_prototest_interface::PoolSize_IsValid(value));
  set_has_pool_width();
  pool_width_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.pool_width)
}

// required .nvdla_prototest_interface.PoolSize pool_height = 10;
inline bool PDPOpDesc::has_pool_height() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PDPOpDesc::set_has_pool_height() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PDPOpDesc::clear_has_pool_height() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PDPOpDesc::clear_pool_height() {
  pool_height_ = 0;
  clear_has_pool_height();
}
inline ::nvdla_prototest_interface::PoolSize PDPOpDesc::pool_height() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.pool_height)
  return static_cast< ::nvdla_prototest_interface::PoolSize >(pool_height_);
}
inline void PDPOpDesc::set_pool_height(::nvdla_prototest_interface::PoolSize value) {
  assert(::nvdla_prototest_interface::PoolSize_IsValid(value));
  set_has_pool_height();
  pool_height_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.pool_height)
}

// required uint32 stride_x = 11;
inline bool PDPOpDesc::has_stride_x() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PDPOpDesc::set_has_stride_x() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PDPOpDesc::clear_has_stride_x() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PDPOpDesc::clear_stride_x() {
  stride_x_ = 0u;
  clear_has_stride_x();
}
inline ::google::protobuf::uint32 PDPOpDesc::stride_x() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.stride_x)
  return stride_x_;
}
inline void PDPOpDesc::set_stride_x(::google::protobuf::uint32 value) {
  set_has_stride_x();
  stride_x_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.stride_x)
}

// required uint32 stride_y = 12;
inline bool PDPOpDesc::has_stride_y() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PDPOpDesc::set_has_stride_y() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PDPOpDesc::clear_has_stride_y() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PDPOpDesc::clear_stride_y() {
  stride_y_ = 0u;
  clear_has_stride_y();
}
inline ::google::protobuf::uint32 PDPOpDesc::stride_y() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.stride_y)
  return stride_y_;
}
inline void PDPOpDesc::set_stride_y(::google::protobuf::uint32 value) {
  set_has_stride_y();
  stride_y_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.stride_y)
}

// required uint32 pad_left = 13;
inline bool PDPOpDesc::has_pad_left() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PDPOpDesc::set_has_pad_left() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PDPOpDesc::clear_has_pad_left() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PDPOpDesc::clear_pad_left() {
  pad_left_ = 0u;
  clear_has_pad_left();
}
inline ::google::protobuf::uint32 PDPOpDesc::pad_left() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.pad_left)
  return pad_left_;
}
inline void PDPOpDesc::set_pad_left(::google::protobuf::uint32 value) {
  set_has_pad_left();
  pad_left_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.pad_left)
}

// required uint32 pad_right = 14;
inline bool PDPOpDesc::has_pad_right() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PDPOpDesc::set_has_pad_right() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PDPOpDesc::clear_has_pad_right() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PDPOpDesc::clear_pad_right() {
  pad_right_ = 0u;
  clear_has_pad_right();
}
inline ::google::protobuf::uint32 PDPOpDesc::pad_right() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.pad_right)
  return pad_right_;
}
inline void PDPOpDesc::set_pad_right(::google::protobuf::uint32 value) {
  set_has_pad_right();
  pad_right_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.pad_right)
}

// required uint32 pad_top = 15;
inline bool PDPOpDesc::has_pad_top() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PDPOpDesc::set_has_pad_top() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PDPOpDesc::clear_has_pad_top() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PDPOpDesc::clear_pad_top() {
  pad_top_ = 0u;
  clear_has_pad_top();
}
inline ::google::protobuf::uint32 PDPOpDesc::pad_top() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.pad_top)
  return pad_top_;
}
inline void PDPOpDesc::set_pad_top(::google::protobuf::uint32 value) {
  set_has_pad_top();
  pad_top_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.pad_top)
}

// required uint32 pad_bottom = 16;
inline bool PDPOpDesc::has_pad_bottom() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PDPOpDesc::set_has_pad_bottom() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PDPOpDesc::clear_has_pad_bottom() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PDPOpDesc::clear_pad_bottom() {
  pad_bottom_ = 0u;
  clear_has_pad_bottom();
}
inline ::google::protobuf::uint32 PDPOpDesc::pad_bottom() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.pad_bottom)
  return pad_bottom_;
}
inline void PDPOpDesc::set_pad_bottom(::google::protobuf::uint32 value) {
  set_has_pad_bottom();
  pad_bottom_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.pad_bottom)
}

// required .nvdla_prototest_interface.DataPrecision precision = 17;
inline bool PDPOpDesc::has_precision() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PDPOpDesc::set_has_precision() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PDPOpDesc::clear_has_precision() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PDPOpDesc::clear_precision() {
  precision_ = 0;
  clear_has_precision();
}
inline ::nvdla_prototest_interface::DataPrecision PDPOpDesc::precision() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.precision)
  return static_cast< ::nvdla_prototest_interface::DataPrecision >(precision_);
}
inline void PDPOpDesc::set_precision(::nvdla_prototest_interface::DataPrecision value) {
  assert(::nvdla_prototest_interface::DataPrecision_IsValid(value));
  set_has_precision();
  precision_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.precision)
}

// optional uint32 reserved0 = 18 [default = 0];
inline bool PDPOpDesc::has_reserved0() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PDPOpDesc::set_has_reserved0() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PDPOpDesc::clear_has_reserved0() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PDPOpDesc::clear_reserved0() {
  reserved0_ = 0u;
  clear_has_reserved0();
}
inline ::google::protobuf::uint32 PDPOpDesc::reserved0() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.reserved0)
  return reserved0_;
}
inline void PDPOpDesc::set_reserved0(::google::protobuf::uint32 value) {
  set_has_reserved0();
  reserved0_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.reserved0)
}

// repeated int32 padding_value = 19 [packed = true];
inline int PDPOpDesc::padding_value_size() const {
  return padding_value_.size();
}
inline void PDPOpDesc::clear_padding_value() {
  padding_value_.Clear();
}
inline ::google::protobuf::int32 PDPOpDesc::padding_value(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.PDPOpDesc.padding_value)
  return padding_value_.Get(index);
}
inline void PDPOpDesc::set_padding_value(int index, ::google::protobuf::int32 value) {
  padding_value_.Set(index, value);
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.PDPOpDesc.padding_value)
}
inline void PDPOpDesc::add_padding_value(::google::protobuf::int32 value) {
  padding_value_.Add(value);
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.PDPOpDesc.padding_value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PDPOpDesc::padding_value() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.PDPOpDesc.padding_value)
  return padding_value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PDPOpDesc::mutable_padding_value() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.PDPOpDesc.padding_value)
  return &padding_value_;
}

// -------------------------------------------------------------------

// CDPSurfaceDesc

// required .nvdla_prototest_interface.DataCube src_data = 1;
inline bool CDPSurfaceDesc::has_src_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CDPSurfaceDesc::set_has_src_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CDPSurfaceDesc::clear_has_src_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CDPSurfaceDesc::clear_src_data() {
  if (src_data_ != NULL) src_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_src_data();
}
inline const ::nvdla_prototest_interface::DataCube& CDPSurfaceDesc::src_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CDPSurfaceDesc.src_data)
  return src_data_ != NULL ? *src_data_ : *default_instance_->src_data_;
}
inline ::nvdla_prototest_interface::DataCube* CDPSurfaceDesc::mutable_src_data() {
  set_has_src_data();
  if (src_data_ == NULL) src_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.CDPSurfaceDesc.src_data)
  return src_data_;
}
inline ::nvdla_prototest_interface::DataCube* CDPSurfaceDesc::release_src_data() {
  clear_has_src_data();
  ::nvdla_prototest_interface::DataCube* temp = src_data_;
  src_data_ = NULL;
  return temp;
}
inline void CDPSurfaceDesc::set_allocated_src_data(::nvdla_prototest_interface::DataCube* src_data) {
  delete src_data_;
  src_data_ = src_data;
  if (src_data) {
    set_has_src_data();
  } else {
    clear_has_src_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.CDPSurfaceDesc.src_data)
}

// required .nvdla_prototest_interface.DataCube dst_data = 2;
inline bool CDPSurfaceDesc::has_dst_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CDPSurfaceDesc::set_has_dst_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CDPSurfaceDesc::clear_has_dst_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CDPSurfaceDesc::clear_dst_data() {
  if (dst_data_ != NULL) dst_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_dst_data();
}
inline const ::nvdla_prototest_interface::DataCube& CDPSurfaceDesc::dst_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CDPSurfaceDesc.dst_data)
  return dst_data_ != NULL ? *dst_data_ : *default_instance_->dst_data_;
}
inline ::nvdla_prototest_interface::DataCube* CDPSurfaceDesc::mutable_dst_data() {
  set_has_dst_data();
  if (dst_data_ == NULL) dst_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.CDPSurfaceDesc.dst_data)
  return dst_data_;
}
inline ::nvdla_prototest_interface::DataCube* CDPSurfaceDesc::release_dst_data() {
  clear_has_dst_data();
  ::nvdla_prototest_interface::DataCube* temp = dst_data_;
  dst_data_ = NULL;
  return temp;
}
inline void CDPSurfaceDesc::set_allocated_dst_data(::nvdla_prototest_interface::DataCube* dst_data) {
  delete dst_data_;
  dst_data_ = dst_data;
  if (dst_data) {
    set_has_dst_data();
  } else {
    clear_has_dst_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.CDPSurfaceDesc.dst_data)
}

// -------------------------------------------------------------------

// CDPOpDesc

// required .nvdla_prototest_interface.DataPrecision in_precision = 1;
inline bool CDPOpDesc::has_in_precision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CDPOpDesc::set_has_in_precision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CDPOpDesc::clear_has_in_precision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CDPOpDesc::clear_in_precision() {
  in_precision_ = 0;
  clear_has_in_precision();
}
inline ::nvdla_prototest_interface::DataPrecision CDPOpDesc::in_precision() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CDPOpDesc.in_precision)
  return static_cast< ::nvdla_prototest_interface::DataPrecision >(in_precision_);
}
inline void CDPOpDesc::set_in_precision(::nvdla_prototest_interface::DataPrecision value) {
  assert(::nvdla_prototest_interface::DataPrecision_IsValid(value));
  set_has_in_precision();
  in_precision_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CDPOpDesc.in_precision)
}

// required .nvdla_prototest_interface.DataPrecision out_precision = 2;
inline bool CDPOpDesc::has_out_precision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CDPOpDesc::set_has_out_precision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CDPOpDesc::clear_has_out_precision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CDPOpDesc::clear_out_precision() {
  out_precision_ = 0;
  clear_has_out_precision();
}
inline ::nvdla_prototest_interface::DataPrecision CDPOpDesc::out_precision() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CDPOpDesc.out_precision)
  return static_cast< ::nvdla_prototest_interface::DataPrecision >(out_precision_);
}
inline void CDPOpDesc::set_out_precision(::nvdla_prototest_interface::DataPrecision value) {
  assert(::nvdla_prototest_interface::DataPrecision_IsValid(value));
  set_has_out_precision();
  out_precision_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CDPOpDesc.out_precision)
}

// required int32 lut_index = 3;
inline bool CDPOpDesc::has_lut_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CDPOpDesc::set_has_lut_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CDPOpDesc::clear_has_lut_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CDPOpDesc::clear_lut_index() {
  lut_index_ = 0;
  clear_has_lut_index();
}
inline ::google::protobuf::int32 CDPOpDesc::lut_index() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CDPOpDesc.lut_index)
  return lut_index_;
}
inline void CDPOpDesc::set_lut_index(::google::protobuf::int32 value) {
  set_has_lut_index();
  lut_index_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CDPOpDesc.lut_index)
}

// required .nvdla_prototest_interface.CVTParam in_cvt = 4;
inline bool CDPOpDesc::has_in_cvt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CDPOpDesc::set_has_in_cvt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CDPOpDesc::clear_has_in_cvt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CDPOpDesc::clear_in_cvt() {
  if (in_cvt_ != NULL) in_cvt_->::nvdla_prototest_interface::CVTParam::Clear();
  clear_has_in_cvt();
}
inline const ::nvdla_prototest_interface::CVTParam& CDPOpDesc::in_cvt() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CDPOpDesc.in_cvt)
  return in_cvt_ != NULL ? *in_cvt_ : *default_instance_->in_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* CDPOpDesc::mutable_in_cvt() {
  set_has_in_cvt();
  if (in_cvt_ == NULL) in_cvt_ = new ::nvdla_prototest_interface::CVTParam;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.CDPOpDesc.in_cvt)
  return in_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* CDPOpDesc::release_in_cvt() {
  clear_has_in_cvt();
  ::nvdla_prototest_interface::CVTParam* temp = in_cvt_;
  in_cvt_ = NULL;
  return temp;
}
inline void CDPOpDesc::set_allocated_in_cvt(::nvdla_prototest_interface::CVTParam* in_cvt) {
  delete in_cvt_;
  in_cvt_ = in_cvt;
  if (in_cvt) {
    set_has_in_cvt();
  } else {
    clear_has_in_cvt();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.CDPOpDesc.in_cvt)
}

// required .nvdla_prototest_interface.CVTParam out_cvt = 5;
inline bool CDPOpDesc::has_out_cvt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CDPOpDesc::set_has_out_cvt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CDPOpDesc::clear_has_out_cvt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CDPOpDesc::clear_out_cvt() {
  if (out_cvt_ != NULL) out_cvt_->::nvdla_prototest_interface::CVTParam::Clear();
  clear_has_out_cvt();
}
inline const ::nvdla_prototest_interface::CVTParam& CDPOpDesc::out_cvt() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CDPOpDesc.out_cvt)
  return out_cvt_ != NULL ? *out_cvt_ : *default_instance_->out_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* CDPOpDesc::mutable_out_cvt() {
  set_has_out_cvt();
  if (out_cvt_ == NULL) out_cvt_ = new ::nvdla_prototest_interface::CVTParam;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.CDPOpDesc.out_cvt)
  return out_cvt_;
}
inline ::nvdla_prototest_interface::CVTParam* CDPOpDesc::release_out_cvt() {
  clear_has_out_cvt();
  ::nvdla_prototest_interface::CVTParam* temp = out_cvt_;
  out_cvt_ = NULL;
  return temp;
}
inline void CDPOpDesc::set_allocated_out_cvt(::nvdla_prototest_interface::CVTParam* out_cvt) {
  delete out_cvt_;
  out_cvt_ = out_cvt;
  if (out_cvt) {
    set_has_out_cvt();
  } else {
    clear_has_out_cvt();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.CDPOpDesc.out_cvt)
}

// required uint32 local_size = 6;
inline bool CDPOpDesc::has_local_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CDPOpDesc::set_has_local_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CDPOpDesc::clear_has_local_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CDPOpDesc::clear_local_size() {
  local_size_ = 0u;
  clear_has_local_size();
}
inline ::google::protobuf::uint32 CDPOpDesc::local_size() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CDPOpDesc.local_size)
  return local_size_;
}
inline void CDPOpDesc::set_local_size(::google::protobuf::uint32 value) {
  set_has_local_size();
  local_size_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CDPOpDesc.local_size)
}

// required uint32 bypass_sqsum = 7;
inline bool CDPOpDesc::has_bypass_sqsum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CDPOpDesc::set_has_bypass_sqsum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CDPOpDesc::clear_has_bypass_sqsum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CDPOpDesc::clear_bypass_sqsum() {
  bypass_sqsum_ = 0u;
  clear_has_bypass_sqsum();
}
inline ::google::protobuf::uint32 CDPOpDesc::bypass_sqsum() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CDPOpDesc.bypass_sqsum)
  return bypass_sqsum_;
}
inline void CDPOpDesc::set_bypass_sqsum(::google::protobuf::uint32 value) {
  set_has_bypass_sqsum();
  bypass_sqsum_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CDPOpDesc.bypass_sqsum)
}

// required uint32 bypass_out_mul = 8;
inline bool CDPOpDesc::has_bypass_out_mul() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CDPOpDesc::set_has_bypass_out_mul() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CDPOpDesc::clear_has_bypass_out_mul() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CDPOpDesc::clear_bypass_out_mul() {
  bypass_out_mul_ = 0u;
  clear_has_bypass_out_mul();
}
inline ::google::protobuf::uint32 CDPOpDesc::bypass_out_mul() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CDPOpDesc.bypass_out_mul)
  return bypass_out_mul_;
}
inline void CDPOpDesc::set_bypass_out_mul(::google::protobuf::uint32 value) {
  set_has_bypass_out_mul();
  bypass_out_mul_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CDPOpDesc.bypass_out_mul)
}

// optional uint32 reserved0 = 9 [default = 0];
inline bool CDPOpDesc::has_reserved0() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CDPOpDesc::set_has_reserved0() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CDPOpDesc::clear_has_reserved0() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CDPOpDesc::clear_reserved0() {
  reserved0_ = 0u;
  clear_has_reserved0();
}
inline ::google::protobuf::uint32 CDPOpDesc::reserved0() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.CDPOpDesc.reserved0)
  return reserved0_;
}
inline void CDPOpDesc::set_reserved0(::google::protobuf::uint32 value) {
  set_has_reserved0();
  reserved0_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.CDPOpDesc.reserved0)
}

// -------------------------------------------------------------------

// RUBIKSurfaceDesc

// required .nvdla_prototest_interface.DataCube src_data = 1;
inline bool RUBIKSurfaceDesc::has_src_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RUBIKSurfaceDesc::set_has_src_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RUBIKSurfaceDesc::clear_has_src_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RUBIKSurfaceDesc::clear_src_data() {
  if (src_data_ != NULL) src_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_src_data();
}
inline const ::nvdla_prototest_interface::DataCube& RUBIKSurfaceDesc::src_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.RUBIKSurfaceDesc.src_data)
  return src_data_ != NULL ? *src_data_ : *default_instance_->src_data_;
}
inline ::nvdla_prototest_interface::DataCube* RUBIKSurfaceDesc::mutable_src_data() {
  set_has_src_data();
  if (src_data_ == NULL) src_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.RUBIKSurfaceDesc.src_data)
  return src_data_;
}
inline ::nvdla_prototest_interface::DataCube* RUBIKSurfaceDesc::release_src_data() {
  clear_has_src_data();
  ::nvdla_prototest_interface::DataCube* temp = src_data_;
  src_data_ = NULL;
  return temp;
}
inline void RUBIKSurfaceDesc::set_allocated_src_data(::nvdla_prototest_interface::DataCube* src_data) {
  delete src_data_;
  src_data_ = src_data;
  if (src_data) {
    set_has_src_data();
  } else {
    clear_has_src_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.RUBIKSurfaceDesc.src_data)
}

// required .nvdla_prototest_interface.DataCube dst_data = 2;
inline bool RUBIKSurfaceDesc::has_dst_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RUBIKSurfaceDesc::set_has_dst_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RUBIKSurfaceDesc::clear_has_dst_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RUBIKSurfaceDesc::clear_dst_data() {
  if (dst_data_ != NULL) dst_data_->::nvdla_prototest_interface::DataCube::Clear();
  clear_has_dst_data();
}
inline const ::nvdla_prototest_interface::DataCube& RUBIKSurfaceDesc::dst_data() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.RUBIKSurfaceDesc.dst_data)
  return dst_data_ != NULL ? *dst_data_ : *default_instance_->dst_data_;
}
inline ::nvdla_prototest_interface::DataCube* RUBIKSurfaceDesc::mutable_dst_data() {
  set_has_dst_data();
  if (dst_data_ == NULL) dst_data_ = new ::nvdla_prototest_interface::DataCube;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.RUBIKSurfaceDesc.dst_data)
  return dst_data_;
}
inline ::nvdla_prototest_interface::DataCube* RUBIKSurfaceDesc::release_dst_data() {
  clear_has_dst_data();
  ::nvdla_prototest_interface::DataCube* temp = dst_data_;
  dst_data_ = NULL;
  return temp;
}
inline void RUBIKSurfaceDesc::set_allocated_dst_data(::nvdla_prototest_interface::DataCube* dst_data) {
  delete dst_data_;
  dst_data_ = dst_data;
  if (dst_data) {
    set_has_dst_data();
  } else {
    clear_has_dst_data();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.RUBIKSurfaceDesc.dst_data)
}

// -------------------------------------------------------------------

// RUBIKOpDesc

// required .nvdla_prototest_interface.RUBIKMode mode = 1;
inline bool RUBIKOpDesc::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RUBIKOpDesc::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RUBIKOpDesc::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RUBIKOpDesc::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::nvdla_prototest_interface::RUBIKMode RUBIKOpDesc::mode() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.RUBIKOpDesc.mode)
  return static_cast< ::nvdla_prototest_interface::RUBIKMode >(mode_);
}
inline void RUBIKOpDesc::set_mode(::nvdla_prototest_interface::RUBIKMode value) {
  assert(::nvdla_prototest_interface::RUBIKMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.RUBIKOpDesc.mode)
}

// required .nvdla_prototest_interface.DataPrecision precision = 2;
inline bool RUBIKOpDesc::has_precision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RUBIKOpDesc::set_has_precision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RUBIKOpDesc::clear_has_precision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RUBIKOpDesc::clear_precision() {
  precision_ = 0;
  clear_has_precision();
}
inline ::nvdla_prototest_interface::DataPrecision RUBIKOpDesc::precision() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.RUBIKOpDesc.precision)
  return static_cast< ::nvdla_prototest_interface::DataPrecision >(precision_);
}
inline void RUBIKOpDesc::set_precision(::nvdla_prototest_interface::DataPrecision value) {
  assert(::nvdla_prototest_interface::DataPrecision_IsValid(value));
  set_has_precision();
  precision_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.RUBIKOpDesc.precision)
}

// required uint32 stride_x = 3;
inline bool RUBIKOpDesc::has_stride_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RUBIKOpDesc::set_has_stride_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RUBIKOpDesc::clear_has_stride_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RUBIKOpDesc::clear_stride_x() {
  stride_x_ = 0u;
  clear_has_stride_x();
}
inline ::google::protobuf::uint32 RUBIKOpDesc::stride_x() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.RUBIKOpDesc.stride_x)
  return stride_x_;
}
inline void RUBIKOpDesc::set_stride_x(::google::protobuf::uint32 value) {
  set_has_stride_x();
  stride_x_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.RUBIKOpDesc.stride_x)
}

// required uint32 stride_y = 4;
inline bool RUBIKOpDesc::has_stride_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RUBIKOpDesc::set_has_stride_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RUBIKOpDesc::clear_has_stride_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RUBIKOpDesc::clear_stride_y() {
  stride_y_ = 0u;
  clear_has_stride_y();
}
inline ::google::protobuf::uint32 RUBIKOpDesc::stride_y() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.RUBIKOpDesc.stride_y)
  return stride_y_;
}
inline void RUBIKOpDesc::set_stride_y(::google::protobuf::uint32 value) {
  set_has_stride_y();
  stride_y_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.RUBIKOpDesc.stride_y)
}

// -------------------------------------------------------------------

// SurfaceContainer

// optional .nvdla_prototest_interface.BDMASurfaceDesc bdma_surface = 1;
inline bool SurfaceContainer::has_bdma_surface() const {
  return surface_container_oneof_case() == kBdmaSurface;
}
inline void SurfaceContainer::set_has_bdma_surface() {
  _oneof_case_[0] = kBdmaSurface;
}
inline void SurfaceContainer::clear_bdma_surface() {
  if (has_bdma_surface()) {
    delete surface_container_oneof_.bdma_surface_;
    clear_has_surface_container_oneof();
  }
}
inline const ::nvdla_prototest_interface::BDMASurfaceDesc& SurfaceContainer::bdma_surface() const {
  return has_bdma_surface() ? *surface_container_oneof_.bdma_surface_
                      : ::nvdla_prototest_interface::BDMASurfaceDesc::default_instance();
}
inline ::nvdla_prototest_interface::BDMASurfaceDesc* SurfaceContainer::mutable_bdma_surface() {
  if (!has_bdma_surface()) {
    clear_surface_container_oneof();
    set_has_bdma_surface();
    surface_container_oneof_.bdma_surface_ = new ::nvdla_prototest_interface::BDMASurfaceDesc;
  }
  return surface_container_oneof_.bdma_surface_;
}
inline ::nvdla_prototest_interface::BDMASurfaceDesc* SurfaceContainer::release_bdma_surface() {
  if (has_bdma_surface()) {
    clear_has_surface_container_oneof();
    ::nvdla_prototest_interface::BDMASurfaceDesc* temp = surface_container_oneof_.bdma_surface_;
    surface_container_oneof_.bdma_surface_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SurfaceContainer::set_allocated_bdma_surface(::nvdla_prototest_interface::BDMASurfaceDesc* bdma_surface) {
  clear_surface_container_oneof();
  if (bdma_surface) {
    set_has_bdma_surface();
    surface_container_oneof_.bdma_surface_ = bdma_surface;
  }
}

// optional .nvdla_prototest_interface.CONVSurfaceDesc conv_surface = 2;
inline bool SurfaceContainer::has_conv_surface() const {
  return surface_container_oneof_case() == kConvSurface;
}
inline void SurfaceContainer::set_has_conv_surface() {
  _oneof_case_[0] = kConvSurface;
}
inline void SurfaceContainer::clear_conv_surface() {
  if (has_conv_surface()) {
    delete surface_container_oneof_.conv_surface_;
    clear_has_surface_container_oneof();
  }
}
inline const ::nvdla_prototest_interface::CONVSurfaceDesc& SurfaceContainer::conv_surface() const {
  return has_conv_surface() ? *surface_container_oneof_.conv_surface_
                      : ::nvdla_prototest_interface::CONVSurfaceDesc::default_instance();
}
inline ::nvdla_prototest_interface::CONVSurfaceDesc* SurfaceContainer::mutable_conv_surface() {
  if (!has_conv_surface()) {
    clear_surface_container_oneof();
    set_has_conv_surface();
    surface_container_oneof_.conv_surface_ = new ::nvdla_prototest_interface::CONVSurfaceDesc;
  }
  return surface_container_oneof_.conv_surface_;
}
inline ::nvdla_prototest_interface::CONVSurfaceDesc* SurfaceContainer::release_conv_surface() {
  if (has_conv_surface()) {
    clear_has_surface_container_oneof();
    ::nvdla_prototest_interface::CONVSurfaceDesc* temp = surface_container_oneof_.conv_surface_;
    surface_container_oneof_.conv_surface_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SurfaceContainer::set_allocated_conv_surface(::nvdla_prototest_interface::CONVSurfaceDesc* conv_surface) {
  clear_surface_container_oneof();
  if (conv_surface) {
    set_has_conv_surface();
    surface_container_oneof_.conv_surface_ = conv_surface;
  }
}

// optional .nvdla_prototest_interface.SDPSurfaceDesc sdp_surface = 3;
inline bool SurfaceContainer::has_sdp_surface() const {
  return surface_container_oneof_case() == kSdpSurface;
}
inline void SurfaceContainer::set_has_sdp_surface() {
  _oneof_case_[0] = kSdpSurface;
}
inline void SurfaceContainer::clear_sdp_surface() {
  if (has_sdp_surface()) {
    delete surface_container_oneof_.sdp_surface_;
    clear_has_surface_container_oneof();
  }
}
inline const ::nvdla_prototest_interface::SDPSurfaceDesc& SurfaceContainer::sdp_surface() const {
  return has_sdp_surface() ? *surface_container_oneof_.sdp_surface_
                      : ::nvdla_prototest_interface::SDPSurfaceDesc::default_instance();
}
inline ::nvdla_prototest_interface::SDPSurfaceDesc* SurfaceContainer::mutable_sdp_surface() {
  if (!has_sdp_surface()) {
    clear_surface_container_oneof();
    set_has_sdp_surface();
    surface_container_oneof_.sdp_surface_ = new ::nvdla_prototest_interface::SDPSurfaceDesc;
  }
  return surface_container_oneof_.sdp_surface_;
}
inline ::nvdla_prototest_interface::SDPSurfaceDesc* SurfaceContainer::release_sdp_surface() {
  if (has_sdp_surface()) {
    clear_has_surface_container_oneof();
    ::nvdla_prototest_interface::SDPSurfaceDesc* temp = surface_container_oneof_.sdp_surface_;
    surface_container_oneof_.sdp_surface_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SurfaceContainer::set_allocated_sdp_surface(::nvdla_prototest_interface::SDPSurfaceDesc* sdp_surface) {
  clear_surface_container_oneof();
  if (sdp_surface) {
    set_has_sdp_surface();
    surface_container_oneof_.sdp_surface_ = sdp_surface;
  }
}

// optional .nvdla_prototest_interface.PDPSurfaceDesc pdp_surface = 4;
inline bool SurfaceContainer::has_pdp_surface() const {
  return surface_container_oneof_case() == kPdpSurface;
}
inline void SurfaceContainer::set_has_pdp_surface() {
  _oneof_case_[0] = kPdpSurface;
}
inline void SurfaceContainer::clear_pdp_surface() {
  if (has_pdp_surface()) {
    delete surface_container_oneof_.pdp_surface_;
    clear_has_surface_container_oneof();
  }
}
inline const ::nvdla_prototest_interface::PDPSurfaceDesc& SurfaceContainer::pdp_surface() const {
  return has_pdp_surface() ? *surface_container_oneof_.pdp_surface_
                      : ::nvdla_prototest_interface::PDPSurfaceDesc::default_instance();
}
inline ::nvdla_prototest_interface::PDPSurfaceDesc* SurfaceContainer::mutable_pdp_surface() {
  if (!has_pdp_surface()) {
    clear_surface_container_oneof();
    set_has_pdp_surface();
    surface_container_oneof_.pdp_surface_ = new ::nvdla_prototest_interface::PDPSurfaceDesc;
  }
  return surface_container_oneof_.pdp_surface_;
}
inline ::nvdla_prototest_interface::PDPSurfaceDesc* SurfaceContainer::release_pdp_surface() {
  if (has_pdp_surface()) {
    clear_has_surface_container_oneof();
    ::nvdla_prototest_interface::PDPSurfaceDesc* temp = surface_container_oneof_.pdp_surface_;
    surface_container_oneof_.pdp_surface_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SurfaceContainer::set_allocated_pdp_surface(::nvdla_prototest_interface::PDPSurfaceDesc* pdp_surface) {
  clear_surface_container_oneof();
  if (pdp_surface) {
    set_has_pdp_surface();
    surface_container_oneof_.pdp_surface_ = pdp_surface;
  }
}

// optional .nvdla_prototest_interface.CDPSurfaceDesc cdp_surface = 5;
inline bool SurfaceContainer::has_cdp_surface() const {
  return surface_container_oneof_case() == kCdpSurface;
}
inline void SurfaceContainer::set_has_cdp_surface() {
  _oneof_case_[0] = kCdpSurface;
}
inline void SurfaceContainer::clear_cdp_surface() {
  if (has_cdp_surface()) {
    delete surface_container_oneof_.cdp_surface_;
    clear_has_surface_container_oneof();
  }
}
inline const ::nvdla_prototest_interface::CDPSurfaceDesc& SurfaceContainer::cdp_surface() const {
  return has_cdp_surface() ? *surface_container_oneof_.cdp_surface_
                      : ::nvdla_prototest_interface::CDPSurfaceDesc::default_instance();
}
inline ::nvdla_prototest_interface::CDPSurfaceDesc* SurfaceContainer::mutable_cdp_surface() {
  if (!has_cdp_surface()) {
    clear_surface_container_oneof();
    set_has_cdp_surface();
    surface_container_oneof_.cdp_surface_ = new ::nvdla_prototest_interface::CDPSurfaceDesc;
  }
  return surface_container_oneof_.cdp_surface_;
}
inline ::nvdla_prototest_interface::CDPSurfaceDesc* SurfaceContainer::release_cdp_surface() {
  if (has_cdp_surface()) {
    clear_has_surface_container_oneof();
    ::nvdla_prototest_interface::CDPSurfaceDesc* temp = surface_container_oneof_.cdp_surface_;
    surface_container_oneof_.cdp_surface_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SurfaceContainer::set_allocated_cdp_surface(::nvdla_prototest_interface::CDPSurfaceDesc* cdp_surface) {
  clear_surface_container_oneof();
  if (cdp_surface) {
    set_has_cdp_surface();
    surface_container_oneof_.cdp_surface_ = cdp_surface;
  }
}

// optional .nvdla_prototest_interface.RUBIKSurfaceDesc rubik_surface = 6;
inline bool SurfaceContainer::has_rubik_surface() const {
  return surface_container_oneof_case() == kRubikSurface;
}
inline void SurfaceContainer::set_has_rubik_surface() {
  _oneof_case_[0] = kRubikSurface;
}
inline void SurfaceContainer::clear_rubik_surface() {
  if (has_rubik_surface()) {
    delete surface_container_oneof_.rubik_surface_;
    clear_has_surface_container_oneof();
  }
}
inline const ::nvdla_prototest_interface::RUBIKSurfaceDesc& SurfaceContainer::rubik_surface() const {
  return has_rubik_surface() ? *surface_container_oneof_.rubik_surface_
                      : ::nvdla_prototest_interface::RUBIKSurfaceDesc::default_instance();
}
inline ::nvdla_prototest_interface::RUBIKSurfaceDesc* SurfaceContainer::mutable_rubik_surface() {
  if (!has_rubik_surface()) {
    clear_surface_container_oneof();
    set_has_rubik_surface();
    surface_container_oneof_.rubik_surface_ = new ::nvdla_prototest_interface::RUBIKSurfaceDesc;
  }
  return surface_container_oneof_.rubik_surface_;
}
inline ::nvdla_prototest_interface::RUBIKSurfaceDesc* SurfaceContainer::release_rubik_surface() {
  if (has_rubik_surface()) {
    clear_has_surface_container_oneof();
    ::nvdla_prototest_interface::RUBIKSurfaceDesc* temp = surface_container_oneof_.rubik_surface_;
    surface_container_oneof_.rubik_surface_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SurfaceContainer::set_allocated_rubik_surface(::nvdla_prototest_interface::RUBIKSurfaceDesc* rubik_surface) {
  clear_surface_container_oneof();
  if (rubik_surface) {
    set_has_rubik_surface();
    surface_container_oneof_.rubik_surface_ = rubik_surface;
  }
}

inline bool SurfaceContainer::has_surface_container_oneof() {
  return surface_container_oneof_case() != SURFACE_CONTAINER_ONEOF_NOT_SET;
}
inline void SurfaceContainer::clear_has_surface_container_oneof() {
  _oneof_case_[0] = SURFACE_CONTAINER_ONEOF_NOT_SET;
}
inline SurfaceContainer::SurfaceContainerOneofCase SurfaceContainer::surface_container_oneof_case() const {
  return SurfaceContainer::SurfaceContainerOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// OperationContainer

// optional .nvdla_prototest_interface.BDMAOpDesc bdma_op = 1;
inline bool OperationContainer::has_bdma_op() const {
  return op_container_oneof_case() == kBdmaOp;
}
inline void OperationContainer::set_has_bdma_op() {
  _oneof_case_[0] = kBdmaOp;
}
inline void OperationContainer::clear_bdma_op() {
  if (has_bdma_op()) {
    delete op_container_oneof_.bdma_op_;
    clear_has_op_container_oneof();
  }
}
inline const ::nvdla_prototest_interface::BDMAOpDesc& OperationContainer::bdma_op() const {
  return has_bdma_op() ? *op_container_oneof_.bdma_op_
                      : ::nvdla_prototest_interface::BDMAOpDesc::default_instance();
}
inline ::nvdla_prototest_interface::BDMAOpDesc* OperationContainer::mutable_bdma_op() {
  if (!has_bdma_op()) {
    clear_op_container_oneof();
    set_has_bdma_op();
    op_container_oneof_.bdma_op_ = new ::nvdla_prototest_interface::BDMAOpDesc;
  }
  return op_container_oneof_.bdma_op_;
}
inline ::nvdla_prototest_interface::BDMAOpDesc* OperationContainer::release_bdma_op() {
  if (has_bdma_op()) {
    clear_has_op_container_oneof();
    ::nvdla_prototest_interface::BDMAOpDesc* temp = op_container_oneof_.bdma_op_;
    op_container_oneof_.bdma_op_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void OperationContainer::set_allocated_bdma_op(::nvdla_prototest_interface::BDMAOpDesc* bdma_op) {
  clear_op_container_oneof();
  if (bdma_op) {
    set_has_bdma_op();
    op_container_oneof_.bdma_op_ = bdma_op;
  }
}

// optional .nvdla_prototest_interface.CONVOpDesc conv_op = 2;
inline bool OperationContainer::has_conv_op() const {
  return op_container_oneof_case() == kConvOp;
}
inline void OperationContainer::set_has_conv_op() {
  _oneof_case_[0] = kConvOp;
}
inline void OperationContainer::clear_conv_op() {
  if (has_conv_op()) {
    delete op_container_oneof_.conv_op_;
    clear_has_op_container_oneof();
  }
}
inline const ::nvdla_prototest_interface::CONVOpDesc& OperationContainer::conv_op() const {
  return has_conv_op() ? *op_container_oneof_.conv_op_
                      : ::nvdla_prototest_interface::CONVOpDesc::default_instance();
}
inline ::nvdla_prototest_interface::CONVOpDesc* OperationContainer::mutable_conv_op() {
  if (!has_conv_op()) {
    clear_op_container_oneof();
    set_has_conv_op();
    op_container_oneof_.conv_op_ = new ::nvdla_prototest_interface::CONVOpDesc;
  }
  return op_container_oneof_.conv_op_;
}
inline ::nvdla_prototest_interface::CONVOpDesc* OperationContainer::release_conv_op() {
  if (has_conv_op()) {
    clear_has_op_container_oneof();
    ::nvdla_prototest_interface::CONVOpDesc* temp = op_container_oneof_.conv_op_;
    op_container_oneof_.conv_op_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void OperationContainer::set_allocated_conv_op(::nvdla_prototest_interface::CONVOpDesc* conv_op) {
  clear_op_container_oneof();
  if (conv_op) {
    set_has_conv_op();
    op_container_oneof_.conv_op_ = conv_op;
  }
}

// optional .nvdla_prototest_interface.SDPOpDesc sdp_op = 3;
inline bool OperationContainer::has_sdp_op() const {
  return op_container_oneof_case() == kSdpOp;
}
inline void OperationContainer::set_has_sdp_op() {
  _oneof_case_[0] = kSdpOp;
}
inline void OperationContainer::clear_sdp_op() {
  if (has_sdp_op()) {
    delete op_container_oneof_.sdp_op_;
    clear_has_op_container_oneof();
  }
}
inline const ::nvdla_prototest_interface::SDPOpDesc& OperationContainer::sdp_op() const {
  return has_sdp_op() ? *op_container_oneof_.sdp_op_
                      : ::nvdla_prototest_interface::SDPOpDesc::default_instance();
}
inline ::nvdla_prototest_interface::SDPOpDesc* OperationContainer::mutable_sdp_op() {
  if (!has_sdp_op()) {
    clear_op_container_oneof();
    set_has_sdp_op();
    op_container_oneof_.sdp_op_ = new ::nvdla_prototest_interface::SDPOpDesc;
  }
  return op_container_oneof_.sdp_op_;
}
inline ::nvdla_prototest_interface::SDPOpDesc* OperationContainer::release_sdp_op() {
  if (has_sdp_op()) {
    clear_has_op_container_oneof();
    ::nvdla_prototest_interface::SDPOpDesc* temp = op_container_oneof_.sdp_op_;
    op_container_oneof_.sdp_op_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void OperationContainer::set_allocated_sdp_op(::nvdla_prototest_interface::SDPOpDesc* sdp_op) {
  clear_op_container_oneof();
  if (sdp_op) {
    set_has_sdp_op();
    op_container_oneof_.sdp_op_ = sdp_op;
  }
}

// optional .nvdla_prototest_interface.PDPOpDesc pdp_op = 4;
inline bool OperationContainer::has_pdp_op() const {
  return op_container_oneof_case() == kPdpOp;
}
inline void OperationContainer::set_has_pdp_op() {
  _oneof_case_[0] = kPdpOp;
}
inline void OperationContainer::clear_pdp_op() {
  if (has_pdp_op()) {
    delete op_container_oneof_.pdp_op_;
    clear_has_op_container_oneof();
  }
}
inline const ::nvdla_prototest_interface::PDPOpDesc& OperationContainer::pdp_op() const {
  return has_pdp_op() ? *op_container_oneof_.pdp_op_
                      : ::nvdla_prototest_interface::PDPOpDesc::default_instance();
}
inline ::nvdla_prototest_interface::PDPOpDesc* OperationContainer::mutable_pdp_op() {
  if (!has_pdp_op()) {
    clear_op_container_oneof();
    set_has_pdp_op();
    op_container_oneof_.pdp_op_ = new ::nvdla_prototest_interface::PDPOpDesc;
  }
  return op_container_oneof_.pdp_op_;
}
inline ::nvdla_prototest_interface::PDPOpDesc* OperationContainer::release_pdp_op() {
  if (has_pdp_op()) {
    clear_has_op_container_oneof();
    ::nvdla_prototest_interface::PDPOpDesc* temp = op_container_oneof_.pdp_op_;
    op_container_oneof_.pdp_op_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void OperationContainer::set_allocated_pdp_op(::nvdla_prototest_interface::PDPOpDesc* pdp_op) {
  clear_op_container_oneof();
  if (pdp_op) {
    set_has_pdp_op();
    op_container_oneof_.pdp_op_ = pdp_op;
  }
}

// optional .nvdla_prototest_interface.CDPOpDesc cdp_op = 5;
inline bool OperationContainer::has_cdp_op() const {
  return op_container_oneof_case() == kCdpOp;
}
inline void OperationContainer::set_has_cdp_op() {
  _oneof_case_[0] = kCdpOp;
}
inline void OperationContainer::clear_cdp_op() {
  if (has_cdp_op()) {
    delete op_container_oneof_.cdp_op_;
    clear_has_op_container_oneof();
  }
}
inline const ::nvdla_prototest_interface::CDPOpDesc& OperationContainer::cdp_op() const {
  return has_cdp_op() ? *op_container_oneof_.cdp_op_
                      : ::nvdla_prototest_interface::CDPOpDesc::default_instance();
}
inline ::nvdla_prototest_interface::CDPOpDesc* OperationContainer::mutable_cdp_op() {
  if (!has_cdp_op()) {
    clear_op_container_oneof();
    set_has_cdp_op();
    op_container_oneof_.cdp_op_ = new ::nvdla_prototest_interface::CDPOpDesc;
  }
  return op_container_oneof_.cdp_op_;
}
inline ::nvdla_prototest_interface::CDPOpDesc* OperationContainer::release_cdp_op() {
  if (has_cdp_op()) {
    clear_has_op_container_oneof();
    ::nvdla_prototest_interface::CDPOpDesc* temp = op_container_oneof_.cdp_op_;
    op_container_oneof_.cdp_op_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void OperationContainer::set_allocated_cdp_op(::nvdla_prototest_interface::CDPOpDesc* cdp_op) {
  clear_op_container_oneof();
  if (cdp_op) {
    set_has_cdp_op();
    op_container_oneof_.cdp_op_ = cdp_op;
  }
}

// optional .nvdla_prototest_interface.RUBIKOpDesc rubik_op = 6;
inline bool OperationContainer::has_rubik_op() const {
  return op_container_oneof_case() == kRubikOp;
}
inline void OperationContainer::set_has_rubik_op() {
  _oneof_case_[0] = kRubikOp;
}
inline void OperationContainer::clear_rubik_op() {
  if (has_rubik_op()) {
    delete op_container_oneof_.rubik_op_;
    clear_has_op_container_oneof();
  }
}
inline const ::nvdla_prototest_interface::RUBIKOpDesc& OperationContainer::rubik_op() const {
  return has_rubik_op() ? *op_container_oneof_.rubik_op_
                      : ::nvdla_prototest_interface::RUBIKOpDesc::default_instance();
}
inline ::nvdla_prototest_interface::RUBIKOpDesc* OperationContainer::mutable_rubik_op() {
  if (!has_rubik_op()) {
    clear_op_container_oneof();
    set_has_rubik_op();
    op_container_oneof_.rubik_op_ = new ::nvdla_prototest_interface::RUBIKOpDesc;
  }
  return op_container_oneof_.rubik_op_;
}
inline ::nvdla_prototest_interface::RUBIKOpDesc* OperationContainer::release_rubik_op() {
  if (has_rubik_op()) {
    clear_has_op_container_oneof();
    ::nvdla_prototest_interface::RUBIKOpDesc* temp = op_container_oneof_.rubik_op_;
    op_container_oneof_.rubik_op_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void OperationContainer::set_allocated_rubik_op(::nvdla_prototest_interface::RUBIKOpDesc* rubik_op) {
  clear_op_container_oneof();
  if (rubik_op) {
    set_has_rubik_op();
    op_container_oneof_.rubik_op_ = rubik_op;
  }
}

inline bool OperationContainer::has_op_container_oneof() {
  return op_container_oneof_case() != OP_CONTAINER_ONEOF_NOT_SET;
}
inline void OperationContainer::clear_has_op_container_oneof() {
  _oneof_case_[0] = OP_CONTAINER_ONEOF_NOT_SET;
}
inline OperationContainer::OpContainerOneofCase OperationContainer::op_container_oneof_case() const {
  return OperationContainer::OpContainerOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Consumer

// required int32 index = 1;
inline bool Consumer::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Consumer::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Consumer::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Consumer::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Consumer::index() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Consumer.index)
  return index_;
}
inline void Consumer::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Consumer.index)
}

// required .nvdla_prototest_interface.LayerType type = 2;
inline bool Consumer::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Consumer::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Consumer::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Consumer::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::nvdla_prototest_interface::LayerType Consumer::type() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Consumer.type)
  return static_cast< ::nvdla_prototest_interface::LayerType >(type_);
}
inline void Consumer::set_type(::nvdla_prototest_interface::LayerType value) {
  assert(::nvdla_prototest_interface::LayerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Consumer.type)
}

// required .nvdla_prototest_interface.Consumer.EventType event = 3;
inline bool Consumer::has_event() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Consumer::set_has_event() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Consumer::clear_has_event() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Consumer::clear_event() {
  event_ = 1;
  clear_has_event();
}
inline ::nvdla_prototest_interface::Consumer_EventType Consumer::event() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Consumer.event)
  return static_cast< ::nvdla_prototest_interface::Consumer_EventType >(event_);
}
inline void Consumer::set_event(::nvdla_prototest_interface::Consumer_EventType value) {
  assert(::nvdla_prototest_interface::Consumer_EventType_IsValid(value));
  set_has_event();
  event_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Consumer.event)
}

// -------------------------------------------------------------------

// Layer

// required int32 index = 1;
inline bool Layer::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Layer::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Layer::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Layer::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Layer::index() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Layer.index)
  return index_;
}
inline void Layer::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Layer.index)
}

// required int32 roi_index = 2;
inline bool Layer::has_roi_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Layer::set_has_roi_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Layer::clear_has_roi_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Layer::clear_roi_index() {
  roi_index_ = 0;
  clear_has_roi_index();
}
inline ::google::protobuf::int32 Layer::roi_index() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Layer.roi_index)
  return roi_index_;
}
inline void Layer::set_roi_index(::google::protobuf::int32 value) {
  set_has_roi_index();
  roi_index_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Layer.roi_index)
}

// required .nvdla_prototest_interface.LayerType type = 3;
inline bool Layer::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Layer::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Layer::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Layer::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::nvdla_prototest_interface::LayerType Layer::type() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Layer.type)
  return static_cast< ::nvdla_prototest_interface::LayerType >(type_);
}
inline void Layer::set_type(::nvdla_prototest_interface::LayerType value) {
  assert(::nvdla_prototest_interface::LayerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Layer.type)
}

// required uint32 dependency_count = 4;
inline bool Layer::has_dependency_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Layer::set_has_dependency_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Layer::clear_has_dependency_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Layer::clear_dependency_count() {
  dependency_count_ = 0u;
  clear_has_dependency_count();
}
inline ::google::protobuf::uint32 Layer::dependency_count() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Layer.dependency_count)
  return dependency_count_;
}
inline void Layer::set_dependency_count(::google::protobuf::uint32 value) {
  set_has_dependency_count();
  dependency_count_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Layer.dependency_count)
}

// repeated uint32 reserved = 5 [packed = true];
inline int Layer::reserved_size() const {
  return reserved_.size();
}
inline void Layer::clear_reserved() {
  reserved_.Clear();
}
inline ::google::protobuf::uint32 Layer::reserved(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Layer.reserved)
  return reserved_.Get(index);
}
inline void Layer::set_reserved(int index, ::google::protobuf::uint32 value) {
  reserved_.Set(index, value);
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Layer.reserved)
}
inline void Layer::add_reserved(::google::protobuf::uint32 value) {
  reserved_.Add(value);
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.Layer.reserved)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Layer::reserved() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.Layer.reserved)
  return reserved_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Layer::mutable_reserved() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.Layer.reserved)
  return &reserved_;
}

// repeated .nvdla_prototest_interface.Consumer bottom = 6;
inline int Layer::bottom_size() const {
  return bottom_.size();
}
inline void Layer::clear_bottom() {
  bottom_.Clear();
}
inline const ::nvdla_prototest_interface::Consumer& Layer::bottom(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Layer.bottom)
  return bottom_.Get(index);
}
inline ::nvdla_prototest_interface::Consumer* Layer::mutable_bottom(int index) {
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.Layer.bottom)
  return bottom_.Mutable(index);
}
inline ::nvdla_prototest_interface::Consumer* Layer::add_bottom() {
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.Layer.bottom)
  return bottom_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Consumer >&
Layer::bottom() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.Layer.bottom)
  return bottom_;
}
inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Consumer >*
Layer::mutable_bottom() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.Layer.bottom)
  return &bottom_;
}

// optional .nvdla_prototest_interface.Consumer fused = 7;
inline bool Layer::has_fused() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Layer::set_has_fused() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Layer::clear_has_fused() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Layer::clear_fused() {
  if (fused_ != NULL) fused_->::nvdla_prototest_interface::Consumer::Clear();
  clear_has_fused();
}
inline const ::nvdla_prototest_interface::Consumer& Layer::fused() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Layer.fused)
  return fused_ != NULL ? *fused_ : *default_instance_->fused_;
}
inline ::nvdla_prototest_interface::Consumer* Layer::mutable_fused() {
  set_has_fused();
  if (fused_ == NULL) fused_ = new ::nvdla_prototest_interface::Consumer;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.Layer.fused)
  return fused_;
}
inline ::nvdla_prototest_interface::Consumer* Layer::release_fused() {
  clear_has_fused();
  ::nvdla_prototest_interface::Consumer* temp = fused_;
  fused_ = NULL;
  return temp;
}
inline void Layer::set_allocated_fused(::nvdla_prototest_interface::Consumer* fused) {
  delete fused_;
  fused_ = fused;
  if (fused) {
    set_has_fused();
  } else {
    clear_has_fused();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.Layer.fused)
}

// required .nvdla_prototest_interface.OperationContainer op_config = 8;
inline bool Layer::has_op_config() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Layer::set_has_op_config() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Layer::clear_has_op_config() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Layer::clear_op_config() {
  if (op_config_ != NULL) op_config_->::nvdla_prototest_interface::OperationContainer::Clear();
  clear_has_op_config();
}
inline const ::nvdla_prototest_interface::OperationContainer& Layer::op_config() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Layer.op_config)
  return op_config_ != NULL ? *op_config_ : *default_instance_->op_config_;
}
inline ::nvdla_prototest_interface::OperationContainer* Layer::mutable_op_config() {
  set_has_op_config();
  if (op_config_ == NULL) op_config_ = new ::nvdla_prototest_interface::OperationContainer;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.Layer.op_config)
  return op_config_;
}
inline ::nvdla_prototest_interface::OperationContainer* Layer::release_op_config() {
  clear_has_op_config();
  ::nvdla_prototest_interface::OperationContainer* temp = op_config_;
  op_config_ = NULL;
  return temp;
}
inline void Layer::set_allocated_op_config(::nvdla_prototest_interface::OperationContainer* op_config) {
  delete op_config_;
  op_config_ = op_config;
  if (op_config) {
    set_has_op_config();
  } else {
    clear_has_op_config();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.Layer.op_config)
}

// required .nvdla_prototest_interface.SurfaceContainer surface = 9;
inline bool Layer::has_surface() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Layer::set_has_surface() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Layer::clear_has_surface() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Layer::clear_surface() {
  if (surface_ != NULL) surface_->::nvdla_prototest_interface::SurfaceContainer::Clear();
  clear_has_surface();
}
inline const ::nvdla_prototest_interface::SurfaceContainer& Layer::surface() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Layer.surface)
  return surface_ != NULL ? *surface_ : *default_instance_->surface_;
}
inline ::nvdla_prototest_interface::SurfaceContainer* Layer::mutable_surface() {
  set_has_surface();
  if (surface_ == NULL) surface_ = new ::nvdla_prototest_interface::SurfaceContainer;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.Layer.surface)
  return surface_;
}
inline ::nvdla_prototest_interface::SurfaceContainer* Layer::release_surface() {
  clear_has_surface();
  ::nvdla_prototest_interface::SurfaceContainer* temp = surface_;
  surface_ = NULL;
  return temp;
}
inline void Layer::set_allocated_surface(::nvdla_prototest_interface::SurfaceContainer* surface) {
  delete surface_;
  surface_ = surface;
  if (surface) {
    set_has_surface();
  } else {
    clear_has_surface();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.Layer.surface)
}

// -------------------------------------------------------------------

// NetworkLayer

// repeated .nvdla_prototest_interface.Layer layer = 1;
inline int NetworkLayer::layer_size() const {
  return layer_.size();
}
inline void NetworkLayer::clear_layer() {
  layer_.Clear();
}
inline const ::nvdla_prototest_interface::Layer& NetworkLayer::layer(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkLayer.layer)
  return layer_.Get(index);
}
inline ::nvdla_prototest_interface::Layer* NetworkLayer::mutable_layer(int index) {
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.NetworkLayer.layer)
  return layer_.Mutable(index);
}
inline ::nvdla_prototest_interface::Layer* NetworkLayer::add_layer() {
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.NetworkLayer.layer)
  return layer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Layer >&
NetworkLayer::layer() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.NetworkLayer.layer)
  return layer_;
}
inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Layer >*
NetworkLayer::mutable_layer() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.NetworkLayer.layer)
  return &layer_;
}

// -------------------------------------------------------------------

// NetworkDesc

// required int32 operation_desc_index = 1;
inline bool NetworkDesc::has_operation_desc_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkDesc::set_has_operation_desc_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkDesc::clear_has_operation_desc_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkDesc::clear_operation_desc_index() {
  operation_desc_index_ = 0;
  clear_has_operation_desc_index();
}
inline ::google::protobuf::int32 NetworkDesc::operation_desc_index() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.operation_desc_index)
  return operation_desc_index_;
}
inline void NetworkDesc::set_operation_desc_index(::google::protobuf::int32 value) {
  set_has_operation_desc_index();
  operation_desc_index_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.operation_desc_index)
}

// required int32 surface_desc_index = 2;
inline bool NetworkDesc::has_surface_desc_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkDesc::set_has_surface_desc_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkDesc::clear_has_surface_desc_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkDesc::clear_surface_desc_index() {
  surface_desc_index_ = 0;
  clear_has_surface_desc_index();
}
inline ::google::protobuf::int32 NetworkDesc::surface_desc_index() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.surface_desc_index)
  return surface_desc_index_;
}
inline void NetworkDesc::set_surface_desc_index(::google::protobuf::int32 value) {
  set_has_surface_desc_index();
  surface_desc_index_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.surface_desc_index)
}

// required int32 dependency_graph_index = 3;
inline bool NetworkDesc::has_dependency_graph_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkDesc::set_has_dependency_graph_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetworkDesc::clear_has_dependency_graph_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetworkDesc::clear_dependency_graph_index() {
  dependency_graph_index_ = 0;
  clear_has_dependency_graph_index();
}
inline ::google::protobuf::int32 NetworkDesc::dependency_graph_index() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.dependency_graph_index)
  return dependency_graph_index_;
}
inline void NetworkDesc::set_dependency_graph_index(::google::protobuf::int32 value) {
  set_has_dependency_graph_index();
  dependency_graph_index_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.dependency_graph_index)
}

// required int32 lut_data_index = 4;
inline bool NetworkDesc::has_lut_data_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetworkDesc::set_has_lut_data_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NetworkDesc::clear_has_lut_data_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NetworkDesc::clear_lut_data_index() {
  lut_data_index_ = 0;
  clear_has_lut_data_index();
}
inline ::google::protobuf::int32 NetworkDesc::lut_data_index() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.lut_data_index)
  return lut_data_index_;
}
inline void NetworkDesc::set_lut_data_index(::google::protobuf::int32 value) {
  set_has_lut_data_index();
  lut_data_index_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.lut_data_index)
}

// required int32 roi_array_index = 5;
inline bool NetworkDesc::has_roi_array_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetworkDesc::set_has_roi_array_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NetworkDesc::clear_has_roi_array_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NetworkDesc::clear_roi_array_index() {
  roi_array_index_ = 0;
  clear_has_roi_array_index();
}
inline ::google::protobuf::int32 NetworkDesc::roi_array_index() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.roi_array_index)
  return roi_array_index_;
}
inline void NetworkDesc::set_roi_array_index(::google::protobuf::int32 value) {
  set_has_roi_array_index();
  roi_array_index_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.roi_array_index)
}

// required int32 surface_index = 6;
inline bool NetworkDesc::has_surface_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NetworkDesc::set_has_surface_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NetworkDesc::clear_has_surface_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NetworkDesc::clear_surface_index() {
  surface_index_ = 0;
  clear_has_surface_index();
}
inline ::google::protobuf::int32 NetworkDesc::surface_index() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.surface_index)
  return surface_index_;
}
inline void NetworkDesc::set_surface_index(::google::protobuf::int32 value) {
  set_has_surface_index();
  surface_index_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.surface_index)
}

// optional int32 stat_list_index = 7 [default = -1];
inline bool NetworkDesc::has_stat_list_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NetworkDesc::set_has_stat_list_index() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NetworkDesc::clear_has_stat_list_index() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NetworkDesc::clear_stat_list_index() {
  stat_list_index_ = -1;
  clear_has_stat_list_index();
}
inline ::google::protobuf::int32 NetworkDesc::stat_list_index() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.stat_list_index)
  return stat_list_index_;
}
inline void NetworkDesc::set_stat_list_index(::google::protobuf::int32 value) {
  set_has_stat_list_index();
  stat_list_index_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.stat_list_index)
}

// optional int32 reserved1 = 8 [default = -1];
inline bool NetworkDesc::has_reserved1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NetworkDesc::set_has_reserved1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NetworkDesc::clear_has_reserved1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NetworkDesc::clear_reserved1() {
  reserved1_ = -1;
  clear_has_reserved1();
}
inline ::google::protobuf::int32 NetworkDesc::reserved1() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.reserved1)
  return reserved1_;
}
inline void NetworkDesc::set_reserved1(::google::protobuf::int32 value) {
  set_has_reserved1();
  reserved1_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.reserved1)
}

// repeated int32 op_head = 9 [packed = true];
inline int NetworkDesc::op_head_size() const {
  return op_head_.size();
}
inline void NetworkDesc::clear_op_head() {
  op_head_.Clear();
}
inline ::google::protobuf::int32 NetworkDesc::op_head(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.op_head)
  return op_head_.Get(index);
}
inline void NetworkDesc::set_op_head(int index, ::google::protobuf::int32 value) {
  op_head_.Set(index, value);
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.op_head)
}
inline void NetworkDesc::add_op_head(::google::protobuf::int32 value) {
  op_head_.Add(value);
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.NetworkDesc.op_head)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NetworkDesc::op_head() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.NetworkDesc.op_head)
  return op_head_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NetworkDesc::mutable_op_head() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.NetworkDesc.op_head)
  return &op_head_;
}

// required uint32 num_rois = 10;
inline bool NetworkDesc::has_num_rois() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NetworkDesc::set_has_num_rois() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NetworkDesc::clear_has_num_rois() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NetworkDesc::clear_num_rois() {
  num_rois_ = 0u;
  clear_has_num_rois();
}
inline ::google::protobuf::uint32 NetworkDesc::num_rois() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.num_rois)
  return num_rois_;
}
inline void NetworkDesc::set_num_rois(::google::protobuf::uint32 value) {
  set_has_num_rois();
  num_rois_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.num_rois)
}

// required uint32 num_operations = 11;
inline bool NetworkDesc::has_num_operations() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NetworkDesc::set_has_num_operations() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NetworkDesc::clear_has_num_operations() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NetworkDesc::clear_num_operations() {
  num_operations_ = 0u;
  clear_has_num_operations();
}
inline ::google::protobuf::uint32 NetworkDesc::num_operations() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.num_operations)
  return num_operations_;
}
inline void NetworkDesc::set_num_operations(::google::protobuf::uint32 value) {
  set_has_num_operations();
  num_operations_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.num_operations)
}

// required uint32 num_luts = 12;
inline bool NetworkDesc::has_num_luts() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NetworkDesc::set_has_num_luts() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NetworkDesc::clear_has_num_luts() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NetworkDesc::clear_num_luts() {
  num_luts_ = 0u;
  clear_has_num_luts();
}
inline ::google::protobuf::uint32 NetworkDesc::num_luts() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.num_luts)
  return num_luts_;
}
inline void NetworkDesc::set_num_luts(::google::protobuf::uint32 value) {
  set_has_num_luts();
  num_luts_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.num_luts)
}

// required uint32 num_addresses = 13;
inline bool NetworkDesc::has_num_addresses() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NetworkDesc::set_has_num_addresses() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NetworkDesc::clear_has_num_addresses() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NetworkDesc::clear_num_addresses() {
  num_addresses_ = 0u;
  clear_has_num_addresses();
}
inline ::google::protobuf::uint32 NetworkDesc::num_addresses() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.num_addresses)
  return num_addresses_;
}
inline void NetworkDesc::set_num_addresses(::google::protobuf::uint32 value) {
  set_has_num_addresses();
  num_addresses_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.num_addresses)
}

// required int32 input_layer = 14;
inline bool NetworkDesc::has_input_layer() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NetworkDesc::set_has_input_layer() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NetworkDesc::clear_has_input_layer() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NetworkDesc::clear_input_layer() {
  input_layer_ = 0;
  clear_has_input_layer();
}
inline ::google::protobuf::int32 NetworkDesc::input_layer() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.input_layer)
  return input_layer_;
}
inline void NetworkDesc::set_input_layer(::google::protobuf::int32 value) {
  set_has_input_layer();
  input_layer_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.input_layer)
}

// required uint32 dynamic_roi = 15;
inline bool NetworkDesc::has_dynamic_roi() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NetworkDesc::set_has_dynamic_roi() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NetworkDesc::clear_has_dynamic_roi() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NetworkDesc::clear_dynamic_roi() {
  dynamic_roi_ = 0u;
  clear_has_dynamic_roi();
}
inline ::google::protobuf::uint32 NetworkDesc::dynamic_roi() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.dynamic_roi)
  return dynamic_roi_;
}
inline void NetworkDesc::set_dynamic_roi(::google::protobuf::uint32 value) {
  set_has_dynamic_roi();
  dynamic_roi_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.dynamic_roi)
}

// optional uint32 reserved0 = 16 [default = 0];
inline bool NetworkDesc::has_reserved0() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NetworkDesc::set_has_reserved0() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NetworkDesc::clear_has_reserved0() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NetworkDesc::clear_reserved0() {
  reserved0_ = 0u;
  clear_has_reserved0();
}
inline ::google::protobuf::uint32 NetworkDesc::reserved0() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.NetworkDesc.reserved0)
  return reserved0_;
}
inline void NetworkDesc::set_reserved0(::google::protobuf::uint32 value) {
  set_has_reserved0();
  reserved0_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.NetworkDesc.reserved0)
}

// -------------------------------------------------------------------

// LUTParamList

// repeated .nvdla_prototest_interface.LUTParam lut_param = 1;
inline int LUTParamList::lut_param_size() const {
  return lut_param_.size();
}
inline void LUTParamList::clear_lut_param() {
  lut_param_.Clear();
}
inline const ::nvdla_prototest_interface::LUTParam& LUTParamList::lut_param(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.LUTParamList.lut_param)
  return lut_param_.Get(index);
}
inline ::nvdla_prototest_interface::LUTParam* LUTParamList::mutable_lut_param(int index) {
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.LUTParamList.lut_param)
  return lut_param_.Mutable(index);
}
inline ::nvdla_prototest_interface::LUTParam* LUTParamList::add_lut_param() {
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.LUTParamList.lut_param)
  return lut_param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::LUTParam >&
LUTParamList::lut_param() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.LUTParamList.lut_param)
  return lut_param_;
}
inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::LUTParam >*
LUTParamList::mutable_lut_param() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.LUTParamList.lut_param)
  return &lut_param_;
}

// -------------------------------------------------------------------

// ROIArrayDesc

// required uint32 array_length = 1;
inline bool ROIArrayDesc::has_array_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ROIArrayDesc::set_has_array_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ROIArrayDesc::clear_has_array_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ROIArrayDesc::clear_array_length() {
  array_length_ = 0u;
  clear_has_array_length();
}
inline ::google::protobuf::uint32 ROIArrayDesc::array_length() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.ROIArrayDesc.array_length)
  return array_length_;
}
inline void ROIArrayDesc::set_array_length(::google::protobuf::uint32 value) {
  set_has_array_length();
  array_length_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.ROIArrayDesc.array_length)
}

// required uint32 array_reserved = 2;
inline bool ROIArrayDesc::has_array_reserved() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ROIArrayDesc::set_has_array_reserved() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ROIArrayDesc::clear_has_array_reserved() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ROIArrayDesc::clear_array_reserved() {
  array_reserved_ = 0u;
  clear_has_array_reserved();
}
inline ::google::protobuf::uint32 ROIArrayDesc::array_reserved() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.ROIArrayDesc.array_reserved)
  return array_reserved_;
}
inline void ROIArrayDesc::set_array_reserved(::google::protobuf::uint32 value) {
  set_has_array_reserved();
  array_reserved_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.ROIArrayDesc.array_reserved)
}

// -------------------------------------------------------------------

// ROIDesc

// required uint32 left = 1;
inline bool ROIDesc::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ROIDesc::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ROIDesc::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ROIDesc::clear_left() {
  left_ = 0u;
  clear_has_left();
}
inline ::google::protobuf::uint32 ROIDesc::left() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.ROIDesc.left)
  return left_;
}
inline void ROIDesc::set_left(::google::protobuf::uint32 value) {
  set_has_left();
  left_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.ROIDesc.left)
}

// required uint32 top = 2;
inline bool ROIDesc::has_top() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ROIDesc::set_has_top() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ROIDesc::clear_has_top() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ROIDesc::clear_top() {
  top_ = 0u;
  clear_has_top();
}
inline ::google::protobuf::uint32 ROIDesc::top() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.ROIDesc.top)
  return top_;
}
inline void ROIDesc::set_top(::google::protobuf::uint32 value) {
  set_has_top();
  top_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.ROIDesc.top)
}

// required uint32 right = 3;
inline bool ROIDesc::has_right() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ROIDesc::set_has_right() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ROIDesc::clear_has_right() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ROIDesc::clear_right() {
  right_ = 0u;
  clear_has_right();
}
inline ::google::protobuf::uint32 ROIDesc::right() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.ROIDesc.right)
  return right_;
}
inline void ROIDesc::set_right(::google::protobuf::uint32 value) {
  set_has_right();
  right_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.ROIDesc.right)
}

// required uint32 bottom = 4;
inline bool ROIDesc::has_bottom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ROIDesc::set_has_bottom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ROIDesc::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ROIDesc::clear_bottom() {
  bottom_ = 0u;
  clear_has_bottom();
}
inline ::google::protobuf::uint32 ROIDesc::bottom() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.ROIDesc.bottom)
  return bottom_;
}
inline void ROIDesc::set_bottom(::google::protobuf::uint32 value) {
  set_has_bottom();
  bottom_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.ROIDesc.bottom)
}

// -------------------------------------------------------------------

// ROIDescription

// required .nvdla_prototest_interface.ROIArrayDesc roi_arr = 1;
inline bool ROIDescription::has_roi_arr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ROIDescription::set_has_roi_arr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ROIDescription::clear_has_roi_arr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ROIDescription::clear_roi_arr() {
  if (roi_arr_ != NULL) roi_arr_->::nvdla_prototest_interface::ROIArrayDesc::Clear();
  clear_has_roi_arr();
}
inline const ::nvdla_prototest_interface::ROIArrayDesc& ROIDescription::roi_arr() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.ROIDescription.roi_arr)
  return roi_arr_ != NULL ? *roi_arr_ : *default_instance_->roi_arr_;
}
inline ::nvdla_prototest_interface::ROIArrayDesc* ROIDescription::mutable_roi_arr() {
  set_has_roi_arr();
  if (roi_arr_ == NULL) roi_arr_ = new ::nvdla_prototest_interface::ROIArrayDesc;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.ROIDescription.roi_arr)
  return roi_arr_;
}
inline ::nvdla_prototest_interface::ROIArrayDesc* ROIDescription::release_roi_arr() {
  clear_has_roi_arr();
  ::nvdla_prototest_interface::ROIArrayDesc* temp = roi_arr_;
  roi_arr_ = NULL;
  return temp;
}
inline void ROIDescription::set_allocated_roi_arr(::nvdla_prototest_interface::ROIArrayDesc* roi_arr) {
  delete roi_arr_;
  roi_arr_ = roi_arr;
  if (roi_arr) {
    set_has_roi_arr();
  } else {
    clear_has_roi_arr();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.ROIDescription.roi_arr)
}

// repeated .nvdla_prototest_interface.ROIDesc roi_desc = 2;
inline int ROIDescription::roi_desc_size() const {
  return roi_desc_.size();
}
inline void ROIDescription::clear_roi_desc() {
  roi_desc_.Clear();
}
inline const ::nvdla_prototest_interface::ROIDesc& ROIDescription::roi_desc(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.ROIDescription.roi_desc)
  return roi_desc_.Get(index);
}
inline ::nvdla_prototest_interface::ROIDesc* ROIDescription::mutable_roi_desc(int index) {
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.ROIDescription.roi_desc)
  return roi_desc_.Mutable(index);
}
inline ::nvdla_prototest_interface::ROIDesc* ROIDescription::add_roi_desc() {
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.ROIDescription.roi_desc)
  return roi_desc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::ROIDesc >&
ROIDescription::roi_desc() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.ROIDescription.roi_desc)
  return roi_desc_;
}
inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::ROIDesc >*
ROIDescription::mutable_roi_desc() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.ROIDescription.roi_desc)
  return &roi_desc_;
}

// -------------------------------------------------------------------

// Network

// required .nvdla_prototest_interface.NetworkDesc param = 1;
inline bool Network::has_param() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Network::set_has_param() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Network::clear_has_param() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Network::clear_param() {
  if (param_ != NULL) param_->::nvdla_prototest_interface::NetworkDesc::Clear();
  clear_has_param();
}
inline const ::nvdla_prototest_interface::NetworkDesc& Network::param() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Network.param)
  return param_ != NULL ? *param_ : *default_instance_->param_;
}
inline ::nvdla_prototest_interface::NetworkDesc* Network::mutable_param() {
  set_has_param();
  if (param_ == NULL) param_ = new ::nvdla_prototest_interface::NetworkDesc;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.Network.param)
  return param_;
}
inline ::nvdla_prototest_interface::NetworkDesc* Network::release_param() {
  clear_has_param();
  ::nvdla_prototest_interface::NetworkDesc* temp = param_;
  param_ = NULL;
  return temp;
}
inline void Network::set_allocated_param(::nvdla_prototest_interface::NetworkDesc* param) {
  delete param_;
  param_ = param;
  if (param) {
    set_has_param();
  } else {
    clear_has_param();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.Network.param)
}

// required .nvdla_prototest_interface.NetworkLayer layers = 2;
inline bool Network::has_layers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Network::set_has_layers() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Network::clear_has_layers() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Network::clear_layers() {
  if (layers_ != NULL) layers_->::nvdla_prototest_interface::NetworkLayer::Clear();
  clear_has_layers();
}
inline const ::nvdla_prototest_interface::NetworkLayer& Network::layers() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Network.layers)
  return layers_ != NULL ? *layers_ : *default_instance_->layers_;
}
inline ::nvdla_prototest_interface::NetworkLayer* Network::mutable_layers() {
  set_has_layers();
  if (layers_ == NULL) layers_ = new ::nvdla_prototest_interface::NetworkLayer;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.Network.layers)
  return layers_;
}
inline ::nvdla_prototest_interface::NetworkLayer* Network::release_layers() {
  clear_has_layers();
  ::nvdla_prototest_interface::NetworkLayer* temp = layers_;
  layers_ = NULL;
  return temp;
}
inline void Network::set_allocated_layers(::nvdla_prototest_interface::NetworkLayer* layers) {
  delete layers_;
  layers_ = layers;
  if (layers) {
    set_has_layers();
  } else {
    clear_has_layers();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.Network.layers)
}

// required .nvdla_prototest_interface.LUTParamList lut_list = 3;
inline bool Network::has_lut_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Network::set_has_lut_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Network::clear_has_lut_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Network::clear_lut_list() {
  if (lut_list_ != NULL) lut_list_->::nvdla_prototest_interface::LUTParamList::Clear();
  clear_has_lut_list();
}
inline const ::nvdla_prototest_interface::LUTParamList& Network::lut_list() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Network.lut_list)
  return lut_list_ != NULL ? *lut_list_ : *default_instance_->lut_list_;
}
inline ::nvdla_prototest_interface::LUTParamList* Network::mutable_lut_list() {
  set_has_lut_list();
  if (lut_list_ == NULL) lut_list_ = new ::nvdla_prototest_interface::LUTParamList;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.Network.lut_list)
  return lut_list_;
}
inline ::nvdla_prototest_interface::LUTParamList* Network::release_lut_list() {
  clear_has_lut_list();
  ::nvdla_prototest_interface::LUTParamList* temp = lut_list_;
  lut_list_ = NULL;
  return temp;
}
inline void Network::set_allocated_lut_list(::nvdla_prototest_interface::LUTParamList* lut_list) {
  delete lut_list_;
  lut_list_ = lut_list;
  if (lut_list) {
    set_has_lut_list();
  } else {
    clear_has_lut_list();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.Network.lut_list)
}

// required .nvdla_prototest_interface.ROIDescription roi_list = 4;
inline bool Network::has_roi_list() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Network::set_has_roi_list() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Network::clear_has_roi_list() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Network::clear_roi_list() {
  if (roi_list_ != NULL) roi_list_->::nvdla_prototest_interface::ROIDescription::Clear();
  clear_has_roi_list();
}
inline const ::nvdla_prototest_interface::ROIDescription& Network::roi_list() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Network.roi_list)
  return roi_list_ != NULL ? *roi_list_ : *default_instance_->roi_list_;
}
inline ::nvdla_prototest_interface::ROIDescription* Network::mutable_roi_list() {
  set_has_roi_list();
  if (roi_list_ == NULL) roi_list_ = new ::nvdla_prototest_interface::ROIDescription;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.Network.roi_list)
  return roi_list_;
}
inline ::nvdla_prototest_interface::ROIDescription* Network::release_roi_list() {
  clear_has_roi_list();
  ::nvdla_prototest_interface::ROIDescription* temp = roi_list_;
  roi_list_ = NULL;
  return temp;
}
inline void Network::set_allocated_roi_list(::nvdla_prototest_interface::ROIDescription* roi_list) {
  delete roi_list_;
  roi_list_ = roi_list;
  if (roi_list) {
    set_has_roi_list();
  } else {
    clear_has_roi_list();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.Network.roi_list)
}

// -------------------------------------------------------------------

// TaskStatus

// required uint64 timestamp = 1;
inline bool TaskStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskStatus::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 TaskStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TaskStatus.timestamp)
  return timestamp_;
}
inline void TaskStatus::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.TaskStatus.timestamp)
}

// required uint32 status_engine = 2;
inline bool TaskStatus::has_status_engine() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskStatus::set_has_status_engine() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskStatus::clear_has_status_engine() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskStatus::clear_status_engine() {
  status_engine_ = 0u;
  clear_has_status_engine();
}
inline ::google::protobuf::uint32 TaskStatus::status_engine() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TaskStatus.status_engine)
  return status_engine_;
}
inline void TaskStatus::set_status_engine(::google::protobuf::uint32 value) {
  set_has_status_engine();
  status_engine_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.TaskStatus.status_engine)
}

// required uint32 subframe = 3;
inline bool TaskStatus::has_subframe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskStatus::set_has_subframe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskStatus::clear_has_subframe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskStatus::clear_subframe() {
  subframe_ = 0u;
  clear_has_subframe();
}
inline ::google::protobuf::uint32 TaskStatus::subframe() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TaskStatus.subframe)
  return subframe_;
}
inline void TaskStatus::set_subframe(::google::protobuf::uint32 value) {
  set_has_subframe();
  subframe_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.TaskStatus.subframe)
}

// required uint32 status_task = 4;
inline bool TaskStatus::has_status_task() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskStatus::set_has_status_task() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskStatus::clear_has_status_task() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskStatus::clear_status_task() {
  status_task_ = 0u;
  clear_has_status_task();
}
inline ::google::protobuf::uint32 TaskStatus::status_task() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TaskStatus.status_task)
  return status_task_;
}
inline void TaskStatus::set_status_task(::google::protobuf::uint32 value) {
  set_has_status_task();
  status_task_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.TaskStatus.status_task)
}

// -------------------------------------------------------------------

// Action

// repeated uint32 event_id = 1 [packed = true];
inline int Action::event_id_size() const {
  return event_id_.size();
}
inline void Action::clear_event_id() {
  event_id_.Clear();
}
inline ::google::protobuf::uint32 Action::event_id(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Action.event_id)
  return event_id_.Get(index);
}
inline void Action::set_event_id(int index, ::google::protobuf::uint32 value) {
  event_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Action.event_id)
}
inline void Action::add_event_id(::google::protobuf::uint32 value) {
  event_id_.Add(value);
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.Action.event_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Action::event_id() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.Action.event_id)
  return event_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Action::mutable_event_id() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.Action.event_id)
  return &event_id_;
}

// -------------------------------------------------------------------

// TaskSchedule

// optional .nvdla_prototest_interface.Action pre_actions = 1;
inline bool TaskSchedule::has_pre_actions() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskSchedule::set_has_pre_actions() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskSchedule::clear_has_pre_actions() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskSchedule::clear_pre_actions() {
  if (pre_actions_ != NULL) pre_actions_->::nvdla_prototest_interface::Action::Clear();
  clear_has_pre_actions();
}
inline const ::nvdla_prototest_interface::Action& TaskSchedule::pre_actions() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TaskSchedule.pre_actions)
  return pre_actions_ != NULL ? *pre_actions_ : *default_instance_->pre_actions_;
}
inline ::nvdla_prototest_interface::Action* TaskSchedule::mutable_pre_actions() {
  set_has_pre_actions();
  if (pre_actions_ == NULL) pre_actions_ = new ::nvdla_prototest_interface::Action;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.TaskSchedule.pre_actions)
  return pre_actions_;
}
inline ::nvdla_prototest_interface::Action* TaskSchedule::release_pre_actions() {
  clear_has_pre_actions();
  ::nvdla_prototest_interface::Action* temp = pre_actions_;
  pre_actions_ = NULL;
  return temp;
}
inline void TaskSchedule::set_allocated_pre_actions(::nvdla_prototest_interface::Action* pre_actions) {
  delete pre_actions_;
  pre_actions_ = pre_actions;
  if (pre_actions) {
    set_has_pre_actions();
  } else {
    clear_has_pre_actions();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.TaskSchedule.pre_actions)
}

// optional .nvdla_prototest_interface.Action post_actions = 2;
inline bool TaskSchedule::has_post_actions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskSchedule::set_has_post_actions() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskSchedule::clear_has_post_actions() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskSchedule::clear_post_actions() {
  if (post_actions_ != NULL) post_actions_->::nvdla_prototest_interface::Action::Clear();
  clear_has_post_actions();
}
inline const ::nvdla_prototest_interface::Action& TaskSchedule::post_actions() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TaskSchedule.post_actions)
  return post_actions_ != NULL ? *post_actions_ : *default_instance_->post_actions_;
}
inline ::nvdla_prototest_interface::Action* TaskSchedule::mutable_post_actions() {
  set_has_post_actions();
  if (post_actions_ == NULL) post_actions_ = new ::nvdla_prototest_interface::Action;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.TaskSchedule.post_actions)
  return post_actions_;
}
inline ::nvdla_prototest_interface::Action* TaskSchedule::release_post_actions() {
  clear_has_post_actions();
  ::nvdla_prototest_interface::Action* temp = post_actions_;
  post_actions_ = NULL;
  return temp;
}
inline void TaskSchedule::set_allocated_post_actions(::nvdla_prototest_interface::Action* post_actions) {
  delete post_actions_;
  post_actions_ = post_actions;
  if (post_actions) {
    set_has_post_actions();
  } else {
    clear_has_post_actions();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.TaskSchedule.post_actions)
}

// -------------------------------------------------------------------

// TasksData

// optional uint32 task_id = 1;
inline bool TasksData::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TasksData::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TasksData::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TasksData::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 TasksData::task_id() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TasksData.task_id)
  return task_id_;
}
inline void TasksData::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.TasksData.task_id)
}

// required .nvdla_prototest_interface.EngineID engine_id = 2;
inline bool TasksData::has_engine_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TasksData::set_has_engine_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TasksData::clear_has_engine_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TasksData::clear_engine_id() {
  engine_id_ = 0;
  clear_has_engine_id();
}
inline ::nvdla_prototest_interface::EngineID TasksData::engine_id() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TasksData.engine_id)
  return static_cast< ::nvdla_prototest_interface::EngineID >(engine_id_);
}
inline void TasksData::set_engine_id(::nvdla_prototest_interface::EngineID value) {
  assert(::nvdla_prototest_interface::EngineID_IsValid(value));
  set_has_engine_id();
  engine_id_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.TasksData.engine_id)
}

// required .nvdla_prototest_interface.Network network = 3;
inline bool TasksData::has_network() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TasksData::set_has_network() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TasksData::clear_has_network() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TasksData::clear_network() {
  if (network_ != NULL) network_->::nvdla_prototest_interface::Network::Clear();
  clear_has_network();
}
inline const ::nvdla_prototest_interface::Network& TasksData::network() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TasksData.network)
  return network_ != NULL ? *network_ : *default_instance_->network_;
}
inline ::nvdla_prototest_interface::Network* TasksData::mutable_network() {
  set_has_network();
  if (network_ == NULL) network_ = new ::nvdla_prototest_interface::Network;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.TasksData.network)
  return network_;
}
inline ::nvdla_prototest_interface::Network* TasksData::release_network() {
  clear_has_network();
  ::nvdla_prototest_interface::Network* temp = network_;
  network_ = NULL;
  return temp;
}
inline void TasksData::set_allocated_network(::nvdla_prototest_interface::Network* network) {
  delete network_;
  network_ = network;
  if (network) {
    set_has_network();
  } else {
    clear_has_network();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.TasksData.network)
}

// optional .nvdla_prototest_interface.TaskSchedule schedule = 4;
inline bool TasksData::has_schedule() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TasksData::set_has_schedule() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TasksData::clear_has_schedule() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TasksData::clear_schedule() {
  if (schedule_ != NULL) schedule_->::nvdla_prototest_interface::TaskSchedule::Clear();
  clear_has_schedule();
}
inline const ::nvdla_prototest_interface::TaskSchedule& TasksData::schedule() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TasksData.schedule)
  return schedule_ != NULL ? *schedule_ : *default_instance_->schedule_;
}
inline ::nvdla_prototest_interface::TaskSchedule* TasksData::mutable_schedule() {
  set_has_schedule();
  if (schedule_ == NULL) schedule_ = new ::nvdla_prototest_interface::TaskSchedule;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.TasksData.schedule)
  return schedule_;
}
inline ::nvdla_prototest_interface::TaskSchedule* TasksData::release_schedule() {
  clear_has_schedule();
  ::nvdla_prototest_interface::TaskSchedule* temp = schedule_;
  schedule_ = NULL;
  return temp;
}
inline void TasksData::set_allocated_schedule(::nvdla_prototest_interface::TaskSchedule* schedule) {
  delete schedule_;
  schedule_ = schedule;
  if (schedule) {
    set_has_schedule();
  } else {
    clear_has_schedule();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.TasksData.schedule)
}

// optional .nvdla_prototest_interface.TaskStatus task_status = 5;
inline bool TasksData::has_task_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TasksData::set_has_task_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TasksData::clear_has_task_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TasksData::clear_task_status() {
  if (task_status_ != NULL) task_status_->::nvdla_prototest_interface::TaskStatus::Clear();
  clear_has_task_status();
}
inline const ::nvdla_prototest_interface::TaskStatus& TasksData::task_status() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TasksData.task_status)
  return task_status_ != NULL ? *task_status_ : *default_instance_->task_status_;
}
inline ::nvdla_prototest_interface::TaskStatus* TasksData::mutable_task_status() {
  set_has_task_status();
  if (task_status_ == NULL) task_status_ = new ::nvdla_prototest_interface::TaskStatus;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.TasksData.task_status)
  return task_status_;
}
inline ::nvdla_prototest_interface::TaskStatus* TasksData::release_task_status() {
  clear_has_task_status();
  ::nvdla_prototest_interface::TaskStatus* temp = task_status_;
  task_status_ = NULL;
  return temp;
}
inline void TasksData::set_allocated_task_status(::nvdla_prototest_interface::TaskStatus* task_status) {
  delete task_status_;
  task_status_ = task_status;
  if (task_status) {
    set_has_task_status();
  } else {
    clear_has_task_status();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.TasksData.task_status)
}

// optional uint32 task_timeout = 6 [default = 4294967295];
inline bool TasksData::has_task_timeout() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TasksData::set_has_task_timeout() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TasksData::clear_has_task_timeout() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TasksData::clear_task_timeout() {
  task_timeout_ = 4294967295u;
  clear_has_task_timeout();
}
inline ::google::protobuf::uint32 TasksData::task_timeout() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TasksData.task_timeout)
  return task_timeout_;
}
inline void TasksData::set_task_timeout(::google::protobuf::uint32 value) {
  set_has_task_timeout();
  task_timeout_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.TasksData.task_timeout)
}

// optional int32 task_result = 7 [default = 0];
inline bool TasksData::has_task_result() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TasksData::set_has_task_result() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TasksData::clear_has_task_result() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TasksData::clear_task_result() {
  task_result_ = 0;
  clear_has_task_result();
}
inline ::google::protobuf::int32 TasksData::task_result() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TasksData.task_result)
  return task_result_;
}
inline void TasksData::set_task_result(::google::protobuf::int32 value) {
  set_has_task_result();
  task_result_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.TasksData.task_result)
}

// -------------------------------------------------------------------

// Event

// required uint32 event_id = 1;
inline bool Event::has_event_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_event_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_event_id() {
  event_id_ = 0u;
  clear_has_event_id();
}
inline ::google::protobuf::uint32 Event::event_id() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Event.event_id)
  return event_id_;
}
inline void Event::set_event_id(::google::protobuf::uint32 value) {
  set_has_event_id();
  event_id_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Event.event_id)
}

// required .nvdla_prototest_interface.Event.EventType event_type = 2;
inline bool Event::has_event_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_event_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_event_type() {
  event_type_ = 0;
  clear_has_event_type();
}
inline ::nvdla_prototest_interface::Event_EventType Event::event_type() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Event.event_type)
  return static_cast< ::nvdla_prototest_interface::Event_EventType >(event_type_);
}
inline void Event::set_event_type(::nvdla_prototest_interface::Event_EventType value) {
  assert(::nvdla_prototest_interface::Event_EventType_IsValid(value));
  set_has_event_type();
  event_type_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Event.event_type)
}

// required uint32 event_flags = 3;
inline bool Event::has_event_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event::set_has_event_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event::clear_has_event_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event::clear_event_flags() {
  event_flags_ = 0u;
  clear_has_event_flags();
}
inline ::google::protobuf::uint32 Event::event_flags() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Event.event_flags)
  return event_flags_;
}
inline void Event::set_event_flags(::google::protobuf::uint32 value) {
  set_has_event_flags();
  event_flags_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Event.event_flags)
}

// optional uint32 event_timeout = 4 [default = 4294967295];
inline bool Event::has_event_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Event::set_has_event_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Event::clear_has_event_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Event::clear_event_timeout() {
  event_timeout_ = 4294967295u;
  clear_has_event_timeout();
}
inline ::google::protobuf::uint32 Event::event_timeout() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Event.event_timeout)
  return event_timeout_;
}
inline void Event::set_event_timeout(::google::protobuf::uint32 value) {
  set_has_event_timeout();
  event_timeout_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.Event.event_timeout)
}

// -------------------------------------------------------------------

// EventList

// repeated .nvdla_prototest_interface.Event event = 1;
inline int EventList::event_size() const {
  return event_.size();
}
inline void EventList::clear_event() {
  event_.Clear();
}
inline const ::nvdla_prototest_interface::Event& EventList::event(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.EventList.event)
  return event_.Get(index);
}
inline ::nvdla_prototest_interface::Event* EventList::mutable_event(int index) {
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.EventList.event)
  return event_.Mutable(index);
}
inline ::nvdla_prototest_interface::Event* EventList::add_event() {
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.EventList.event)
  return event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Event >&
EventList::event() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.EventList.event)
  return event_;
}
inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::Event >*
EventList::mutable_event() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.EventList.event)
  return &event_;
}

// -------------------------------------------------------------------

// SubmitSlot

// repeated uint32 task_id = 1;
inline int SubmitSlot::task_id_size() const {
  return task_id_.size();
}
inline void SubmitSlot::clear_task_id() {
  task_id_.Clear();
}
inline ::google::protobuf::uint32 SubmitSlot::task_id(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.SubmitSlot.task_id)
  return task_id_.Get(index);
}
inline void SubmitSlot::set_task_id(int index, ::google::protobuf::uint32 value) {
  task_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.SubmitSlot.task_id)
}
inline void SubmitSlot::add_task_id(::google::protobuf::uint32 value) {
  task_id_.Add(value);
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.SubmitSlot.task_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SubmitSlot::task_id() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.SubmitSlot.task_id)
  return task_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SubmitSlot::mutable_task_id() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.SubmitSlot.task_id)
  return &task_id_;
}

// -------------------------------------------------------------------

// TestInfo

// required uint32 num_tasks = 1;
inline bool TestInfo::has_num_tasks() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestInfo::set_has_num_tasks() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestInfo::clear_has_num_tasks() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestInfo::clear_num_tasks() {
  num_tasks_ = 0u;
  clear_has_num_tasks();
}
inline ::google::protobuf::uint32 TestInfo::num_tasks() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TestInfo.num_tasks)
  return num_tasks_;
}
inline void TestInfo::set_num_tasks(::google::protobuf::uint32 value) {
  set_has_num_tasks();
  num_tasks_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.TestInfo.num_tasks)
}

// required uint32 num_buffers = 2;
inline bool TestInfo::has_num_buffers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestInfo::set_has_num_buffers() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestInfo::clear_has_num_buffers() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestInfo::clear_num_buffers() {
  num_buffers_ = 0u;
  clear_has_num_buffers();
}
inline ::google::protobuf::uint32 TestInfo::num_buffers() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TestInfo.num_buffers)
  return num_buffers_;
}
inline void TestInfo::set_num_buffers(::google::protobuf::uint32 value) {
  set_has_num_buffers();
  num_buffers_ = value;
  // @@protoc_insertion_point(field_set:nvdla_prototest_interface.TestInfo.num_buffers)
}

// repeated .nvdla_prototest_interface.TasksData task = 3;
inline int TestInfo::task_size() const {
  return task_.size();
}
inline void TestInfo::clear_task() {
  task_.Clear();
}
inline const ::nvdla_prototest_interface::TasksData& TestInfo::task(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TestInfo.task)
  return task_.Get(index);
}
inline ::nvdla_prototest_interface::TasksData* TestInfo::mutable_task(int index) {
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.TestInfo.task)
  return task_.Mutable(index);
}
inline ::nvdla_prototest_interface::TasksData* TestInfo::add_task() {
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.TestInfo.task)
  return task_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::TasksData >&
TestInfo::task() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.TestInfo.task)
  return task_;
}
inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::TasksData >*
TestInfo::mutable_task() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.TestInfo.task)
  return &task_;
}

// optional .nvdla_prototest_interface.EventList event_list = 4;
inline bool TestInfo::has_event_list() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestInfo::set_has_event_list() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestInfo::clear_has_event_list() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestInfo::clear_event_list() {
  if (event_list_ != NULL) event_list_->::nvdla_prototest_interface::EventList::Clear();
  clear_has_event_list();
}
inline const ::nvdla_prototest_interface::EventList& TestInfo::event_list() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TestInfo.event_list)
  return event_list_ != NULL ? *event_list_ : *default_instance_->event_list_;
}
inline ::nvdla_prototest_interface::EventList* TestInfo::mutable_event_list() {
  set_has_event_list();
  if (event_list_ == NULL) event_list_ = new ::nvdla_prototest_interface::EventList;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.TestInfo.event_list)
  return event_list_;
}
inline ::nvdla_prototest_interface::EventList* TestInfo::release_event_list() {
  clear_has_event_list();
  ::nvdla_prototest_interface::EventList* temp = event_list_;
  event_list_ = NULL;
  return temp;
}
inline void TestInfo::set_allocated_event_list(::nvdla_prototest_interface::EventList* event_list) {
  delete event_list_;
  event_list_ = event_list;
  if (event_list) {
    set_has_event_list();
  } else {
    clear_has_event_list();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.TestInfo.event_list)
}

// repeated .nvdla_prototest_interface.SubmitSlot slots = 5;
inline int TestInfo::slots_size() const {
  return slots_.size();
}
inline void TestInfo::clear_slots() {
  slots_.Clear();
}
inline const ::nvdla_prototest_interface::SubmitSlot& TestInfo::slots(int index) const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.TestInfo.slots)
  return slots_.Get(index);
}
inline ::nvdla_prototest_interface::SubmitSlot* TestInfo::mutable_slots(int index) {
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.TestInfo.slots)
  return slots_.Mutable(index);
}
inline ::nvdla_prototest_interface::SubmitSlot* TestInfo::add_slots() {
  // @@protoc_insertion_point(field_add:nvdla_prototest_interface.TestInfo.slots)
  return slots_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::SubmitSlot >&
TestInfo::slots() const {
  // @@protoc_insertion_point(field_list:nvdla_prototest_interface.TestInfo.slots)
  return slots_;
}
inline ::google::protobuf::RepeatedPtrField< ::nvdla_prototest_interface::SubmitSlot >*
TestInfo::mutable_slots() {
  // @@protoc_insertion_point(field_mutable_list:nvdla_prototest_interface.TestInfo.slots)
  return &slots_;
}

// -------------------------------------------------------------------

// Test

// required .nvdla_prototest_interface.TestInfo test = 1;
inline bool Test::has_test() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test::set_has_test() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test::clear_has_test() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test::clear_test() {
  if (test_ != NULL) test_->::nvdla_prototest_interface::TestInfo::Clear();
  clear_has_test();
}
inline const ::nvdla_prototest_interface::TestInfo& Test::test() const {
  // @@protoc_insertion_point(field_get:nvdla_prototest_interface.Test.test)
  return test_ != NULL ? *test_ : *default_instance_->test_;
}
inline ::nvdla_prototest_interface::TestInfo* Test::mutable_test() {
  set_has_test();
  if (test_ == NULL) test_ = new ::nvdla_prototest_interface::TestInfo;
  // @@protoc_insertion_point(field_mutable:nvdla_prototest_interface.Test.test)
  return test_;
}
inline ::nvdla_prototest_interface::TestInfo* Test::release_test() {
  clear_has_test();
  ::nvdla_prototest_interface::TestInfo* temp = test_;
  test_ = NULL;
  return temp;
}
inline void Test::set_allocated_test(::nvdla_prototest_interface::TestInfo* test) {
  delete test_;
  test_ = test;
  if (test) {
    set_has_test();
  } else {
    clear_has_test();
  }
  // @@protoc_insertion_point(field_set_allocated:nvdla_prototest_interface.Test.test)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace nvdla_prototest_interface

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::nvdla_prototest_interface::SDPOp_SDPOpMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::SDPOp_SDPOpMode>() {
  return ::nvdla_prototest_interface::SDPOp_SDPOpMode_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::PDPOpDesc_PoolingMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::PDPOpDesc_PoolingMode>() {
  return ::nvdla_prototest_interface::PDPOpDesc_PoolingMode_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::Consumer_EventType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::Consumer_EventType>() {
  return ::nvdla_prototest_interface::Consumer_EventType_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::Event_EventType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::Event_EventType>() {
  return ::nvdla_prototest_interface::Event_EventType_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::DataPrecision> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::DataPrecision>() {
  return ::nvdla_prototest_interface::DataPrecision_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::MemType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::MemType>() {
  return ::nvdla_prototest_interface::MemType_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::MemFlag> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::MemFlag>() {
  return ::nvdla_prototest_interface::MemFlag_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::EngineID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::EngineID>() {
  return ::nvdla_prototest_interface::EngineID_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::LayerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::LayerType>() {
  return ::nvdla_prototest_interface::LayerType_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::ALUType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::ALUType>() {
  return ::nvdla_prototest_interface::ALUType_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::SDPOpType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::SDPOpType>() {
  return ::nvdla_prototest_interface::SDPOpType_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::LUTLOGSize> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::LUTLOGSize>() {
  return ::nvdla_prototest_interface::LUTLOGSize_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::LUTTable> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::LUTTable>() {
  return ::nvdla_prototest_interface::LUTTable_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::LUTMethod> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::LUTMethod>() {
  return ::nvdla_prototest_interface::LUTMethod_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::LUTPriority> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::LUTPriority>() {
  return ::nvdla_prototest_interface::LUTPriority_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::ConvMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::ConvMode>() {
  return ::nvdla_prototest_interface::ConvMode_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::ConvPixelMAP> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::ConvPixelMAP>() {
  return ::nvdla_prototest_interface::ConvPixelMAP_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::PixelOverride> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::PixelOverride>() {
  return ::nvdla_prototest_interface::PixelOverride_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::PoolSize> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::PoolSize>() {
  return ::nvdla_prototest_interface::PoolSize_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::RUBIKMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::RUBIKMode>() {
  return ::nvdla_prototest_interface::RUBIKMode_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::WeightFormat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::WeightFormat>() {
  return ::nvdla_prototest_interface::WeightFormat_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::MeanFormat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::MeanFormat>() {
  return ::nvdla_prototest_interface::MeanFormat_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::SDPActivation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::SDPActivation>() {
  return ::nvdla_prototest_interface::SDPActivation_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::DataFormat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::DataFormat>() {
  return ::nvdla_prototest_interface::DataFormat_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::FillerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::FillerType>() {
  return ::nvdla_prototest_interface::FillerType_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::FileType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::FileType>() {
  return ::nvdla_prototest_interface::FileType_descriptor();
}
template <> struct is_proto_enum< ::nvdla_prototest_interface::DataType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nvdla_prototest_interface::DataType>() {
  return ::nvdla_prototest_interface::DataType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_DlaPrototestInterface_2eproto__INCLUDED
